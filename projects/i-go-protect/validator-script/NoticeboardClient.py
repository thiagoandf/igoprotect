# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "setup(uint64,uint64,uint64,uint64,address,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "create_validator_ad(pay,pay,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void": {
            "structs": {
                "val_config_man": {
                    "name": "ValConfigMan",
                    "elements": [
                        [
                            "hw_cat",
                            "uint64"
                        ],
                        [
                            "min_amt",
                            "uint64"
                        ],
                        [
                            "max_amt",
                            "uint64"
                        ],
                        [
                            "fee_setup",
                            "uint64"
                        ],
                        [
                            "fee_round",
                            "uint64"
                        ],
                        [
                            "deposit",
                            "uint64"
                        ],
                        [
                            "setup_rounds",
                            "uint64"
                        ],
                        [
                            "confirmation_rounds",
                            "uint64"
                        ],
                        [
                            "max_breach",
                            "uint64"
                        ],
                        [
                            "breach_rounds",
                            "uint64"
                        ],
                        [
                            "uptime_gar",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "set_validator_ad_extra((byte[30],byte[70]))void": {
            "structs": {
                "val_config_extra": {
                    "name": "ValConfigExtra",
                    "elements": [
                        [
                            "name",
                            "byte[30]"
                        ],
                        [
                            "link",
                            "byte[70]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end_validator_ad()void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "val_withdraw_earnings()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "withdraw_balance()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "withdraw_depoist()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "user_opt_in()void": {
            "call_config": {
                "opt_in": "CALL"
            }
        },
        "create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "confirm_keys(uint64,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_generated(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_confirmed(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end_expired_or_breached_delegator_contract(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end_active_delegator_contract(uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuYXBwcm92YWxfcHJvZ3JhbToKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9lbnRyeXBvaW50QDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fZW50cnlwb2ludEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AyMgogICAgbWV0aG9kICJzZXR1cCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxwYXkpdm9pZCIKICAgIG1ldGhvZCAiY3JlYXRlX3ZhbGlkYXRvcl9hZChwYXkscGF5LHBheSl2b2lkIgogICAgbWV0aG9kICJzZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeSgodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzZXRfdmFsaWRhdG9yX2FkX2V4dHJhKChieXRlWzMwXSxieXRlWzcwXSkpdm9pZCIKICAgIG1ldGhvZCAiZW5kX3ZhbGlkYXRvcl9hZCgpdm9pZCIKICAgIG1ldGhvZCAidmFsX3dpdGhkcmF3X2Vhcm5pbmdzKCl1aW50NjQiCiAgICBtZXRob2QgIndpdGhkcmF3X2JhbGFuY2UoKXVpbnQ2NCIKICAgIG1ldGhvZCAid2l0aGRyYXdfZGVwb2lzdCgpdWludDY0IgogICAgbWV0aG9kICJ1c2VyX29wdF9pbigpdm9pZCIKICAgIG1ldGhvZCAiY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCh1aW50NjQscGF5LHBheSxwYXksdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJkZXBvc2l0X2tleXMoYWRkcmVzcyxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJjb25maXJtX2tleXModWludDY0LHBheSl2b2lkIgogICAgbWV0aG9kICJrZXlzX25vdF9nZW5lcmF0ZWQoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJrZXlzX25vdF9jb25maXJtZWQoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJlbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3QoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdCh1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fc2V0dXBfcm91dGVANCBtYWluX2NyZWF0ZV92YWxpZGF0b3JfYWRfcm91dGVANSBtYWluX3NldF92YWxpZGF0b3JfYWRfbWFuZGF0b3J5X3JvdXRlQDYgbWFpbl9zZXRfdmFsaWRhdG9yX2FkX2V4dHJhX3JvdXRlQDcgbWFpbl9lbmRfdmFsaWRhdG9yX2FkX3JvdXRlQDggbWFpbl92YWxfd2l0aGRyYXdfZWFybmluZ3Nfcm91dGVAOSBtYWluX3dpdGhkcmF3X2JhbGFuY2Vfcm91dGVAMTAgbWFpbl93aXRoZHJhd19kZXBvaXN0X3JvdXRlQDExIG1haW5fdXNlcl9vcHRfaW5fcm91dGVAMTIgbWFpbl9jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDEzIG1haW5fZGVwb3NpdF9rZXlzX3JvdXRlQDE0IG1haW5fY29uZmlybV9rZXlzX3JvdXRlQDE1IG1haW5fa2V5c19ub3RfZ2VuZXJhdGVkX3JvdXRlQDE2IG1haW5fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDE3IG1haW5fZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDE4IG1haW5fZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3Rfcm91dGVAMTkKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fc2V0dXBfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBzZXR1cAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfdmFsaWRhdG9yX2FkX3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTUyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMwogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNyZWF0ZV92YWxpZGF0b3JfYWQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnlfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIxNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnkKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZhbGlkYXRvcl9hZF9leHRyYV9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0NAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQ0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBzZXRfdmFsaWRhdG9yX2FkX2V4dHJhCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF92YWxpZGF0b3JfYWRfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNjMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGVuZF92YWxpZGF0b3JfYWQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fdmFsX3dpdGhkcmF3X2Vhcm5pbmdzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjk2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB2YWxfd2l0aGRyYXdfZWFybmluZ3MKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fd2l0aGRyYXdfYmFsYW5jZV9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMjEtMzI2CiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAgICAgICAgICAgRm9yIGFsbCB1c2VycyAgICAgICAgICAgLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIEZPUiBGVVRVUkU6IFRoaW5rIGFib3V0IGlmIGl0IHdvdWxkIGJlIG1vcmUgY29udmVuaWVudCB0aGF0IGFueW9uZSBjb3VsZCB0cmlnZ2VyIHdpdGhkcmF3YWwgb2YgYmFsYW5jZSBhbmQgZGVwb3NpdAogICAgLy8gIyBFc3BlY2lhbGx5IHdpdGggb3BlbiBvcHRpb25zIG9mIGUuZy4ga2V5c19ub3RfZ2VuZXJhdGVkCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhd19iYWxhbmNlCiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X2RlcG9pc3Rfcm91dGVAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhd19kZXBvaXN0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3VzZXJfb3B0X2luX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM2NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJPcHRJbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgaW50IE9wdEluCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBPcHRJbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgdXNlcl9vcHRfaW4KICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdF9yb3V0ZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozODcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAzCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDIKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM4NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9kZXBvc2l0X2tleXNfcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDUwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGRlcG9zaXRfa2V5cwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jb25maXJtX2tleXNfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ4NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29uZmlybV9rZXlzCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2tleXNfbm90X2dlbmVyYXRlZF9yb3V0ZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19ub3RfZ2VuZXJhdGVkCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2tleXNfbm90X2NvbmZpcm1lZF9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1ODIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19ub3RfY29uZmlybWVkCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0CiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY0NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQ1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5zZXR1cChkZXBvc2l0X3ZhbF9taW46IGJ5dGVzLCBkZXBvc2l0X2RlbF9taW46IGJ5dGVzLCB2YWxfZWFybl9mYWN0b3I6IGJ5dGVzLCB2YWxfZmFjdG9yeV9hcHBfaWQ6IGJ5dGVzLCBtYW5hZ2VyOiBieXRlcywgbWJyOiB1aW50NjQpIC0+IHZvaWQ6CnNldHVwOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEwNS0xMTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0dXAoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZXBvc2l0X3ZhbF9taW46IGFyYzQuVUludDY0LAogICAgLy8gICAgIGRlcG9zaXRfZGVsX21pbjogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgdmFsX2Vhcm5fZmFjdG9yOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICB2YWxfZmFjdG9yeV9hcHBfaWQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIG1hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBtYnI6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTE1CiAgICAvLyBhc3NlcnQgbm90IHNlbGYubGl2ZSwgIk5vdGljZWJvYXJkIGlzIG5vdCB5ZXQgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBub3QgeWV0IGxpdmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTE3CiAgICAvLyBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMTYtMTE4CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcwogICAgLy8gKSwgIlNldHVwIGNhbiBiZSBkb25lIG9ubHkgYnkgY29udHJhY3QgY3JlYXRvci4iCiAgICBhc3NlcnQgLy8gU2V0dXAgY2FuIGJlIGRvbmUgb25seSBieSBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEyMQogICAgLy8gZGVwb3NpdF9kZWxfbWluLm5hdGl2ZSAqIE1BWF9ERUxfQ05UIDw9IGRlcG9zaXRfdmFsX21pbi5uYXRpdmUKICAgIGZyYW1lX2RpZyAtNQogICAgYnRvaQogICAgZHVwCiAgICBpbnQgNAogICAgKgogICAgZnJhbWVfZGlnIC02CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTIwLTEyMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBkZXBvc2l0X2RlbF9taW4ubmF0aXZlICogTUFYX0RFTF9DTlQgPD0gZGVwb3NpdF92YWxfbWluLm5hdGl2ZQogICAgLy8gKSwgIlZhbGlkYXRvcidzIGRlcG9zaXQgbXVzdCBjb3ZlciBhdCBsZWFzdCBlYWNoIGRlbGVnYXRvcidzIGRlcG9zaXQuIgogICAgYXNzZXJ0IC8vIFZhbGlkYXRvcidzIGRlcG9zaXQgbXVzdCBjb3ZlciBhdCBsZWFzdCBlYWNoIGRlbGVnYXRvcidzIGRlcG9zaXQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI0CiAgICAvLyBzZWxmLmRlcG9zaXRfdmFsX21pbiA9IGRlcG9zaXRfdmFsX21pbi5uYXRpdmUKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI1CiAgICAvLyBzZWxmLmRlcG9zaXRfZGVsX21pbiA9IGRlcG9zaXRfZGVsX21pbi5uYXRpdmUKICAgIGJ5dGUgImRlcG9zaXRfZGVsX21pbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI4CiAgICAvLyBVSW50NjQoMCkgPCB2YWxfZWFybl9mYWN0b3IubmF0aXZlIDwgVUludDY0KDEwMCkKICAgIGZyYW1lX2RpZyAtNAogICAgYnRvaQogICAgZHVwCiAgICBieiBzZXR1cF9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAwCiAgICBpbnQgMTAwCiAgICA8CiAgICBieiBzZXR1cF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIHNldHVwX2Jvb2xfbWVyZ2VANAoKc2V0dXBfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCnNldHVwX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMjctMTI5CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFVJbnQ2NCgwKSA8IHZhbF9lYXJuX2ZhY3Rvci5uYXRpdmUgPCBVSW50NjQoMTAwKQogICAgLy8gKSwgIlZhbGlkYXRvciBmYWN0b3IgY2FuJ3QgYmUgbGFyZ2VyIHRoYW4gMTAwIG9yIHNtYWxsZXIgdGhhbiAwLiIKICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgZmFjdG9yIGNhbid0IGJlIGxhcmdlciB0aGFuIDEwMCBvciBzbWFsbGVyIHRoYW4gMC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzEKICAgIC8vIHNlbGYudmFsX2Vhcm5fZmFjdG9yID0gdmFsX2Vhcm5fZmFjdG9yLm5hdGl2ZQogICAgYnl0ZSAidmFsX2Vhcm5fZmFjdG9yIgogICAgZnJhbWVfZGlnIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTMyCiAgICAvLyBzZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCA9IHZhbF9mYWN0b3J5X2FwcF9pZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMwogICAgYnRvaQogICAgYnl0ZSAidmFsX2ZhY3RvcnlfYXBwX2lkIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzMKICAgIC8vIHNlbGYubWFuYWdlciA9IG1hbmFnZXIubmF0aXZlCiAgICBieXRlICJtYW5hZ2VyIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEzNS0xMzYKICAgIC8vICMgQ3JlYXRlIGJveCBmb3IgbGlzdCBvZiB2YWxpZGF0b3JzCiAgICAvLyBhc3NlcnQgb3AuQm94LmNyZWF0ZShCeXRlcyhWQUxfTElTVCksIFZBTF9MSVNUX0VMX0JZVEVfU0laRSAqIE1BWF9WQUxfQ05UKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBpbnQgODAwCiAgICBib3hfY3JlYXRlCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDAKICAgIC8vIG1ici5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzgtMTQxCiAgICAvLyAjIEFzc2VydCBpbmNyZWFzZSBpbiBtaW5pbXVtIGJhbGFuY2UgcmVxdWlyZW1lbnQgZm9yIGJveCBmb3IgdmFsaWRhdG9yIGxpc3QKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJNQlIgaW5jcmVhc2UgZm9yIGJveCBvZiB2YWxpZGF0b3IgbGlzdCBuZWVkcyB0byBiZSBjb3ZlcmVkLiIKICAgIGFzc2VydCAvLyBNQlIgaW5jcmVhc2UgZm9yIGJveCBvZiB2YWxpZGF0b3IgbGlzdCBuZWVkcyB0byBiZSBjb3ZlcmVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE0MgogICAgLy8gYXNzZXJ0IG1ici5hbW91bnQgPT0gTUJSX0JPWF9WQUxfTElTVF9DUkVBVElPTgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludCAzMjU3MDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDQKICAgIC8vIHNlbGYubGl2ZSA9IFRydWUKICAgIGJ5dGUgImxpdmUiCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDYKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmNyZWF0ZV92YWxpZGF0b3JfYWQoZGVwb3NpdDogdWludDY0LCBtYnJfZmFjdG9yeTogdWludDY0LCBtYnJfdmFsOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZV92YWxpZGF0b3JfYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTUyLTE1OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfdmFsaWRhdG9yX2FkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVwb3NpdDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWJyX2ZhY3Rvcnk6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIG1icl92YWw6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTU5CiAgICAvLyBhc3NlcnQgc2VsZi5saXZlLCAiTm90aWNlYm9hcmQgaXMgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBsaXZlLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE2NC0xNjUKICAgIC8vICMgQW4gYWNjb3VudCBjYW4gaGF2ZSBvbmx5IG9uZSByb2xlIGluIHRoZSBwbGF0Zm9ybSAtIGVpdGhlciBVc2VyQ29udHJhY3Qgb3IgR2VuZXJhbFZhbGlkYXRvckFkCiAgICAvLyBhc3NlcnQgc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdID09IDAsICJBY2NvdW50IGRvZXNuJ3QgeWV0IGhhdmUgYSByb2xlLiIKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAhCiAgICBhc3NlcnQgLy8gQWNjb3VudCBkb2Vzbid0IHlldCBoYXZlIGEgcm9sZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNzAKICAgIC8vIGRlcG9zaXQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTY3LTE3MQogICAgLy8gIyBGT1IgRlVUVVJFOiBDaGVjayBpZiB2YWxpZGF0b3IgYWxyZWFkeSBoYXMgc3VmZmljaWVudCBkZXBvc2l0IChpZiBpdCB3YXNuJ3Qgd2l0aGRyYXduKS4gQnV0IE1CUiBzdGlsbCBuZWVkcyB0byBiZSBwYWlkLgogICAgLy8gIyBBc3NlcnQgbWluaW11bSB2YWxpZGF0b3IgZGVwb3NpdCB3YXMgcGFpZAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBkZXBvc2l0LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJWYWxpZGF0b3IgZGVwb3NpdCB3YXNuJ3QgbWFkZSB0byBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGRlcG9zaXQgd2Fzbid0IG1hZGUgdG8gbm90aWNlYm9hcmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTczCiAgICAvLyBkZXBvc2l0LmFtb3VudCA+PSBzZWxmLmRlcG9zaXRfdmFsX21pbgogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBBbW91bnQKICAgIGludCAwCiAgICBieXRlICJkZXBvc2l0X3ZhbF9taW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfdmFsX21pbiBleGlzdHMKICAgIGRpZyAxCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3Mi0xNzQKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVwb3NpdC5hbW91bnQgPj0gc2VsZi5kZXBvc2l0X3ZhbF9taW4KICAgIC8vICksICJWYWxpZGF0b3IgZGlkbid0IGRlcG9zaXQgbWluaW11bSByZXF1aXJlZCBhbW91bnQuIgogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBkaWRuJ3QgZGVwb3NpdCBtaW5pbXVtIHJlcXVpcmVkIGFtb3VudC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNzYtMTc3CiAgICAvLyAjIE1hcmsgZGVwb3NpdCBhbW91bnQgaW4gdXNlcidzIGxvY2FsIHN0b3JhZ2UKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPSBkZXBvc2l0LmFtb3VudAogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICBkaWcgMgogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3OS0xODcKICAgIC8vICMgQ3JlYXRlIFZhbGRpYXRvckFkCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdmYWN0b3J5VmFsaWRhdG9yQWQuZ2VuZXJhdGVfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBzZWxmLnZhbF9lYXJuX2ZhY3RvciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE4MgogICAgLy8gYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE4MwogICAgLy8gc2VsZi52YWxfZWFybl9mYWN0b3IsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2Vhcm5fZmFjdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfZWFybl9mYWN0b3IgZXhpc3RzCiAgICBpdG9iCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTg0CiAgICAvLyBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODUKICAgIC8vIGFwcF9pZD1zZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCwKICAgIGludCAwCiAgICBieXRlICJ2YWxfZmFjdG9yeV9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9mYWN0b3J5X2FwcF9pZCBleGlzdHMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3OS0xODcKICAgIC8vICMgQ3JlYXRlIFZhbGRpYXRvckFkCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdmYWN0b3J5VmFsaWRhdG9yQWQuZ2VuZXJhdGVfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBzZWxmLnZhbF9lYXJuX2ZhY3RvciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgbWV0aG9kICJnZW5lcmF0ZV92YWxpZGF0b3JfYWQoYWRkcmVzcyx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODYKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTc5LTE4NwogICAgLy8gIyBDcmVhdGUgVmFsZGlhdG9yQWQKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2ZhY3RvcnlWYWxpZGF0b3JBZC5nZW5lcmF0ZV92YWxpZGF0b3JfYWQsCiAgICAvLyAgICAgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHNlbGYudmFsX2Vhcm5fZmFjdG9yLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXQuYW1vdW50KSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi52YWxfZmFjdG9yeV9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTg4CiAgICAvLyBjcmVhdGVkX2FwcF9pZCA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODktMTkwCiAgICAvLyAjIFN0b3JlIGNyZWF0ZWQgR2VuZXJhbFZhbGlkYXRvckFkIElEIGluIHZhbGlkYXRvcidzIGxvY2FsIHN0b3JhZ2UKICAgIC8vIHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXSA9IGNyZWF0ZWRfYXBwX2lkCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgZGlnIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxOTItMTkzCiAgICAvLyAjIEFkZCBuZXcgR2VuZXJhbFZhbGlkYXRvckFkIHRvIGxpc3Qgb2YgdmFsaWRhdG9ycwogICAgLy8gYXNzZXJ0IHZhbF9saXN0X2FkZChjcmVhdGVkX2FwcF9pZCksICJWYWxpZGF0b3IgbGlzdCBpcyBmdWxsLiIKICAgIGR1cAogICAgY2FsbHN1YiB2YWxfbGlzdF9hZGQKICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgbGlzdCBpcyBmdWxsLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE5OAogICAgLy8gbWJyX2ZhY3RvcnkucmVjZWl2ZXIgPT0gQXBwbGljYXRpb24oc2VsZi52YWxfZmFjdG9yeV9hcHBfaWQpLmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfZmFjdG9yeV9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9mYWN0b3J5X2FwcF9pZCBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTk1LTE5OQogICAgLy8gIyBBc3NlcnQgaW5jcmVhc2UgaW4gbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IHdhcyBwYWlkIGZvciBOb3RpY2Vib2FyZCBkdWUgdG8KICAgIC8vICMgR2VuZXJhbFZhbGlkYXRvckFkIGNyZWF0aW9uIChGT1IgRlVUVVJFOiBhbmQgY3JlYXRpb24gb2YgbmV3IEJveCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX2ZhY3RvcnkucmVjZWl2ZXIgPT0gQXBwbGljYXRpb24oc2VsZi52YWxfZmFjdG9yeV9hcHBfaWQpLmFkZHJlc3MKICAgIC8vICksICJNQlIgaW5jcmVhc2Ugb2YgZmFjdG9yeSBvZiB2YWxpZGF0b3IgYWRzIG5lZWRzIHRvIGJlIGNvdmVyZWQuIgogICAgYXNzZXJ0IC8vIE1CUiBpbmNyZWFzZSBvZiBmYWN0b3J5IG9mIHZhbGlkYXRvciBhZHMgbmVlZHMgdG8gYmUgY292ZXJlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDAKICAgIC8vIGFzc2VydCBtYnJfZmFjdG9yeS5hbW91bnQgPT0gTUJSX1ZBTElEQVRPUkFEX0NSRUFUSU9OCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFtb3VudAogICAgaW50IDg5OTUwMAogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwMi0yMDMKICAgIC8vICMgSW5jcmVhc2UgYmxvY2tlZCBiYWxhbmNlIGluIE5vdGljZWJvYXJkCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ICs9IGRlcG9zaXQuYW1vdW50CiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJsb2NrZWRfYW10IGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICArCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjA3CiAgICAvLyBtYnJfdmFsLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwNS0yMDgKICAgIC8vICMgQXNzZXJ0IE1CUiB3YXMgcGFpZCBmb3IgdmFsaWRhdG9yIGFkZHJlc3MsIHNvIHRoYXQgbm90aWNlIGJvYXJkIGNhbiBmdW5kIGl0CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl92YWwucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgIk1CUiB3YXNuJ3QgcGFpZCB0byBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gTUJSIHdhc24ndCBwYWlkIHRvIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwOS0yMTAKICAgIC8vICMgVE8gRE86IEZpbmQgdGhlIGNvcnJlY3QgcGFyYW1ldGVyIHRvIHJlcGxhY2UgMTAwXzAwMAogICAgLy8gYXNzZXJ0IG1icl92YWwuYW1vdW50ID09IFVJbnQ2NCgKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjA5LTIxMgogICAgLy8gIyBUTyBETzogRmluZCB0aGUgY29ycmVjdCBwYXJhbWV0ZXIgdG8gcmVwbGFjZSAxMDBfMDAwCiAgICAvLyBhc3NlcnQgbWJyX3ZhbC5hbW91bnQgPT0gVUludDY0KAogICAgLy8gICAgIDEwMF8wMDAKICAgIC8vICksICJWYWxpZGF0b3IgZGlkbid0IGRlcG9zaXQgbWluaW11bSByZXF1aXJlZCBhbW91bnQgdG8gdmFsaWRhdG9yIGFkLiIKICAgIGludCAxMDAwMDAKICAgID09CiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGRpZG4ndCBkZXBvc2l0IG1pbmltdW0gcmVxdWlyZWQgYW1vdW50IHRvIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMTQKICAgIC8vIHBheV90b19hY2MoVUludDY0KDEwMF8wMDApLCBBcHBsaWNhdGlvbihjcmVhdGVkX2FwcF9pZCkuYWRkcmVzcykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludCAxMDAwMDAKICAgIHN3YXAKICAgIGNhbGxzdWIgcGF5X3RvX2FjYwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0LnZhbF9saXN0X2FkZCh2YWxfYXBwX2lkOiB1aW50NjQpIC0+IHVpbnQ2NDoKdmFsX2xpc3RfYWRkOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcyNy03MjkKICAgIC8vICMgLS0tLS0tLSBTdWJyb3V0aW5lIHV0aWxzIC0tLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgdmFsX2xpc3RfYWRkKHZhbF9hcHBfaWQ6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgaW50IDAKICAgIGJ5dGUgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0NC03NDUKICAgIC8vICMgR2V0IGJveCB3aXRoIHZhbGlkYXRvciBsaXN0CiAgICAvLyB2YWxfbGlzdF9ib3gsIGJveF9nZXQgPSBvcC5Cb3guZ2V0KEJ5dGVzKFZBTF9MSVNUKSkKICAgIGJ5dGUgInZhbF9saXN0IgogICAgYm94X2dldAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0NgogICAgLy8gYXNzZXJ0IGJveF9nZXQsICJHb3QgYm94IgogICAgYXNzZXJ0IC8vIEdvdCBib3gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NDktNzUwCiAgICAvLyAjIEFkZCBpdCB0byB0aGUgZmlyc3Qgbm9uLXplcm8gcGxhY2UKICAgIC8vIHZhbF9hZGRlZCA9IEZhbHNlCiAgICBpbnQgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc1MQogICAgLy8gZm9yIHZhbF9pZHggaW4gdXJhbmdlKE1BWF9WQUxfQ05UKToKICAgIGR1cAoKdmFsX2xpc3RfYWRkX2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NTEKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEwMAogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9idXJ5IDMKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9idXJ5IDAKICAgIGJ6IHZhbF9saXN0X2FkZF9hZnRlcl9mb3JANwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc1MgogICAgLy8gaWYgdmFsX2xpc3RbdmFsX2lkeF0gPT0gYXJjNC5VSW50NjQoMCk6CiAgICBmcmFtZV9kaWcgMQogICAgYXNzZXJ0IC8vIEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgNgogICAgaW50IDgKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICBmcmFtZV9kaWcgNAogICAgc3dhcAogICAgaW50IDgKICAgIGV4dHJhY3QzCiAgICBieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgYj09CiAgICBieiB2YWxfbGlzdF9hZGRfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzUzCiAgICAvLyB2YWxfbGlzdFt2YWxfaWR4XSA9IGFyYzQuVUludDY0KHZhbF9hcHBfaWQpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgMgogICAgdW5jb3ZlciAyCiAgICByZXBsYWNlMwogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzU0CiAgICAvLyB2YWxfYWRkZWQgPSBUcnVlCiAgICBpbnQgMQogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzU1CiAgICAvLyBicmVhawogICAgYiB2YWxfbGlzdF9hZGRfYWZ0ZXJfZm9yQDcKCnZhbF9saXN0X2FkZF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzUxCiAgICAvLyBmb3IgdmFsX2lkeCBpbiB1cmFuZ2UoTUFYX1ZBTF9DTlQpOgogICAgZnJhbWVfZGlnIDYKICAgIGludCAxCiAgICArCiAgICBmcmFtZV9idXJ5IDYKICAgIGIgdmFsX2xpc3RfYWRkX2Zvcl9oZWFkZXJAMQoKdmFsX2xpc3RfYWRkX2FmdGVyX2ZvckA3OgogICAgZnJhbWVfZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NTcKICAgIC8vIG9wLkJveC5wdXQoQnl0ZXMoVkFMX0xJU1QpLCB2YWxfbGlzdC5ieXRlcykKICAgIGJ5dGUgInZhbF9saXN0IgogICAgZnJhbWVfZGlnIDAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NTkKICAgIC8vIHJldHVybiB2YWxfYWRkZWQKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmhlbHBlcnMuY29tbW9uLnBheV90b19hY2MoYW1vdW50OiB1aW50NjQsIGFjY291bnQ6IGJ5dGVzKSAtPiB2b2lkOgpwYXlfdG9fYWNjOgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0OC0xNDkKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcGF5X3RvX2FjYyhhbW91bnQ6IFVJbnQ2NCwgYWNjb3VudDogQWNjb3VudCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE1MC0xNTQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9YW1vdW50LAogICAgLy8gICAgIHJlY2VpdmVyPWFjY291bnQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTAKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludCBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTMKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTUwLTE1NAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI9YWNjb3VudCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnkodmFsX2NvbmZpZ19tYW46IGJ5dGVzLCBsaXZlOiBieXRlcywgbWFuYWdlcjogYnl0ZXMsIG1heF9kZWxfY250OiBieXRlcykgLT4gdm9pZDoKc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjE2LTIyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBzZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9jb25maWdfbWFuOiBWYWxDb25maWdNYW4sCiAgICAvLyAgICAgbGl2ZTogYXJjNC5Cb29sLAogICAgLy8gICAgIG1hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBtYXhfZGVsX2NudDogYXJjNC5VSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA0IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMjUKICAgIC8vIHNlbGYuZGVwb3NpdF9zdWZmaWNpZW50KCkKICAgIGNhbGxzdWIgZGVwb3NpdF9zdWZmaWNpZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjI3CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyOAogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMzAKICAgIC8vIGFzc2VydCBkZWxfYXBwX2lkID09IFVJbnQ2NCgwKSwgIlVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLiIKICAgICEKICAgIGFzc2VydCAvLyBVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMzEKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSwgIlVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuIgogICAgZHVwCiAgICBhc3NlcnQgLy8gVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMzMtMjQxCiAgICAvLyB0eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5zZXRfbWFuZGF0b3J5LAogICAgLy8gICAgIHZhbF9jb25maWdfbWFuLmNvcHkoKSwKICAgIC8vICAgICBsaXZlLAogICAgLy8gICAgIG1hbmFnZXIuY29weSgpLAogICAgLy8gICAgIG1heF9kZWxfY250LAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInNldF9tYW5kYXRvcnkoKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYWRkcmVzcyx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0MAogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMzMtMjQxCiAgICAvLyB0eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5zZXRfbWFuZGF0b3J5LAogICAgLy8gICAgIHZhbF9jb25maWdfbWFuLmNvcHkoKSwKICAgIC8vICAgICBsaXZlLAogICAgLy8gICAgIG1hbmFnZXIuY29weSgpLAogICAgLy8gICAgIG1heF9kZWxfY250LAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNDIKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmRlcG9zaXRfc3VmZmljaWVudCgpIC0+IHZvaWQ6CmRlcG9zaXRfc3VmZmljaWVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MTktNzIxCiAgICAvLyAjIC0tLS0tIENoZWNrIGlmIGJlbG93IGlzIG5lZWRlZCBhdCBhbGwgLS0tLS0tCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGRlcG9zaXRfc3VmZmljaWVudChzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzIzCiAgICAvLyBzZWxmLmRlcG9zaXRfYW10W1R4bi5zZW5kZXJdID4gc2VsZi5kZXBvc2l0X3ZhbF9taW4KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZXBvc2l0X2FtdCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZXBvc2l0X2FtdCBleGlzdHMgZm9yIGFjY291bnQKICAgIGludCAwCiAgICBieXRlICJkZXBvc2l0X3ZhbF9taW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfdmFsX21pbiBleGlzdHMKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MjItNzI0CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPiBzZWxmLmRlcG9zaXRfdmFsX21pbgogICAgLy8gKSwgIkFjdGlvbiBibG9ja2VkIGR1ZSB0byBpbnN1ZmZpY2llbnQgZGVwb3NpdCIKICAgIGFzc2VydCAvLyBBY3Rpb24gYmxvY2tlZCBkdWUgdG8gaW5zdWZmaWNpZW50IGRlcG9zaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5zZXRfdmFsaWRhdG9yX2FkX2V4dHJhKHZhbF9jb25maWdfZXh0cmE6IGJ5dGVzKSAtPiB2b2lkOgpzZXRfdmFsaWRhdG9yX2FkX2V4dHJhOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0NC0yNDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X3ZhbGlkYXRvcl9hZF9leHRyYShzZWxmLCB2YWxfY29uZmlnX2V4dHJhOiBWYWxDb25maWdFeHRyYSkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0NwogICAgLy8gc2VsZi5kZXBvc2l0X3N1ZmZpY2llbnQoKQogICAgY2FsbHN1YiBkZXBvc2l0X3N1ZmZpY2llbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNDkKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUwCiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI1MgogICAgLy8gYXNzZXJ0IGRlbF9hcHBfaWQgPT0gVUludDY0KDApLCAiVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuIgogICAgIQogICAgYXNzZXJ0IC8vIFVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI1MwogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApLCAiVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4iCiAgICBkdXAKICAgIGFzc2VydCAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI1NS0yNjAKICAgIC8vIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLnNldF9leHRyYSwKICAgIC8vICAgICB2YWxfY29uZmlnX2V4dHJhLmNvcHkoKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgbWV0aG9kICJzZXRfZXh0cmEoKGJ5dGVbMzBdLGJ5dGVbNzBdKSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjU5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI1NS0yNjAKICAgIC8vIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLnNldF9leHRyYSwKICAgIC8vICAgICB2YWxfY29uZmlnX2V4dHJhLmNvcHkoKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjYxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfdmFsaWRhdG9yX2FkKCkgLT4gdm9pZDoKZW5kX3ZhbGlkYXRvcl9hZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNjMtMjY2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGVuZF92YWxpZGF0b3JfYWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI3MQogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzIKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjc0CiAgICAvLyBhc3NlcnQgZGVsX2FwcF9pZCA9PSBVSW50NjQoMCksICJVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4iCiAgICAhCiAgICBhc3NlcnQgLy8gVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjc1CiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCksICJVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLiIKICAgIGR1cAogICAgYXNzZXJ0IC8vIFVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjc3LTI4MgogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX3ZhbGlkYXRvcl9hZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBvbl9jb21wbGV0aW9uPU9uQ29tcGxldGVBY3Rpb24uRGVsZXRlQXBwbGljYXRpb24sCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjgwCiAgICAvLyBvbl9jb21wbGV0aW9uPU9uQ29tcGxldGVBY3Rpb24uRGVsZXRlQXBwbGljYXRpb24sCiAgICBpbnQgRGVsZXRlQXBwbGljYXRpb24KICAgIGl0eG5fZmllbGQgT25Db21wbGV0aW9uCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI3Ny0yODIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF92YWxpZGF0b3JfYWQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgb25fY29tcGxldGlvbj1PbkNvbXBsZXRlQWN0aW9uLkRlbGV0ZUFwcGxpY2F0aW9uLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgbWV0aG9kICJlbmRfdmFsaWRhdG9yX2FkKCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODEKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjc3LTI4MgogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX3ZhbGlkYXRvcl9hZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBvbl9jb21wbGV0aW9uPU9uQ29tcGxldGVBY3Rpb24uRGVsZXRlQXBwbGljYXRpb24sCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjgzCiAgICAvLyB2YWxfZWFybmluZ3MgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjg1LTI4NgogICAgLy8gIyBJbmNyZWFzZSB1c2VyJ3MsIGkuZS4gdmFsaWRhdG9ycywgZWFybmluZ3MKICAgIC8vIHNlbGYuYmFsYW5jZVtUeG4uc2VuZGVyXSArPSB2YWxfZWFybmluZ3MKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICArCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJiYWxhbmNlIgogICAgdW5jb3ZlciAyCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjg4LTI4OQogICAgLy8gIyBSZW1vdmUgR2VuZXJhbFZhbGlkYXRvckFkIGZyb20gbGlzdCBvZiB2YWxpZGF0b3JzCiAgICAvLyBhc3NlcnQgdmFsX2xpc3RfcmVtb3ZlKHZhbF9hcHBfaWQpLCAiVmFsaWRhdG9yIGxpc3QgZG9lc24ndCBpbmNsdWRlIHRoZSBhZC4iCiAgICBjYWxsc3ViIHZhbF9saXN0X3JlbW92ZQogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBsaXN0IGRvZXNuJ3QgaW5jbHVkZSB0aGUgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjkxLTI5MgogICAgLy8gIyBGcmVlIHVzZXIKICAgIC8vIGFzc2VydCBzZWxmLmZyZWVfdXNlcihUeG4uc2VuZGVyKSwgIkNvdWxkbid0IGZyZWUgdmFsaWRhdG9yLiIKICAgIHR4biBTZW5kZXIKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSB2YWxpZGF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjk0CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC52YWxfbGlzdF9yZW1vdmUodmFsX2FwcF9pZDogdWludDY0KSAtPiB1aW50NjQ6CnZhbF9saXN0X3JlbW92ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjItNzYzCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIHZhbF9saXN0X3JlbW92ZSh2YWxfYXBwX2lkOiBVSW50NjQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIGludCAwCiAgICBieXRlICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NzgtNzc5CiAgICAvLyAjIEdldCBib3ggd2l0aCB2YWxpZGF0b3IgbGlzdAogICAgLy8gdmFsX2xpc3RfYm94LCBib3hfZ2V0ID0gb3AuQm94LmdldChCeXRlcyhWQUxfTElTVCkpCiAgICBieXRlICJ2YWxfbGlzdCIKICAgIGJveF9nZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3ODAKICAgIC8vIGFzc2VydCBib3hfZ2V0LCAiR290IGJveCIKICAgIGFzc2VydCAvLyBHb3QgYm94CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzgzLTc4NAogICAgLy8gIyBSZW1vdmUgdGhlIGVsZW1lbnQKICAgIC8vIHZhbF9yZW1vdmUgPSBGYWxzZQogICAgaW50IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3ODUKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBkdXAKCnZhbF9saXN0X3JlbW92ZV9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Nzg1CiAgICAvLyBmb3IgdmFsX2lkeCBpbiB1cmFuZ2UoTUFYX1ZBTF9DTlQpOgogICAgZnJhbWVfZGlnIDYKICAgIGludCAxMDAKICAgIDwKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSAzCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfYnVyeSAwCiAgICBieiB2YWxfbGlzdF9yZW1vdmVfYWZ0ZXJfZm9yQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3ODYKICAgIC8vIGlmIHZhbF9saXN0W3ZhbF9pZHhdID09IGFyYzQuVUludDY0KHZhbF9hcHBfaWQpOgogICAgZnJhbWVfZGlnIDEKICAgIGFzc2VydCAvLyBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDYKICAgIGludCA4CiAgICAqCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgZnJhbWVfZGlnIDQKICAgIHN3YXAKICAgIGludCA4CiAgICBleHRyYWN0MwogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBiPT0KICAgIGJ6IHZhbF9saXN0X3JlbW92ZV9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3ODcKICAgIC8vIHZhbF9saXN0W3ZhbF9pZHhdID0gYXJjNC5VSW50NjQoMCkKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgMgogICAgYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKICAgIHJlcGxhY2UzCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3ODgKICAgIC8vIHZhbF9yZW1vdmUgPSBUcnVlCiAgICBpbnQgMQogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Nzg5CiAgICAvLyBicmVhawogICAgYiB2YWxfbGlzdF9yZW1vdmVfYWZ0ZXJfZm9yQDcKCnZhbF9saXN0X3JlbW92ZV9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Nzg1CiAgICAvLyBmb3IgdmFsX2lkeCBpbiB1cmFuZ2UoTUFYX1ZBTF9DTlQpOgogICAgZnJhbWVfZGlnIDYKICAgIGludCAxCiAgICArCiAgICBmcmFtZV9idXJ5IDYKICAgIGIgdmFsX2xpc3RfcmVtb3ZlX2Zvcl9oZWFkZXJAMQoKdmFsX2xpc3RfcmVtb3ZlX2FmdGVyX2ZvckA3OgogICAgZnJhbWVfZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3OTEKICAgIC8vIG9wLkJveC5wdXQoQnl0ZXMoVkFMX0xJU1QpLCB2YWxfbGlzdC5ieXRlcykKICAgIGJ5dGUgInZhbF9saXN0IgogICAgZnJhbWVfZGlnIDAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3OTMKICAgIC8vIHJldHVybiB2YWxfcmVtb3ZlCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5mcmVlX3VzZXIodXNlcl9hY2M6IGJ5dGVzKSAtPiB1aW50NjQ6CmZyZWVfdXNlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MTMtNzE0CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGZyZWVfdXNlcihzZWxmLCB1c2VyX2FjYzogQWNjb3VudCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcxNQogICAgLy8gc2VsZi52YWxfYXBwX2lkW3VzZXJfYWNjXSA9IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MTYKICAgIC8vIHNlbGYuZGVsX2FwcF9pZFt1c2VyX2FjY10gPSBVSW50NjQoMCkKICAgIGZyYW1lX2RpZyAtMQogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzE3CiAgICAvLyByZXR1cm4gVHJ1ZQogICAgaW50IDEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC52YWxfd2l0aGRyYXdfZWFybmluZ3MoKSAtPiBieXRlczoKdmFsX3dpdGhkcmF3X2Vhcm5pbmdzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI5Ni0yOTkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgdmFsX3dpdGhkcmF3X2Vhcm5pbmdzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzAwCiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMwMQogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDMKICAgIC8vIGFzc2VydCBkZWxfYXBwX2lkID09IFVJbnQ2NCgwKSwgIlVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLiIKICAgICEKICAgIGFzc2VydCAvLyBVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSwgIlVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuIgogICAgZHVwCiAgICBhc3NlcnQgLy8gVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDYtMzEwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC53aXRoZHJhd19lYXJuaW5ncywKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgbWV0aG9kICJ3aXRoZHJhd19lYXJuaW5ncygpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzA5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMwNi0zMTAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLndpdGhkcmF3X2Vhcm5pbmdzLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMxMQogICAgLy8gZWFybmluZ3MgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzEzLTMxNQogICAgLy8gIyBSZWxlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZCBmb3IgZGlmZmVyZW5jZSBiZXR3ZWVuIGNoYXJnZWQgZmVlX3NldHVwIGFuZCBlYXJuaW5ncyBvZiB2YWxpZGF0b3IsCiAgICAvLyAjIGkuZS4gZWFybmluZ3Mgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IGVhcm5pbmdzCiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJsb2NrZWRfYW10IGV4aXN0cwogICAgZGlnIDEKICAgIC0KICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMTcKICAgIC8vIHBheV90b19zZW5kZXIoZWFybmluZ3MpCiAgICBkdXAKICAgIGNhbGxzdWIgcGF5X3RvX3NlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMxOQogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KGVhcm5pbmdzKQogICAgaXRvYgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmhlbHBlcnMuY29tbW9uLnBheV90b19zZW5kZXIoYW1vdW50OiB1aW50NjQpIC0+IHZvaWQ6CnBheV90b19zZW5kZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTM4LTE0MAogICAgLy8gIyAtLS0tLS0tIEZ1bmN0aW9ucyAtLS0tLS0tCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIHBheV90b19zZW5kZXIoYW1vdW50OiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNDEtMTQ1CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0MwogICAgLy8gcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNDEKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludCBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNDQKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTQxLTE0NQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQud2l0aGRyYXdfYmFsYW5jZSgpIC0+IGJ5dGVzOgp3aXRoZHJhd19iYWxhbmNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMyMS0zMjkKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tICAgICAgICAgICBGb3IgYWxsIHVzZXJzICAgICAgICAgICAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgRk9SIEZVVFVSRTogVGhpbmsgYWJvdXQgaWYgaXQgd291bGQgYmUgbW9yZSBjb252ZW5pZW50IHRoYXQgYW55b25lIGNvdWxkIHRyaWdnZXIgd2l0aGRyYXdhbCBvZiBiYWxhbmNlIGFuZCBkZXBvc2l0CiAgICAvLyAjIEVzcGVjaWFsbHkgd2l0aCBvcGVuIG9wdGlvbnMgb2YgZS5nLiBrZXlzX25vdF9nZW5lcmF0ZWQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgd2l0aGRyYXdfYmFsYW5jZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBhcmM0LlVJbnQ2NDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMzMQogICAgLy8gYmFsYW5jZSA9IHNlbGYuYmFsYW5jZVtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImJhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMzMtMzM0CiAgICAvLyAjIFJlbGVhc2UgYmxvY2tlZCBiYWxhbmNlIGluIE5vdGljZWJvYXJkCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IGJhbGFuY2UKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBkaWcgMQogICAgLQogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMzNgogICAgLy8gcGF5X3RvX3NlbmRlcihiYWxhbmNlKQogICAgZHVwCiAgICBjYWxsc3ViIHBheV90b19zZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMzgtMzM5CiAgICAvLyAjIFNldCBuZXcgYmFsYW5jZSB0byB6ZXJvCiAgICAvLyBzZWxmLmJhbGFuY2VbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImJhbGFuY2UiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0MQogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KGJhbGFuY2UpCiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQud2l0aGRyYXdfZGVwb2lzdCgpIC0+IGJ5dGVzOgp3aXRoZHJhd19kZXBvaXN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0My0zNDYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgd2l0aGRyYXdfZGVwb2lzdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBhcmM0LlVJbnQ2NDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0NwogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNDgKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzUwLTM1MgogICAgLy8gYXNzZXJ0IGRlbF9hcHBfaWQgPT0gVUludDY0KDApIGFuZCB2YWxfYXBwX2lkID09IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiV2l0aGRyYXdhbCBvZiBkZXBvc2l0IGlzIG9ubHkgcG9zc2libGUgaWYgdXNlciBpcyBuZWl0aGVyIGEgdmFsaWRhdG9yIG5vciBhIGRlbGVnYXRvci4iCiAgICBibnogd2l0aGRyYXdfZGVwb2lzdF9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAwCiAgICBibnogd2l0aGRyYXdfZGVwb2lzdF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIHdpdGhkcmF3X2RlcG9pc3RfYm9vbF9tZXJnZUA0Cgp3aXRoZHJhd19kZXBvaXN0X2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgp3aXRoZHJhd19kZXBvaXN0X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNTAtMzUyCiAgICAvLyBhc3NlcnQgZGVsX2FwcF9pZCA9PSBVSW50NjQoMCkgYW5kIHZhbF9hcHBfaWQgPT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJXaXRoZHJhd2FsIG9mIGRlcG9zaXQgaXMgb25seSBwb3NzaWJsZSBpZiB1c2VyIGlzIG5laXRoZXIgYSB2YWxpZGF0b3Igbm9yIGEgZGVsZWdhdG9yLiIKICAgIGFzc2VydCAvLyBXaXRoZHJhd2FsIG9mIGRlcG9zaXQgaXMgb25seSBwb3NzaWJsZSBpZiB1c2VyIGlzIG5laXRoZXIgYSB2YWxpZGF0b3Igbm9yIGEgZGVsZWdhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM1NAogICAgLy8gZGVwb3NpdCA9IHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZXBvc2l0X2FtdCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZXBvc2l0X2FtdCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNTYtMzU3CiAgICAvLyAjIFJlbGVhc2UgYmxvY2tlZCBiYWxhbmNlIGluIE5vdGljZWJvYXJkIGZvciB0aGUgZGVwb3NpdAogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCAtPSBkZXBvc2l0CiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJsb2NrZWRfYW10IGV4aXN0cwogICAgZGlnIDEKICAgIC0KICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNTkKICAgIC8vIHBheV90b19zZW5kZXIoZGVwb3NpdCkKICAgIGR1cAogICAgY2FsbHN1YiBwYXlfdG9fc2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzYxLTM2MgogICAgLy8gIyBTZXQgbmV3IGRlcG9zaXQgdG8gemVybwogICAgLy8gc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM2NAogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KGRlcG9zaXQpCiAgICBpdG9iCiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQudXNlcl9vcHRfaW4oKSAtPiB2b2lkOgp1c2VyX29wdF9pbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNjYtMzY5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk9wdEluIl0pCiAgICAvLyBkZWYgdXNlcl9vcHRfaW4oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM3NgogICAgLy8gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gVUludDY0KDApCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNzcKICAgIC8vIHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzc4CiAgICAvLyBzZWxmLmRlcG9zaXRfYW10W1R4bi5zZW5kZXJdID0gVUludDY0KDApCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJkZXBvc2l0X2FtdCIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzc5CiAgICAvLyBzZWxmLmJhbGFuY2VbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImJhbGFuY2UiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM4MQogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCh2YWxfYXBwX2lkOiBieXRlcywgZGVwb3NpdF9wYXltZW50OiB1aW50NjQsIGZlZV9zZXR1cF9wYXltZW50OiB1aW50NjQsIG1icjogdWludDY0LCByb3VuZF9zdGFydDogYnl0ZXMsIHJvdW5kX2VuZDogYnl0ZXMpIC0+IHZvaWQ6CmNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzg3LTM5NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX2FwcF9pZDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgZGVwb3NpdF9wYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICAgICBmZWVfc2V0dXBfcGF5bWVudDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWJyOiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcm91bmRfZW5kOiBhcmM0LlVJbnQ2NCwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDYgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM5NwogICAgLy8gYXNzZXJ0IHNlbGYubGl2ZSwgIk5vdGljZWJvYXJkIGlzIGxpdmUuIgogICAgaW50IDAKICAgIGJ5dGUgImxpdmUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGxpdmUgZXhpc3RzCiAgICBhc3NlcnQgLy8gTm90aWNlYm9hcmQgaXMgbGl2ZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MDMKICAgIC8vIGFzc2VydCBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0gPT0gMCwgIkFjY291bnQgZG9lc24ndCB5ZXQgaGF2ZSBhIHJvbGUuIgogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgICEKICAgIGFzc2VydCAvLyBBY2NvdW50IGRvZXNuJ3QgeWV0IGhhdmUgYSByb2xlLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQwOAogICAgLy8gbWJyLnJlY2VpdmVyID09IEFwcGxpY2F0aW9uKHZhbF9hcHBfaWQubmF0aXZlKS5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTMKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgLTYKICAgIGJ0b2kKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQwNS00MDkKICAgIC8vICMgQXNzZXJ0IGluY3JlYXNlIGluIG1pbmltdW0gYmFsYW5jZSByZXF1aXJlbWVudCB3YXMgcGFpZCBmb3IgVmFsZGlhdG9yQWQgZHVlIHRvCiAgICAvLyAjIERlbGVnYXRvckNvbnRyYWN0IGNyZWF0aW9uCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1ici5yZWNlaXZlciA9PSBBcHBsaWNhdGlvbih2YWxfYXBwX2lkLm5hdGl2ZSkuYWRkcmVzcwogICAgLy8gKSwgIk1CUiB3YXNuJ3QgcGFpZCB0byB0aGUgdmFsZGlhdG9yIGFkLiIKICAgIGFzc2VydCAvLyBNQlIgd2Fzbid0IHBhaWQgdG8gdGhlIHZhbGRpYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MTEKICAgIC8vIG1ici5hbW91bnQgPT0gTUJSX0RFTEVHQVRPUkNPTlRSQUNUX0NSRUFUSU9OCiAgICBmcmFtZV9kaWcgLTMKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBpbnQgNzg1MDAwCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQxMC00MTIKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyLmFtb3VudCA9PSBNQlJfREVMRUdBVE9SQ09OVFJBQ1RfQ1JFQVRJT04KICAgIC8vICksICJNQlIgcGF5IGhhZCBpbnN1ZmZpY2llbnQgYW1vdW50IGZvciBjcmVhdGlvbiBvZiBuZXcgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBNQlIgcGF5IGhhZCBpbnN1ZmZpY2llbnQgYW1vdW50IGZvciBjcmVhdGlvbiBvZiBuZXcgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQxNgogICAgLy8gZGVwb3NpdF9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtNQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQxNC00MTcKICAgIC8vICMgQXNzZXJ0IG1pbmltdW0gZGVsZWdhdG9yIGRlcG9zaXQgd2FzIHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkIChhbW91bnQgY2hlY2tlZCBpbiBHZW5lcmFsVmFsaWRhdG9yQWQpCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGRlcG9zaXRfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCAiRGVwb3NpdCB3YXNuJ3QgcGFpZCB0byB0aGUgbm90aWNlYm9hcmQuIgogICAgYXNzZXJ0IC8vIERlcG9zaXQgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQyMAogICAgLy8gZmVlX3NldHVwX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC00CiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDE4LTQyMQogICAgLy8gIyBBc3NlcnQgY29ycmVjdCBhbW91bnQgb2Ygc2V0dXAgZmVlIHdhcyBwYWlkIHRvIHRoZSBub3RpY2Vib2FyZCAoYW1vdW50IGNoZWNrZWQgaW4gR2VuZXJhbFZhbGlkYXRvckFkKQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBmZWVfc2V0dXBfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCAiU2V0dXAgZmVlIHdhc24ndCBwYWlkIHRvIHRoZSBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gU2V0dXAgZmVlIHdhc24ndCBwYWlkIHRvIHRoZSBub3RpY2Vib2FyZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjMtNDMzCiAgICAvLyAjIENyZWF0ZSBuZXcgZGVsZWdhdG9yIGNvbnRyYWN0IGZvciB0aGUgY2hvc2VuIHZhbGlkYXRvcgogICAgLy8gY3JlYXRlZF9kZWxfYXBwX2lkLCB0eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0LAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXRfcGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZC5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDI2CiAgICAvLyBhcmM0LlVJbnQ2NChkZXBvc2l0X3BheW1lbnQuYW1vdW50KSwKICAgIGZyYW1lX2RpZyAtNQogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjcKICAgIC8vIGFyYzQuVUludDY0KGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCksCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDI4CiAgICAvLyBhcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICB0eG4gU2VuZGVyCiAgICBzd2FwCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDIzLTQzMwogICAgLy8gIyBDcmVhdGUgbmV3IGRlbGVnYXRvciBjb250cmFjdCBmb3IgdGhlIGNob3NlbiB2YWxpZGF0b3IKICAgIC8vIGNyZWF0ZWRfZGVsX2FwcF9pZCwgdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0X3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQubmF0aXZlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgbWV0aG9kICJjcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0KHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMyCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQyMy00MzMKICAgIC8vICMgQ3JlYXRlIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QgZm9yIHRoZSBjaG9zZW4gdmFsaWRhdG9yCiAgICAvLyBjcmVhdGVkX2RlbF9hcHBfaWQsIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVwb3NpdF9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZmVlX3NldHVwX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBhcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgcm91bmRfc3RhcnQsCiAgICAvLyAgICAgcm91bmRfZW5kLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLm5hdGl2ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MzQtNDM1CiAgICAvLyAjIFN0b3JlIHRoZSBjcmVhdGVkIGRlbGVnYXRvciBjb250cmFjdCBhcHAgSUQKICAgIC8vIHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXSA9IGNyZWF0ZWRfZGVsX2FwcF9pZC5uYXRpdmUKICAgIGJ0b2kKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MzYtNDM3CiAgICAvLyAjIFN0b3JlIHNlbGVjdGVkIHZhbGlkYXRvciBjb250cmFjdCBhcHAgSUQKICAgIC8vIHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXSA9IHZhbF9hcHBfaWQubmF0aXZlCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgdW5jb3ZlciA1CiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM5LTQ0MQogICAgLy8gIyBNYXJrIGRlbGVnYXRvcnMgZGVwb3NpdCBhbW91bnQKICAgIC8vICMgRk9SIEZVVFVSRTogQ29uc2lkZXIgaWYgSSBjb3VsZCBhbHNvIGFkZCB0byB0aGlzIG1ici5hbW91bnQgYW5kL29yIGpvaW4gdGhlbSAocmVtb3ZlIG1iciBhdCBhbGwpCiAgICAvLyBzZWxmLmRlcG9zaXRfYW10W1R4bi5zZW5kZXJdID0gZGVwb3NpdF9wYXltZW50LmFtb3VudAogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICBkaWcgMwogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ0My00NDQKICAgIC8vICMgSW5jcmVhc2UgYmxvY2tlZCBiYWxhbmNlCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ICs9ICgKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDQ1CiAgICAvLyBkZXBvc2l0X3BheW1lbnQuYW1vdW50ICsgZmVlX3NldHVwX3BheW1lbnQuYW1vdW50ICsgbWJyLmFtb3VudAogICAgdW5jb3ZlciAyCiAgICArCiAgICB1bmNvdmVyIDIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NDMtNDQ2CiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSAoCiAgICAvLyAgICAgZGVwb3NpdF9wYXltZW50LmFtb3VudCArIGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCArIG1ici5hbW91bnQKICAgIC8vICkKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NDMtNDQ0CiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSAoCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NDMtNDQ2CiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSAoCiAgICAvLyAgICAgZGVwb3NpdF9wYXltZW50LmFtb3VudCArIGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCArIG1ici5hbW91bnQKICAgIC8vICkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDQ4CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5kZXBvc2l0X2tleXMoZGVsX2FjYzogYnl0ZXMsIHNlbF9rZXk6IGJ5dGVzLCB2b3RlX2tleTogYnl0ZXMsIHN0YXRlX3Byb29mX2tleTogYnl0ZXMsIHZvdGVfa2V5X2RpbHV0aW9uOiBieXRlcywgcm91bmRfc3RhcnQ6IGJ5dGVzLCByb3VuZF9lbmQ6IGJ5dGVzKSAtPiB2b2lkOgpkZXBvc2l0X2tleXM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDUwLTQ2MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBkZXBvc2l0X2tleXMoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfYWNjOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgc2VsX2tleTogU2VsS2V5LAogICAgLy8gICAgIHZvdGVfa2V5OiBWb3RlS2V5LAogICAgLy8gICAgIHN0YXRlX3Byb29mX2tleTogU3RhdGVQcm9vZktleSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbjogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIHJvdW5kX2VuZDogYXJjNC5VSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA3IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NjIKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbZGVsX2FjYy5uYXRpdmVdCiAgICBmcmFtZV9kaWcgLTcKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDYzCiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC03CiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ2NS00NzcKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmRlcG9zaXRfa2V5cywKICAgIC8vICAgICBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIHNlbF9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5LmNvcHkoKSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5X2RpbHV0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NjgKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ2NwogICAgLy8gVHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDY1LTQ3NwogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZGVwb3NpdF9rZXlzLAogICAgLy8gICAgIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgc2VsX2tleS5jb3B5KCksCiAgICAvLyAgICAgdm90ZV9rZXkuY29weSgpLAogICAgLy8gICAgIHN0YXRlX3Byb29mX2tleS5jb3B5KCksCiAgICAvLyAgICAgdm90ZV9rZXlfZGlsdXRpb24sCiAgICAvLyAgICAgcm91bmRfc3RhcnQsCiAgICAvLyAgICAgcm91bmRfZW5kLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgbWV0aG9kICJkZXBvc2l0X2tleXMoYWNjb3VudCx1aW50NjQsYnl0ZVszMl0sYnl0ZVszMl0sYnl0ZVs2NF0sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NjcKICAgIC8vIFR4bi5zZW5kZXIsCiAgICBieXRlIDB4MDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC02CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC01CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC00CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0zCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ2NS00NzcKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmRlcG9zaXRfa2V5cywKICAgIC8vICAgICBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIHNlbF9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5LmNvcHkoKSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5X2RpbHV0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc2CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ2NS00NzcKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmRlcG9zaXRfa2V5cywKICAgIC8vICAgICBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIHNlbF9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5LmNvcHkoKSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5X2RpbHV0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NzgKICAgIC8vIHBsYXRmb3JtX2Vhcm5pbmcgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDgwLTQ4MQogICAgLy8gIyBSZWxlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZCBmb3IgZWFybmluZyBvZiB0aGUgcGxhdGZvcm0KICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgLT0gcGxhdGZvcm1fZWFybmluZwogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIHN3YXAKICAgIC0KICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0ODMKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmNvbmZpcm1fa2V5cyhrZXlyZWdfdHhuX2luZGV4OiBieXRlcywgZmVlX29wZXJhdGlvbl9wYXltZW50OiB1aW50NjQpIC0+IHZvaWQ6CmNvbmZpcm1fa2V5czoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0ODUtNDkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbmZpcm1fa2V5cygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGtleXJlZ190eG5faW5kZXg6IGFyYzQuVUludDY0LAogICAgLy8gICAgIGZlZV9vcGVyYXRpb25fcGF5bWVudDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTIKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ5MwogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTUtNDk3CiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCkgYW5kIGRlbF9hcHBfaWQgIT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJTZW5kZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYnogY29uZmlybV9rZXlzX2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDEKICAgIGJ6IGNvbmZpcm1fa2V5c19ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIGNvbmZpcm1fa2V5c19ib29sX21lcmdlQDQKCmNvbmZpcm1fa2V5c19ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKY29uZmlybV9rZXlzX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTUtNDk3CiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCkgYW5kIGRlbF9hcHBfaWQgIT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJTZW5kZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIFNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDEKICAgIC8vIEdsb2JhbC5ncm91cF9zaXplID09IDMKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIGludCAzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ5OS01MDIKICAgIC8vICMgRk9SIEZVVFVSRTogUmVtb3ZlIGFuZCByYXRoZXIgY2hlY2sgdGhlcmUgaXMgb25seSBvbmUga2V5IHJlZyB0eCBmb3IgdGhlIGFjY291bnQgaW4gdGhlIGdyb3VwIGFuZCBubyByZWtleSB0eHMgKHdoZXJlIG9uZSBjb3VsZCByZWdpc3RlciBhIGtleSBhbmQgdGhlbiBjaGFuZ2UgaXQpCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIEdsb2JhbC5ncm91cF9zaXplID09IDMKICAgIC8vICksICJDaGVjayBndHhuIHNpemUgaXMgZXhhY3RseSB0aHJlZSAtIGZlZSBwYXltZW50LCBhcHAgY2FsbCwgYW5kIGtleSByZWcuIgogICAgYXNzZXJ0IC8vIENoZWNrIGd0eG4gc2l6ZSBpcyBleGFjdGx5IHRocmVlIC0gZmVlIHBheW1lbnQsIGFwcCBjYWxsLCBhbmQga2V5IHJlZy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDYKICAgIC8vIGZlZV9vcGVyYXRpb25fcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDQtNTA3CiAgICAvLyAjIEFzc2VydCBjb3JyZWN0IGFtb3VudCBvZiBvcGVyYXRpb25hbCBmZWUgd2FzIHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkIChhbW91bnQgY2hlY2tlZCBpbiBEZWxlZ2F0b3JDb250cmFjdCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZmVlX29wZXJhdGlvbl9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLiIKICAgIGFzc2VydCAvLyBTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxMAogICAgLy8gb3AuR1R4bi50eXBlX2VudW0oa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGJ0b2kKICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTEKICAgIC8vID09IFRyYW5zYWN0aW9uVHlwZS5LZXlSZWdpc3RyYXRpb24KICAgIGludCBrZXlyZWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTAtNTExCiAgICAvLyBvcC5HVHhuLnR5cGVfZW51bShrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vID09IFRyYW5zYWN0aW9uVHlwZS5LZXlSZWdpc3RyYXRpb24KICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTA5LTUxMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBvcC5HVHhuLnR5cGVfZW51bShrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vICAgICA9PSBUcmFuc2FjdGlvblR5cGUuS2V5UmVnaXN0cmF0aW9uCiAgICAvLyApLCAiS2V5IHJlZyB0cmFuc2FjdGlvbi4iCiAgICBhc3NlcnQgLy8gS2V5IHJlZyB0cmFuc2FjdGlvbi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTYKICAgIC8vIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICBkdXAKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTQtNTE3CiAgICAvLyAjIEZPUiBGVVRVUkU6IEluIGZ1dHVyZSBhbGxvdyBzZXBhcmF0aW9uIG9mIG9uZSBpbnRlcmFjdGluZyB3aXRoIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QgYW5kIGtleSByZWdpc3RyYXRpb24gYWNjb3VudAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBvcC5HVHhuLnNlbmRlcihrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkgPT0gVHhuLnNlbmRlcgogICAgLy8gKSwgIktleSByZWcgaXMgZnJvbSB0aGUgc2FtZSBhY2NvdW50IGFzIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIEtleSByZWcgaXMgZnJvbSB0aGUgc2FtZSBhY2NvdW50IGFzIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTE5LTUyMAogICAgLy8gIyBGT1IgRlVUVVJFOiBDaGVja3MgY291bGQgbGlrZWx5IGJlIHBhc3NlZCBkb3duIHRvIGRlbGVnYXRvciBjb250cmFjdCBzaW1wbHkgdGhyb3VnaCB0aGUga2V5cmVnX3R4bl9pbmRleCBpbnN0ZWFkIG9mIHRyYW5zZmVyaW5nIGFsbCB0aGUgdmFsdWVzIGluZGl2aWR1YWxseSEKICAgIC8vIHNlbF9rZXkgPSBTZWxLZXkuZnJvbV9ieXRlcyhvcC5HVHhuLnNlbGVjdGlvbl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkpCiAgICBkdXAKICAgIGd0eG5zIFNlbGVjdGlvblBLCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTIxCiAgICAvLyB2b3RlX2tleSA9IFZvdGVLZXkuZnJvbV9ieXRlcyhvcC5HVHhuLnZvdGVfcGsoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpKQogICAgZHVwCiAgICBndHhucyBWb3RlUEsKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjItNTI0CiAgICAvLyBzdGF0ZV9wcm9vZl9rZXkgPSBTdGF0ZVByb29mS2V5LmZyb21fYnl0ZXMoCiAgICAvLyAgICAgb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMwogICAgLy8gb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIGd0eG5zIFN0YXRlUHJvb2ZQSwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMi01MjQKICAgIC8vIHN0YXRlX3Byb29mX2tleSA9IFN0YXRlUHJvb2ZLZXkuZnJvbV9ieXRlcygKICAgIC8vICAgICBvcC5HVHhuLnN0YXRlX3Byb29mX3BrKGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyNgogICAgLy8gdm90ZV9rZXlfZGlsdXRpb24gPSBvcC5HVHhuLnZvdGVfa2V5X2RpbHV0aW9uKGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZHVwCiAgICBndHhucyBWb3RlS2V5RGlsdXRpb24KICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjcKICAgIC8vIHJvdW5kX3N0YXJ0ID0gb3AuR1R4bi52b3RlX2ZpcnN0KGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZHVwCiAgICBndHhucyBWb3RlRmlyc3QKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjgKICAgIC8vIHJvdW5kX2VuZCA9IG9wLkdUeG4udm90ZV9sYXN0KGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZ3R4bnMgVm90ZUxhc3QKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MzAtNTQyCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5jb25maXJtX2tleXMsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZmVlX29wZXJhdGlvbl9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgc2VsX2tleS5jb3B5KCksCiAgICAvLyAgICAgdm90ZV9rZXkuY29weSgpLAogICAgLy8gICAgIHN0YXRlX3Byb29mX2tleS5jb3B5KCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQodm90ZV9rZXlfZGlsdXRpb24pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX3N0YXJ0KSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChyb3VuZF9lbmQpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzMgogICAgLy8gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICBmcmFtZV9kaWcgMQogICAgaXRvYgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzMwogICAgLy8gYXJjNC5VSW50NjQoZmVlX29wZXJhdGlvbl9wYXltZW50LmFtb3VudCksCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTM3CiAgICAvLyBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MzgKICAgIC8vIGFyYzQuVUludDY0KHJvdW5kX3N0YXJ0KSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzOQogICAgLy8gYXJjNC5VSW50NjQocm91bmRfZW5kKSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgc3dhcAogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzMC01NDIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNvbmZpcm1fa2V5cywKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfb3BlcmF0aW9uX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICAvLyAgICAgYXJjNC5VSW50NjQocm91bmRfc3RhcnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX2VuZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImNvbmZpcm1fa2V5cyh1aW50NjQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTQxCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzMC01NDIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNvbmZpcm1fa2V5cywKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfb3BlcmF0aW9uX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICAvLyAgICAgYXJjNC5VSW50NjQocm91bmRfc3RhcnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX2VuZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTQzCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0Lm5hdGl2ZQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU0NS01NDYKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmcgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTQ4LTU0OQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UgZm9yIG9wZXJ0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ICs9IGZlZV9vcGVyYXRpb25fcGF5bWVudC5hbW91bnQKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICArCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTUxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5rZXlzX25vdF9nZW5lcmF0ZWQoZGVsX2FjYzogYnl0ZXMpIC0+IHZvaWQ6CmtleXNfbm90X2dlbmVyYXRlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTMtNTU3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGtleXNfbm90X2dlbmVyYXRlZCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hY2M6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1OQogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTYwCiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU2Mi01NjQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBieiBrZXlzX25vdF9nZW5lcmF0ZWRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMQogICAgYnoga2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIga2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfbWVyZ2VANAoKa2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgprZXlzX25vdF9nZW5lcmF0ZWRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU2Mi01NjQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU2Ni01NzEKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2dlbmVyYXRlZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NjgKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgZnJhbWVfZGlnIDEKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NjYtNTcxCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5rZXlzX25vdF9nZW5lcmF0ZWQsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImtleXNfbm90X2dlbmVyYXRlZCh1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU3MAogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NjYtNTcxCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5rZXlzX25vdF9nZW5lcmF0ZWQsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTcyCiAgICAvLyBmZWVfc2V0dXAgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTc0LTU3NQogICAgLy8gIyBSZWZ1bmQgc2V0dXAgZmVlIHRvIGRlbGVnYXRvcidzIGJhbGFuY2UKICAgIC8vIHNlbGYuYmFsYW5jZVtkZWxfYWNjLm5hdGl2ZV0gKz0gZmVlX3NldHVwCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICArCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzctNTc4CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKFR4bi5zZW5kZXIpLCAiQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuIgogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBmcmVlX3VzZXIKICAgIGFzc2VydCAvLyBDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1ODAKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmtleXNfbm90X2NvbmZpcm1lZChkZWxfYWNjOiBieXRlcykgLT4gdm9pZDoKa2V5c19ub3RfY29uZmlybWVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4Mi01ODYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYga2V5c19ub3RfY29uZmlybWVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FjYzogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTg4CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1ODkKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbZGVsX2FjYy5uYXRpdmVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTkxLTU5MwogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiQWNjb3VudCBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBieiBrZXlzX25vdF9jb25maXJtZWRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMQogICAgYnoga2V5c19ub3RfY29uZmlybWVkX2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIga2V5c19ub3RfY29uZmlybWVkX2Jvb2xfbWVyZ2VANAoKa2V5c19ub3RfY29uZmlybWVkX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgprZXlzX25vdF9jb25maXJtZWRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU5MS01OTMKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIkFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIEFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTk1LTYwMAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQua2V5c19ub3RfY29uZmlybWVkLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU5NwogICAgLy8gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICBmcmFtZV9kaWcgMQogICAgaXRvYgogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU5NS02MDAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIG1ldGhvZCAia2V5c19ub3RfY29uZmlybWVkKHVpbnQ2NCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTk5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU5NS02MDAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MDEKICAgIC8vIHBsYXRmb3JtX2Vhcm5pbmcgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjAzLTYwNAogICAgLy8gIyBSZWxlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZCBmb3IgZWFybmluZ3Mgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjA2LTYwNwogICAgLy8gIyBGcmVlIHVzZXIKICAgIC8vIGFzc2VydCBzZWxmLmZyZWVfdXNlcihkZWxfYWNjLm5hdGl2ZSksICJDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjA5CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FjYzogYnl0ZXMpIC0+IHZvaWQ6CmVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MTEtNjE1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hY2M6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgYnl0ZSAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyMAogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjIxCiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyMy02MjUKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIkFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDIKICAgIGJ6IGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX21lcmdlQDQKCmVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MjMtNjI1CiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCkgYW5kIGRlbF9hcHBfaWQgIT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJBY2NvdW50IGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBBY2NvdW50IGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyNy02MzAKICAgIC8vICMgUmVhZCBnbG9iYWwgc3RhdGUgb2YgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfZW5kX3JvdW5kLCBkZWxfZW5kX3JvdW5kX2V4aXN0ID0gb3AuQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgLy8gKQogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyOQogICAgLy8gZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgYnl0ZSAicm91bmRfZW5kIgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyNy02MzAKICAgIC8vICMgUmVhZCBnbG9iYWwgc3RhdGUgb2YgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfZW5kX3JvdW5kLCBkZWxfZW5kX3JvdW5kX2V4aXN0ID0gb3AuQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MzEKICAgIC8vIGFzc2VydCBkZWxfZW5kX3JvdW5kX2V4aXN0LCAiRGVsZWdhdG9yIGNvbnRyYWN0IGhhcyByb3VuZF9lbmQuIgogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBoYXMgcm91bmRfZW5kLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYzMwogICAgLy8gZGVsX2FwcF9pZCwgQnl0ZXMoYiJjb250cmFjdF9icmVhY2hlZCIpCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MzItNjM0CiAgICAvLyBkZWxfY29udHJhY3RfYnJlYWNoZWQsIGRlbF9jb250cmFjdF9icmVhY2hlZF9leGlzdCA9IG9wLkFwcEdsb2JhbC5nZXRfZXhfdWludDY0KAogICAgLy8gICAgIGRlbF9hcHBfaWQsIEJ5dGVzKGIiY29udHJhY3RfYnJlYWNoZWQiKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYzNQogICAgLy8gYXNzZXJ0IGRlbF9jb250cmFjdF9icmVhY2hlZF9leGlzdCwgIkRlbGVnYXRvciBjb250cmFjdCBoYXMgY29udHJhY3RfYnJlYWNoZWQuIgogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBoYXMgY29udHJhY3RfYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjM4CiAgICAvLyBkZWxfZW5kX3JvdW5kIDwgR2xvYmFsLnJvdW5kIG9yIGRlbF9jb250cmFjdF9icmVhY2hlZAogICAgZ2xvYmFsIFJvdW5kCiAgICA8CiAgICBibnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfdHJ1ZUA2CiAgICBmcmFtZV9kaWcgMAogICAgYnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VANwoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfdHJ1ZUA2OgogICAgaW50IDEKICAgIGIgZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfbWVyZ2VAOAoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VANzoKICAgIGludCAwCgplbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYzNy02MzkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVsX2VuZF9yb3VuZCA8IEdsb2JhbC5yb3VuZCBvciBkZWxfY29udHJhY3RfYnJlYWNoZWQKICAgIC8vICksICJBbnlvbmUgY2FuIGVuZCBjb250cmFjdCBpZiBpdCBoYXMgZXhwaXJlZCBhbHJlYWR5IG9yIHdhcyBicmVhY2hlZC4iCiAgICBhc3NlcnQgLy8gQW55b25lIGNhbiBlbmQgY29udHJhY3QgaWYgaXQgaGFzIGV4cGlyZWQgYWxyZWFkeSBvciB3YXMgYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQxCiAgICAvLyBzZWxmLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FwcF9pZCwgdmFsX2FwcF9pZCwgZGVsX2FjYy5uYXRpdmUpCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBlbmRfZGVsZWdhdG9yX2NvbnRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQzCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfZGVsZWdhdG9yX2NvbnRyYWN0KGRlbF9hcHBfaWQ6IHVpbnQ2NCwgdmFsX2FwcF9pZDogdWludDY0LCBhY2M6IGJ5dGVzKSAtPiB2b2lkOgplbmRfZGVsZWdhdG9yX2NvbnRyYWN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY3NS02ODQKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIEludGVybmFsIGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZW5kX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHBfaWQ6IFVJbnQ2NCwKICAgIC8vICAgICB2YWxfYXBwX2lkOiBVSW50NjQsCiAgICAvLyAgICAgYWNjOiBBY2NvdW50LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njg5LTY5NAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX2RlbGVnYXRvcl9jb250cmFjdCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2OTEKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY4OS02OTQKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImVuZF9kZWxlZ2F0b3JfY29udHJhY3QodWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjkzCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY4OS02OTQKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njk1CiAgICAvLyBkZXBvc2l0ID0gcmVzdWx0LmEKICAgIGR1cAogICAgZXh0cmFjdCAwIDgKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2OTYKICAgIC8vIHJlZnVuZCA9IHJlc3VsdC5iCiAgICBkdXAKICAgIGV4dHJhY3QgOCA4CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njk3CiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0LmMKICAgIGV4dHJhY3QgMTYgOAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY5OS03MDAKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmdzIG9mIHRoZSBwbGF0Zm9ybQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCAtPSBwbGF0Zm9ybV9lYXJuaW5nLm5hdGl2ZQogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIHN3YXAKICAgIGJ0b2kKICAgIC0KICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDItNzAzCiAgICAvLyAjIFJldHVybiByZWZ1bmQgdW51c2VkIG9wZXJhdGlvbmFsIGZlZSB0byBkZWxlZ2F0b3IncyBiYWxhbmNlCiAgICAvLyBzZWxmLmJhbGFuY2VbYWNjXSArPSByZWZ1bmQubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBzd2FwCiAgICBidG9pCiAgICArCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDUtNzA2CiAgICAvLyAjIFNldCBkZXBvc2l0IHRvIGRlbGVnYXRvcidzIGxvY2FsIHN0YXRlIC0gYmVjYXVzZSBpdCBjb3VsZCBoYXZlIGJlZW4gc2llemVkIGR1ZSB0byBicmVhY2hlcwogICAgLy8gc2VsZi5kZXBvc2l0X2FtdFthY2NdID0gZGVwb3NpdC5uYXRpdmUKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMQogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDgtNzA5CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKGFjYyksICJDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzExCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdChrZXlyZWdfdHhuX2luZGV4OiBieXRlcykgLT4gdm9pZDoKZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQ1LTY0OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGtleXJlZ190eG5faW5kZXg6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjUyCiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NTMKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjU1LTY1NwogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGJ6IGVuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDEKICAgIGJ6IGVuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIgZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA0CgplbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY1NS02NTcKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY2MQogICAgLy8gR2xvYmFsLmdyb3VwX3NpemUgPT0gMgogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50IDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjU5LTY2MgogICAgLy8gIyBGT1IgRlVUVVJFOiBSZW1vdmUgYW5kIHJhdGhlciBjaGVjayB0aGVyZSBpcyBvbmx5IG9uZSBrZXkgcmVnIHR4IGZvciB0aGUgYWNjb3VudCBpbiB0aGUgZ3JvdXAgYW5kIG5vIHJla2V5IHR4cyAod2hlcmUgb25lIGNvdWxkIHJlZ2lzdGVyIGEga2V5IGFuZCB0aGVuIGNoYW5nZSBpdCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgR2xvYmFsLmdyb3VwX3NpemUgPT0gMgogICAgLy8gKSwgIkNoZWNrIGd0eG4gc2l6ZSBpcyBleGFjdGx5IHR3byAtIGFwcCBjYWxsLCBhbmQga2V5IGRlcmVnLiIKICAgIGFzc2VydCAvLyBDaGVjayBndHhuIHNpemUgaXMgZXhhY3RseSB0d28gLSBhcHAgY2FsbCwgYW5kIGtleSBkZXJlZy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NjYKICAgIC8vIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgIGR1cAogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY2NC02NjcKICAgIC8vICMgRk9SIEZVVFVSRTogSW4gZnV0dXJlIGFsbG93IHNlcGFyYXRpb24gb2Ygb25lIGludGVyYWN0aW5nIHdpdGggdGhlIGRlbGVnYXRvciBjb250cmFjdCBhbmQga2V5IHJlZ2lzdHJhdGlvbiBhY2NvdW50CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICAvLyApLCAiS2V5IChkZSlyZWcgaXMgZnJvbSB0aGUgc2FtZSBhY2NvdW50IGFzIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIEtleSAoZGUpcmVnIGlzIGZyb20gdGhlIHNhbWUgYWNjb3VudCBhcyB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY2OQogICAgLy8gYXNzZXJ0IGlzX2tleV9kZXJlZyhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSksICJUcmFuc2FjdGlvbiBpcyBub3Qga2V5IGRlcmVnLiIKICAgIGNhbGxzdWIgaXNfa2V5X2RlcmVnCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgbm90IGtleSBkZXJlZy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NzEKICAgIC8vIHNlbGYuZW5kX2RlbGVnYXRvcl9jb250cmFjdChkZWxfYXBwX2lkLCB2YWxfYXBwX2lkLCBUeG4uc2VuZGVyKQogICAgdHhuIFNlbmRlcgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyAwCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgZW5kX2RlbGVnYXRvcl9jb250cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY3MwogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24uaXNfa2V5X2RlcmVnKHR4X2lkeDogdWludDY0KSAtPiB1aW50NjQ6CmlzX2tleV9kZXJlZzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTctMTU4CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGlzX2tleV9kZXJlZyh0eF9pZHg6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2MAogICAgLy8gb3AuR1R4bi50eXBlX2VudW0odHhfaWR4KSA9PSBUcmFuc2FjdGlvblR5cGUuS2V5UmVnaXN0cmF0aW9uCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQga2V5cmVnCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE1OS0xNjEKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgb3AuR1R4bi50eXBlX2VudW0odHhfaWR4KSA9PSBUcmFuc2FjdGlvblR5cGUuS2V5UmVnaXN0cmF0aW9uCiAgICAvLyApLCAiS2V5IChkZSlyZWcgdHJhbnNhY3Rpb24uIgogICAgYXNzZXJ0IC8vIEtleSAoZGUpcmVnIHRyYW5zYWN0aW9uLgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2My0xNjUKICAgIC8vICMgQ2hlY2sgaWYga2V5IHJlZyBpcyBkZXJlZ2lzdHJhdGlvbgogICAgLy8gIyBGT1IgRlVUVVJFOiBDaGVjayBpZiByZWFsbHkgQUxMIG5lZWQgdG8gYmUgdW5kZWZpbmVkLCBpLmUuIHplcm8sIHRvIGJlIHZhbGlkIGtleSBkZXJlZwogICAgLy8gYXNzZXJ0IG9wLkdUeG4uc2VsZWN0aW9uX3BrKHR4X2lkeCkgPT0gb3AuYnplcm8oMzIpCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFNlbGVjdGlvblBLCiAgICBpbnQgMzIKICAgIGJ6ZXJvCiAgICBkdXAKICAgIGNvdmVyIDIKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNjYKICAgIC8vIGFzc2VydCBvcC5HVHhuLnZvdGVfcGsodHhfaWR4KSA9PSBvcC5iemVybygzMikKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgVm90ZVBLCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTY3CiAgICAvLyBhc3NlcnQgb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayh0eF9pZHgpID09IG9wLmJ6ZXJvKDY0KQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTdGF0ZVByb29mUEsKICAgIGludCA2NAogICAgYnplcm8KICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNjgKICAgIC8vIGFzc2VydCBvcC5HVHhuLnZvdGVfa2V5X2RpbHV0aW9uKHR4X2lkeCkgPT0gVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFZvdGVLZXlEaWx1dGlvbgogICAgIQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTY5CiAgICAvLyBhc3NlcnQgb3AuR1R4bi52b3RlX2ZpcnN0KHR4X2lkeCkgPT0gVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFZvdGVGaXJzdAogICAgIQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTcwCiAgICAvLyBhc3NlcnQgb3AuR1R4bi52b3RlX2xhc3QodHhfaWR4KSA9PSBVSW50NjQoMCkKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgVm90ZUxhc3QKICAgICEKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE3MgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludCAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuX19pbml0X18oKSAtPiB2b2lkOgpfX2luaXRfXzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo4OAogICAgLy8gZGVmIF9faW5pdF9fKHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo4OS05MAogICAgLy8gIyBEZWZpbmUgZ2xvYmFsIHN0YXRlCiAgICAvLyBzZWxmLmRlcG9zaXRfdmFsX21pbiA9IFVJbnQ2NCgwKQogICAgYnl0ZSAiZGVwb3NpdF92YWxfbWluIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6OTEKICAgIC8vIHNlbGYuZGVwb3NpdF9kZWxfbWluID0gVUludDY0KDApCiAgICBieXRlICJkZXBvc2l0X2RlbF9taW4iCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo5MgogICAgLy8gc2VsZi52YWxfZWFybl9mYWN0b3IgPSBVSW50NjQoMCkKICAgIGJ5dGUgInZhbF9lYXJuX2ZhY3RvciIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjkzCiAgICAvLyBzZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCA9IFVJbnQ2NCgwKQogICAgYnl0ZSAidmFsX2ZhY3RvcnlfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6OTQKICAgIC8vIHNlbGYubWFuYWdlciA9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJ5dGUgIm1hbmFnZXIiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6OTYKICAgIC8vIHNlbGYubGl2ZSA9IEZhbHNlCiAgICBieXRlICJsaXZlIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6OTcKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgPSBVSW50NjQoMCkKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIK",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuY2xlYXJfc3RhdGVfcHJvZ3JhbToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICBpbnQgMQogICAgcmV0dXJuCg=="
    },
    "state": {
        "global": {
            "num_byte_slices": 1,
            "num_uints": 6
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 4
        }
    },
    "schema": {
        "global": {
            "declared": {
                "blocked_amt": {
                    "type": "uint64",
                    "key": "blocked_amt"
                },
                "deposit_del_min": {
                    "type": "uint64",
                    "key": "deposit_del_min"
                },
                "deposit_val_min": {
                    "type": "uint64",
                    "key": "deposit_val_min"
                },
                "live": {
                    "type": "uint64",
                    "key": "live"
                },
                "manager": {
                    "type": "bytes",
                    "key": "manager"
                },
                "val_earn_factor": {
                    "type": "uint64",
                    "key": "val_earn_factor"
                },
                "val_factory_app_id": {
                    "type": "uint64",
                    "key": "val_factory_app_id"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {
                "balance": {
                    "type": "uint64",
                    "key": "balance"
                },
                "del_app_id": {
                    "type": "uint64",
                    "key": "del_app_id"
                },
                "deposit_amt": {
                    "type": "uint64",
                    "key": "deposit_amt"
                },
                "val_app_id": {
                    "type": "uint64",
                    "key": "val_app_id"
                }
            },
            "reserved": {}
        }
    },
    "contract": {
        "name": "Noticeboard",
        "methods": [
            {
                "name": "setup",
                "args": [
                    {
                        "type": "uint64",
                        "name": "deposit_val_min"
                    },
                    {
                        "type": "uint64",
                        "name": "deposit_del_min"
                    },
                    {
                        "type": "uint64",
                        "name": "val_earn_factor"
                    },
                    {
                        "type": "uint64",
                        "name": "val_factory_app_id"
                    },
                    {
                        "type": "address",
                        "name": "manager"
                    },
                    {
                        "type": "pay",
                        "name": "mbr"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "create_validator_ad",
                "args": [
                    {
                        "type": "pay",
                        "name": "deposit"
                    },
                    {
                        "type": "pay",
                        "name": "mbr_factory"
                    },
                    {
                        "type": "pay",
                        "name": "mbr_val"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "set_validator_ad_mandatory",
                "args": [
                    {
                        "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
                        "name": "val_config_man"
                    },
                    {
                        "type": "bool",
                        "name": "live"
                    },
                    {
                        "type": "address",
                        "name": "manager"
                    },
                    {
                        "type": "uint64",
                        "name": "max_del_cnt"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Creates or updates mandatory part of validator ad and sets liveliness status"
            },
            {
                "name": "set_validator_ad_extra",
                "args": [
                    {
                        "type": "(byte[30],byte[70])",
                        "name": "val_config_extra"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Creates or updates extra part of validator ad"
            },
            {
                "name": "end_validator_ad",
                "args": [],
                "returns": {
                    "type": "void"
                },
                "desc": "Sender can delete the validator ad."
            },
            {
                "name": "val_withdraw_earnings",
                "args": [],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "withdraw_balance",
                "args": [],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "withdraw_depoist",
                "args": [],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "user_opt_in",
                "args": [],
                "returns": {
                    "type": "void"
                },
                "desc": "assert not Txn.sender.is_opted_in(\nGlobal.current_application_id ), \"Account has already opted-in the app.\""
            },
            {
                "name": "create_delegator_contract",
                "args": [
                    {
                        "type": "uint64",
                        "name": "val_app_id"
                    },
                    {
                        "type": "pay",
                        "name": "deposit_payment"
                    },
                    {
                        "type": "pay",
                        "name": "fee_setup_payment"
                    },
                    {
                        "type": "pay",
                        "name": "mbr"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "deposit_keys",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    },
                    {
                        "type": "byte[32]",
                        "name": "sel_key"
                    },
                    {
                        "type": "byte[32]",
                        "name": "vote_key"
                    },
                    {
                        "type": "byte[64]",
                        "name": "state_proof_key"
                    },
                    {
                        "type": "uint64",
                        "name": "vote_key_dilution"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "confirm_keys",
                "args": [
                    {
                        "type": "uint64",
                        "name": "keyreg_txn_index"
                    },
                    {
                        "type": "pay",
                        "name": "fee_operation_payment"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "keys_not_generated",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "keys_not_confirmed",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "end_expired_or_breached_delegator_contract",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Anyone can delete the delegator contract after its expiry or when it was breached."
            },
            {
                "name": "end_active_delegator_contract",
                "args": [
                    {
                        "type": "uint64",
                        "name": "keyreg_txn_index"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Delegator can withdraw from contract and get refunded remaining operational fee."
            }
        ],
        "networks": {},
        "desc": "\n    Platform for peer-to-peer consensus delegation.\n    Node runners, i.e. validators can post ads to offer their services to users.\n    Users, i.e. delegators, can open requests for the service and conclude a contract with a node runner.\n\n    Global state\n    ------------\n        Configuration parameters\n        ------------------------\n        deposit_val_min : UInt64\n            Minimum deposit required to be made by validator to the Noticeboard\n        deposit_del_min : UInt64\n            Minimum deposit required to be made by delegator to the Noticeboard\n        val_earn_factor : UInt64\n            Value scaled to (1-0), representing 1 - percentage of fees taken by the platform\n\n        Variables\n        ---------\n        live : bool\n            Whether the contract is live (true) or has ended (false)\n        blocked_amt : UInt64\n            Balance on the Noticeboard account that can't be withdrawn.\n            It is part either of active deposits or not finalized payments.\n\n    Local state\n    -----------\n        val_app_id : UInt64\n            GeneralValidatorAd ID of the asccount - either as owner of validator or selected validator for UserContract\n        del_app_id : UInt64\n            UserContract ID of the account if the account is user; equals 0 for validator accounts.\n        deposit_amt : UInt64\n            Amount the account has deposited in the Noticeboard\n\n    Boxes\n    -----\n        val_list : Box\n            {key = val_id, value = [val_app_id: UInt64, prev_val_id: UInt64, next_val_id: UInt64] }\n\n    Methods\n    -------\n\n    "
    },
    "bare_call_config": {
        "no_op": "CREATE"
    }
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data)
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class SetupArgs(_ArgsBase[None]):
    deposit_val_min: int
    deposit_del_min: int
    val_earn_factor: int
    val_factory_app_id: int
    manager: str
    mbr: TransactionWithSigner

    @staticmethod
    def method() -> str:
        return "setup(uint64,uint64,uint64,uint64,address,pay)void"


@dataclasses.dataclass(kw_only=True)
class CreateValidatorAdArgs(_ArgsBase[None]):
    deposit: TransactionWithSigner
    mbr_factory: TransactionWithSigner
    mbr_val: TransactionWithSigner

    @staticmethod
    def method() -> str:
        return "create_validator_ad(pay,pay,pay)void"


@dataclasses.dataclass(kw_only=True)
class ValConfigMan:
    hw_cat: int
    min_amt: int
    max_amt: int
    fee_setup: int
    fee_round: int
    deposit: int
    setup_rounds: int
    confirmation_rounds: int
    max_breach: int
    breach_rounds: int
    uptime_gar: int


@dataclasses.dataclass(kw_only=True)
class SetValidatorAdMandatoryArgs(_ArgsBase[None]):
    """Creates or updates mandatory part of validator ad and sets liveliness status"""

    val_config_man: ValConfigMan
    live: bool
    manager: str
    max_del_cnt: int

    @staticmethod
    def method() -> str:
        return "set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void"


@dataclasses.dataclass(kw_only=True)
class ValConfigExtra:
    name: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    link: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class SetValidatorAdExtraArgs(_ArgsBase[None]):
    """Creates or updates extra part of validator ad"""

    val_config_extra: ValConfigExtra

    @staticmethod
    def method() -> str:
        return "set_validator_ad_extra((byte[30],byte[70]))void"


@dataclasses.dataclass(kw_only=True)
class EndValidatorAdArgs(_ArgsBase[None]):
    """Sender can delete the validator ad."""

    @staticmethod
    def method() -> str:
        return "end_validator_ad()void"


@dataclasses.dataclass(kw_only=True)
class ValWithdrawEarningsArgs(_ArgsBase[int]):
    @staticmethod
    def method() -> str:
        return "val_withdraw_earnings()uint64"


@dataclasses.dataclass(kw_only=True)
class WithdrawBalanceArgs(_ArgsBase[int]):
    @staticmethod
    def method() -> str:
        return "withdraw_balance()uint64"


@dataclasses.dataclass(kw_only=True)
class WithdrawDepoistArgs(_ArgsBase[int]):
    @staticmethod
    def method() -> str:
        return "withdraw_depoist()uint64"


@dataclasses.dataclass(kw_only=True)
class CreateDelegatorContractArgs(_ArgsBase[None]):
    val_app_id: int
    deposit_payment: TransactionWithSigner
    fee_setup_payment: TransactionWithSigner
    mbr: TransactionWithSigner
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class DepositKeysArgs(_ArgsBase[None]):
    del_acc: str
    sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key_dilution: int
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class ConfirmKeysArgs(_ArgsBase[None]):
    keyreg_txn_index: int
    fee_operation_payment: TransactionWithSigner

    @staticmethod
    def method() -> str:
        return "confirm_keys(uint64,pay)void"


@dataclasses.dataclass(kw_only=True)
class KeysNotGeneratedArgs(_ArgsBase[None]):
    del_acc: str

    @staticmethod
    def method() -> str:
        return "keys_not_generated(address)void"


@dataclasses.dataclass(kw_only=True)
class KeysNotConfirmedArgs(_ArgsBase[None]):
    del_acc: str

    @staticmethod
    def method() -> str:
        return "keys_not_confirmed(address)void"


@dataclasses.dataclass(kw_only=True)
class EndExpiredOrBreachedDelegatorContractArgs(_ArgsBase[None]):
    """Anyone can delete the delegator contract after its expiry or when it was breached."""

    del_acc: str

    @staticmethod
    def method() -> str:
        return "end_expired_or_breached_delegator_contract(address)void"


@dataclasses.dataclass(kw_only=True)
class EndActiveDelegatorContractArgs(_ArgsBase[None]):
    """Delegator can withdraw from contract and get refunded remaining operational fee."""

    keyreg_txn_index: int

    @staticmethod
    def method() -> str:
        return "end_active_delegator_contract(uint64)void"


@dataclasses.dataclass(kw_only=True)
class UserOptInArgs(_ArgsBase[None]):
    """assert not Txn.sender.is_opted_in(
    Global.current_application_id ), "Account has already opted-in the app." """

    @staticmethod
    def method() -> str:
        return "user_opt_in()void"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.blocked_amt = typing.cast(int, data.get(b"blocked_amt"))
        self.deposit_del_min = typing.cast(int, data.get(b"deposit_del_min"))
        self.deposit_val_min = typing.cast(int, data.get(b"deposit_val_min"))
        self.live = typing.cast(int, data.get(b"live"))
        self.manager = ByteReader(typing.cast(bytes, data.get(b"manager")))
        self.val_earn_factor = typing.cast(int, data.get(b"val_earn_factor"))
        self.val_factory_app_id = typing.cast(int, data.get(b"val_factory_app_id"))


class LocalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.balance = typing.cast(int, data.get(b"balance"))
        self.del_app_id = typing.cast(int, data.get(b"del_app_id"))
        self.deposit_amt = typing.cast(int, data.get(b"deposit_amt"))
        self.val_app_id = typing.cast(int, data.get(b"val_app_id"))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def setup(
        self,
        *,
        deposit_val_min: int,
        deposit_del_min: int,
        val_earn_factor: int,
        val_factory_app_id: int,
        manager: str,
        mbr: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `setup(uint64,uint64,uint64,uint64,address,pay)void` ABI method
        
        :param int deposit_val_min: The `deposit_val_min` ABI parameter
        :param int deposit_del_min: The `deposit_del_min` ABI parameter
        :param int val_earn_factor: The `val_earn_factor` ABI parameter
        :param int val_factory_app_id: The `val_factory_app_id` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetupArgs(
            deposit_val_min=deposit_val_min,
            deposit_del_min=deposit_del_min,
            val_earn_factor=val_earn_factor,
            val_factory_app_id=val_factory_app_id,
            manager=manager,
            mbr=mbr,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_validator_ad(
        self,
        *,
        deposit: TransactionWithSigner,
        mbr_factory: TransactionWithSigner,
        mbr_val: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `create_validator_ad(pay,pay,pay)void` ABI method
        
        :param TransactionWithSigner deposit: The `deposit` ABI parameter
        :param TransactionWithSigner mbr_factory: The `mbr_factory` ABI parameter
        :param TransactionWithSigner mbr_val: The `mbr_val` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateValidatorAdArgs(
            deposit=deposit,
            mbr_factory=mbr_factory,
            mbr_val=mbr_val,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def set_validator_ad_mandatory(
        self,
        *,
        val_config_man: ValConfigMan,
        live: bool,
        manager: str,
        max_del_cnt: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Creates or updates mandatory part of validator ad and sets liveliness status
        
        Adds a call to `set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void` ABI method
        
        :param ValConfigMan val_config_man: The `val_config_man` ABI parameter
        :param bool live: The `live` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param int max_del_cnt: The `max_del_cnt` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetValidatorAdMandatoryArgs(
            val_config_man=val_config_man,
            live=live,
            manager=manager,
            max_del_cnt=max_del_cnt,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def set_validator_ad_extra(
        self,
        *,
        val_config_extra: ValConfigExtra,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Creates or updates extra part of validator ad
        
        Adds a call to `set_validator_ad_extra((byte[30],byte[70]))void` ABI method
        
        :param ValConfigExtra val_config_extra: The `val_config_extra` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetValidatorAdExtraArgs(
            val_config_extra=val_config_extra,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def end_validator_ad(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Sender can delete the validator ad.
        
        Adds a call to `end_validator_ad()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndValidatorAdArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def val_withdraw_earnings(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `val_withdraw_earnings()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ValWithdrawEarningsArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def withdraw_balance(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `withdraw_balance()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = WithdrawBalanceArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def withdraw_depoist(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `withdraw_depoist()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = WithdrawDepoistArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_delegator_contract(
        self,
        *,
        val_app_id: int,
        deposit_payment: TransactionWithSigner,
        fee_setup_payment: TransactionWithSigner,
        mbr: TransactionWithSigner,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void` ABI method
        
        :param int val_app_id: The `val_app_id` ABI parameter
        :param TransactionWithSigner deposit_payment: The `deposit_payment` ABI parameter
        :param TransactionWithSigner fee_setup_payment: The `fee_setup_payment` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateDelegatorContractArgs(
            val_app_id=val_app_id,
            deposit_payment=deposit_payment,
            fee_setup_payment=fee_setup_payment,
            mbr=mbr,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def deposit_keys(
        self,
        *,
        del_acc: str,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = DepositKeysArgs(
            del_acc=del_acc,
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def confirm_keys(
        self,
        *,
        keyreg_txn_index: int,
        fee_operation_payment: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `confirm_keys(uint64,pay)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param TransactionWithSigner fee_operation_payment: The `fee_operation_payment` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ConfirmKeysArgs(
            keyreg_txn_index=keyreg_txn_index,
            fee_operation_payment=fee_operation_payment,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_generated(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `keys_not_generated(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotGeneratedArgs(
            del_acc=del_acc,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_confirmed(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `keys_not_confirmed(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotConfirmedArgs(
            del_acc=del_acc,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def end_expired_or_breached_delegator_contract(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Anyone can delete the delegator contract after its expiry or when it was breached.
        
        Adds a call to `end_expired_or_breached_delegator_contract(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndExpiredOrBreachedDelegatorContractArgs(
            del_acc=del_acc,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def end_active_delegator_contract(
        self,
        *,
        keyreg_txn_index: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator can withdraw from contract and get refunded remaining operational fee.
        
        Adds a call to `end_active_delegator_contract(uint64)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndActiveDelegatorContractArgs(
            keyreg_txn_index=keyreg_txn_index,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_bare(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to create an application using the no_op bare method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        self.app_client.compose_create(
            self.atc,
            call_abi_method=False,
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
        )
        return self

    def opt_in_user_opt_in(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """assert not Txn.sender.is_opted_in(
        Global.current_application_id ), "Account has already opted-in the app."
        
        Adds a call to `user_opt_in()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = UserOptInArgs()
        self.app_client.compose_opt_in(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class NoticeboardClient:
    """
        Platform for peer-to-peer consensus delegation.
        Node runners, i.e. validators can post ads to offer their services to users.
        Users, i.e. delegators, can open requests for the service and conclude a contract with a node runner.
    
        Global state
        ------------
            Configuration parameters
            ------------------------
            deposit_val_min : UInt64
                Minimum deposit required to be made by validator to the Noticeboard
            deposit_del_min : UInt64
                Minimum deposit required to be made by delegator to the Noticeboard
            val_earn_factor : UInt64
                Value scaled to (1-0), representing 1 - percentage of fees taken by the platform
    
            Variables
            ---------
            live : bool
                Whether the contract is live (true) or has ended (false)
            blocked_amt : UInt64
                Balance on the Noticeboard account that can't be withdrawn.
                It is part either of active deposits or not finalized payments.
    
        Local state
        -----------
            val_app_id : UInt64
                GeneralValidatorAd ID of the asccount - either as owner of validator or selected validator for UserContract
            del_app_id : UInt64
                UserContract ID of the account if the account is user; equals 0 for validator accounts.
            deposit_amt : UInt64
                Amount the account has deposited in the Noticeboard
    
        Boxes
        -----
            val_list : Box
                {key = val_id, value = [val_app_id: UInt64, prev_val_id: UInt64, next_val_id: UInt64] }
    
        Methods
        -------
    
        
    
    A class for interacting with the Noticeboard app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        NoticeboardClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def get_local_state(self, account: str | None = None) -> LocalState:
        """Returns the application's local state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_local_state(account, raw=True))
        return LocalState(state)

    def setup(
        self,
        *,
        deposit_val_min: int,
        deposit_del_min: int,
        val_earn_factor: int,
        val_factory_app_id: int,
        manager: str,
        mbr: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `setup(uint64,uint64,uint64,uint64,address,pay)void` ABI method
        
        :param int deposit_val_min: The `deposit_val_min` ABI parameter
        :param int deposit_del_min: The `deposit_del_min` ABI parameter
        :param int val_earn_factor: The `val_earn_factor` ABI parameter
        :param int val_factory_app_id: The `val_factory_app_id` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetupArgs(
            deposit_val_min=deposit_val_min,
            deposit_del_min=deposit_del_min,
            val_earn_factor=val_earn_factor,
            val_factory_app_id=val_factory_app_id,
            manager=manager,
            mbr=mbr,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_validator_ad(
        self,
        *,
        deposit: TransactionWithSigner,
        mbr_factory: TransactionWithSigner,
        mbr_val: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `create_validator_ad(pay,pay,pay)void` ABI method
        
        :param TransactionWithSigner deposit: The `deposit` ABI parameter
        :param TransactionWithSigner mbr_factory: The `mbr_factory` ABI parameter
        :param TransactionWithSigner mbr_val: The `mbr_val` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CreateValidatorAdArgs(
            deposit=deposit,
            mbr_factory=mbr_factory,
            mbr_val=mbr_val,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def set_validator_ad_mandatory(
        self,
        *,
        val_config_man: ValConfigMan,
        live: bool,
        manager: str,
        max_del_cnt: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Creates or updates mandatory part of validator ad and sets liveliness status
        
        Calls `set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void` ABI method
        
        :param ValConfigMan val_config_man: The `val_config_man` ABI parameter
        :param bool live: The `live` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param int max_del_cnt: The `max_del_cnt` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetValidatorAdMandatoryArgs(
            val_config_man=val_config_man,
            live=live,
            manager=manager,
            max_del_cnt=max_del_cnt,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def set_validator_ad_extra(
        self,
        *,
        val_config_extra: ValConfigExtra,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Creates or updates extra part of validator ad
        
        Calls `set_validator_ad_extra((byte[30],byte[70]))void` ABI method
        
        :param ValConfigExtra val_config_extra: The `val_config_extra` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetValidatorAdExtraArgs(
            val_config_extra=val_config_extra,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def end_validator_ad(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Sender can delete the validator ad.
        
        Calls `end_validator_ad()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = EndValidatorAdArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def val_withdraw_earnings(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `val_withdraw_earnings()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = ValWithdrawEarningsArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def withdraw_balance(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `withdraw_balance()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = WithdrawBalanceArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def withdraw_depoist(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `withdraw_depoist()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = WithdrawDepoistArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_delegator_contract(
        self,
        *,
        val_app_id: int,
        deposit_payment: TransactionWithSigner,
        fee_setup_payment: TransactionWithSigner,
        mbr: TransactionWithSigner,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void` ABI method
        
        :param int val_app_id: The `val_app_id` ABI parameter
        :param TransactionWithSigner deposit_payment: The `deposit_payment` ABI parameter
        :param TransactionWithSigner fee_setup_payment: The `fee_setup_payment` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CreateDelegatorContractArgs(
            val_app_id=val_app_id,
            deposit_payment=deposit_payment,
            fee_setup_payment=fee_setup_payment,
            mbr=mbr,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def deposit_keys(
        self,
        *,
        del_acc: str,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = DepositKeysArgs(
            del_acc=del_acc,
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def confirm_keys(
        self,
        *,
        keyreg_txn_index: int,
        fee_operation_payment: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `confirm_keys(uint64,pay)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param TransactionWithSigner fee_operation_payment: The `fee_operation_payment` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = ConfirmKeysArgs(
            keyreg_txn_index=keyreg_txn_index,
            fee_operation_payment=fee_operation_payment,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_not_generated(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `keys_not_generated(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = KeysNotGeneratedArgs(
            del_acc=del_acc,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_not_confirmed(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `keys_not_confirmed(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = KeysNotConfirmedArgs(
            del_acc=del_acc,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def end_expired_or_breached_delegator_contract(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Anyone can delete the delegator contract after its expiry or when it was breached.
        
        Calls `end_expired_or_breached_delegator_contract(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = EndExpiredOrBreachedDelegatorContractArgs(
            del_acc=del_acc,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def end_active_delegator_contract(
        self,
        *,
        keyreg_txn_index: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Delegator can withdraw from contract and get refunded remaining operational fee.
        
        Calls `end_active_delegator_contract(uint64)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = EndActiveDelegatorContractArgs(
            keyreg_txn_index=keyreg_txn_index,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_bare(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Creates an application using the no_op bare method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.TransactionResponse: The result of the transaction"""

        result = self.app_client.create(
            call_abi_method=False,
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
        )
        return result

    def opt_in_user_opt_in(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """assert not Txn.sender.is_opted_in(
        Global.current_application_id ), "Account has already opted-in the app."
        
        Calls `user_opt_in()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = UserOptInArgs()
        result = self.app_client.opt_in(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: algokit_utils.DeployCallArgs | None = None,
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: algokit_utils.DeployCallArgs | None = None,
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param algokit_utils.DeployCallArgs | None create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param algokit_utils.DeployCallArgs | None delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())