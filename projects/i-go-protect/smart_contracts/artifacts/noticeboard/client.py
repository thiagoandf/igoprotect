# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "setup(uint64,uint64,uint64,uint64,address,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "create_validator_ad(pay,pay,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void": {
            "structs": {
                "val_config_man": {
                    "name": "ValConfigMan",
                    "elements": [
                        [
                            "hw_cat",
                            "uint64"
                        ],
                        [
                            "min_amt",
                            "uint64"
                        ],
                        [
                            "max_amt",
                            "uint64"
                        ],
                        [
                            "fee_setup",
                            "uint64"
                        ],
                        [
                            "fee_round",
                            "uint64"
                        ],
                        [
                            "deposit",
                            "uint64"
                        ],
                        [
                            "setup_rounds",
                            "uint64"
                        ],
                        [
                            "confirmation_rounds",
                            "uint64"
                        ],
                        [
                            "max_breach",
                            "uint64"
                        ],
                        [
                            "breach_rounds",
                            "uint64"
                        ],
                        [
                            "uptime_gar",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "set_validator_ad_extra((byte[30],byte[70]))void": {
            "structs": {
                "val_config_extra": {
                    "name": "ValConfigExtra",
                    "elements": [
                        [
                            "name",
                            "byte[30]"
                        ],
                        [
                            "link",
                            "byte[70]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end_validator_ad()void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "val_withdraw_earnings()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "withdraw_balance()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "withdraw_depoist()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "user_opt_in()void": {
            "call_config": {
                "opt_in": "CALL"
            }
        },
        "create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "confirm_keys(uint64,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_generated(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_confirmed(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end_expired_or_breached_delegator_contract(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "end_active_delegator_contract(uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuYXBwcm92YWxfcHJvZ3JhbToKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9lbnRyeXBvaW50QDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fZW50cnlwb2ludEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AyMgogICAgbWV0aG9kICJzZXR1cCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxwYXkpdm9pZCIKICAgIG1ldGhvZCAiY3JlYXRlX3ZhbGlkYXRvcl9hZChwYXkscGF5LHBheSl2b2lkIgogICAgbWV0aG9kICJzZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeSgodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzZXRfdmFsaWRhdG9yX2FkX2V4dHJhKChieXRlWzMwXSxieXRlWzcwXSkpdm9pZCIKICAgIG1ldGhvZCAiZW5kX3ZhbGlkYXRvcl9hZCgpdm9pZCIKICAgIG1ldGhvZCAidmFsX3dpdGhkcmF3X2Vhcm5pbmdzKCl1aW50NjQiCiAgICBtZXRob2QgIndpdGhkcmF3X2JhbGFuY2UoKXVpbnQ2NCIKICAgIG1ldGhvZCAid2l0aGRyYXdfZGVwb2lzdCgpdWludDY0IgogICAgbWV0aG9kICJ1c2VyX29wdF9pbigpdm9pZCIKICAgIG1ldGhvZCAiY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCh1aW50NjQscGF5LHBheSxwYXksdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJkZXBvc2l0X2tleXMoYWRkcmVzcyxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJjb25maXJtX2tleXModWludDY0LHBheSl2b2lkIgogICAgbWV0aG9kICJrZXlzX25vdF9nZW5lcmF0ZWQoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJrZXlzX25vdF9jb25maXJtZWQoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJlbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3QoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdCh1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fc2V0dXBfcm91dGVANCBtYWluX2NyZWF0ZV92YWxpZGF0b3JfYWRfcm91dGVANSBtYWluX3NldF92YWxpZGF0b3JfYWRfbWFuZGF0b3J5X3JvdXRlQDYgbWFpbl9zZXRfdmFsaWRhdG9yX2FkX2V4dHJhX3JvdXRlQDcgbWFpbl9lbmRfdmFsaWRhdG9yX2FkX3JvdXRlQDggbWFpbl92YWxfd2l0aGRyYXdfZWFybmluZ3Nfcm91dGVAOSBtYWluX3dpdGhkcmF3X2JhbGFuY2Vfcm91dGVAMTAgbWFpbl93aXRoZHJhd19kZXBvaXN0X3JvdXRlQDExIG1haW5fdXNlcl9vcHRfaW5fcm91dGVAMTIgbWFpbl9jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDEzIG1haW5fZGVwb3NpdF9rZXlzX3JvdXRlQDE0IG1haW5fY29uZmlybV9rZXlzX3JvdXRlQDE1IG1haW5fa2V5c19ub3RfZ2VuZXJhdGVkX3JvdXRlQDE2IG1haW5fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDE3IG1haW5fZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDE4IG1haW5fZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3Rfcm91dGVAMTkKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fc2V0dXBfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBzZXR1cAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfdmFsaWRhdG9yX2FkX3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTUyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMwogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNyZWF0ZV92YWxpZGF0b3JfYWQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnlfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIxNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnkKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZhbGlkYXRvcl9hZF9leHRyYV9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBzZXRfdmFsaWRhdG9yX2FkX2V4dHJhCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF92YWxpZGF0b3JfYWRfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNjEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGVuZF92YWxpZGF0b3JfYWQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fdmFsX3dpdGhkcmF3X2Vhcm5pbmdzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjkyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB2YWxfd2l0aGRyYXdfZWFybmluZ3MKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fd2l0aGRyYXdfYmFsYW5jZV9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMTctMzIwCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAgICAgICAgICAgRm9yIGFsbCB1c2VycyAgICAgICAgICAgLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhd19iYWxhbmNlCiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X2RlcG9pc3Rfcm91dGVAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzM3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhd19kZXBvaXN0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3VzZXJfb3B0X2luX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM2MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJPcHRJbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgaW50IE9wdEluCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBPcHRJbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgdXNlcl9vcHRfaW4KICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdF9yb3V0ZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozODEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAzCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDIKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM4MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9kZXBvc2l0X2tleXNfcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGRlcG9zaXRfa2V5cwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jb25maXJtX2tleXNfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29uZmlybV9rZXlzCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2tleXNfbm90X2dlbmVyYXRlZF9yb3V0ZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU0MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19ub3RfZ2VuZXJhdGVkCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2tleXNfbm90X2NvbmZpcm1lZF9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU3MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19ub3RfY29uZmlybWVkCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYwMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0CiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYzMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjMzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5zZXR1cChkZXBvc2l0X3ZhbF9taW46IGJ5dGVzLCBkZXBvc2l0X2RlbF9taW46IGJ5dGVzLCB2YWxfZWFybl9mYWN0b3I6IGJ5dGVzLCB2YWxfZmFjdG9yeV9hcHBfaWQ6IGJ5dGVzLCBtYW5hZ2VyOiBieXRlcywgbWJyOiB1aW50NjQpIC0+IHZvaWQ6CnNldHVwOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEwNS0xMTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0dXAoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZXBvc2l0X3ZhbF9taW46IGFyYzQuVUludDY0LAogICAgLy8gICAgIGRlcG9zaXRfZGVsX21pbjogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgdmFsX2Vhcm5fZmFjdG9yOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICB2YWxfZmFjdG9yeV9hcHBfaWQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIG1hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBtYnI6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTE1CiAgICAvLyBhc3NlcnQgbm90IHNlbGYubGl2ZSwgIk5vdGljZWJvYXJkIGlzIG5vdCB5ZXQgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBub3QgeWV0IGxpdmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTE3CiAgICAvLyBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMTYtMTE4CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcwogICAgLy8gKSwgIlNldHVwIGNhbiBiZSBkb25lIG9ubHkgYnkgY29udHJhY3QgY3JlYXRvci4iCiAgICBhc3NlcnQgLy8gU2V0dXAgY2FuIGJlIGRvbmUgb25seSBieSBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEyMQogICAgLy8gZGVwb3NpdF9kZWxfbWluLm5hdGl2ZSAqIE1BWF9ERUxfQ05UIDw9IGRlcG9zaXRfdmFsX21pbi5uYXRpdmUKICAgIGZyYW1lX2RpZyAtNQogICAgYnRvaQogICAgZHVwCiAgICBpbnQgNAogICAgKgogICAgZnJhbWVfZGlnIC02CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTIwLTEyMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBkZXBvc2l0X2RlbF9taW4ubmF0aXZlICogTUFYX0RFTF9DTlQgPD0gZGVwb3NpdF92YWxfbWluLm5hdGl2ZQogICAgLy8gKSwgIlZhbGlkYXRvcidzIGRlcG9zaXQgbXVzdCBjb3ZlciBhdCBsZWFzdCBlYWNoIGRlbGVnYXRvcidzIGRlcG9zaXQuIgogICAgYXNzZXJ0IC8vIFZhbGlkYXRvcidzIGRlcG9zaXQgbXVzdCBjb3ZlciBhdCBsZWFzdCBlYWNoIGRlbGVnYXRvcidzIGRlcG9zaXQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI0CiAgICAvLyBzZWxmLmRlcG9zaXRfdmFsX21pbiA9IGRlcG9zaXRfdmFsX21pbi5uYXRpdmUKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI1CiAgICAvLyBzZWxmLmRlcG9zaXRfZGVsX21pbiA9IGRlcG9zaXRfZGVsX21pbi5uYXRpdmUKICAgIGJ5dGUgImRlcG9zaXRfZGVsX21pbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI4CiAgICAvLyBVSW50NjQoMCkgPCB2YWxfZWFybl9mYWN0b3IubmF0aXZlIDwgVUludDY0KDEwMCkKICAgIGZyYW1lX2RpZyAtNAogICAgYnRvaQogICAgZHVwCiAgICBieiBzZXR1cF9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAwCiAgICBpbnQgMTAwCiAgICA8CiAgICBieiBzZXR1cF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIHNldHVwX2Jvb2xfbWVyZ2VANAoKc2V0dXBfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCnNldHVwX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMjctMTI5CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFVJbnQ2NCgwKSA8IHZhbF9lYXJuX2ZhY3Rvci5uYXRpdmUgPCBVSW50NjQoMTAwKQogICAgLy8gKSwgIlZhbGlkYXRvciBmYWN0b3IgY2FuJ3QgYmUgbGFyZ2VyIHRoYW4gMTAwIG9yIHNtYWxsZXIgdGhhbiAwLiIKICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgZmFjdG9yIGNhbid0IGJlIGxhcmdlciB0aGFuIDEwMCBvciBzbWFsbGVyIHRoYW4gMC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzEKICAgIC8vIHNlbGYudmFsX2Vhcm5fZmFjdG9yID0gdmFsX2Vhcm5fZmFjdG9yLm5hdGl2ZQogICAgYnl0ZSAidmFsX2Vhcm5fZmFjdG9yIgogICAgZnJhbWVfZGlnIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTMyCiAgICAvLyBzZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCA9IHZhbF9mYWN0b3J5X2FwcF9pZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMwogICAgYnRvaQogICAgYnl0ZSAidmFsX2ZhY3RvcnlfYXBwX2lkIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzMKICAgIC8vIHNlbGYubWFuYWdlciA9IG1hbmFnZXIubmF0aXZlCiAgICBieXRlICJtYW5hZ2VyIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEzNS0xMzYKICAgIC8vICMgQ3JlYXRlIGJveCBmb3IgbGlzdCBvZiB2YWxpZGF0b3JzCiAgICAvLyBhc3NlcnQgb3AuQm94LmNyZWF0ZShCeXRlcyhWQUxfTElTVCksIFZBTF9MSVNUX0VMX0JZVEVfU0laRSAqIE1BWF9WQUxfQ05UKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBpbnQgODAwCiAgICBib3hfY3JlYXRlCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDAKICAgIC8vIG1ici5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzgtMTQxCiAgICAvLyAjIEFzc2VydCBpbmNyZWFzZSBpbiBtaW5pbXVtIGJhbGFuY2UgcmVxdWlyZW1lbnQgZm9yIGJveCBmb3IgdmFsaWRhdG9yIGxpc3QKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJNQlIgaW5jcmVhc2UgZm9yIGJveCBvZiB2YWxpZGF0b3IgbGlzdCBuZWVkcyB0byBiZSBjb3ZlcmVkLiIKICAgIGFzc2VydCAvLyBNQlIgaW5jcmVhc2UgZm9yIGJveCBvZiB2YWxpZGF0b3IgbGlzdCBuZWVkcyB0byBiZSBjb3ZlcmVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE0MgogICAgLy8gYXNzZXJ0IG1ici5hbW91bnQgPT0gTUJSX0JPWF9WQUxfTElTVF9DUkVBVElPTgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludCAzMjU3MDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDQKICAgIC8vIHNlbGYubGl2ZSA9IFRydWUKICAgIGJ5dGUgImxpdmUiCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDYKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmNyZWF0ZV92YWxpZGF0b3JfYWQoZGVwb3NpdDogdWludDY0LCBtYnJfZmFjdG9yeTogdWludDY0LCBtYnJfdmFsOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZV92YWxpZGF0b3JfYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTUyLTE1OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfdmFsaWRhdG9yX2FkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVwb3NpdDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWJyX2ZhY3Rvcnk6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIG1icl92YWw6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTU5CiAgICAvLyBhc3NlcnQgc2VsZi5saXZlLCAiTm90aWNlYm9hcmQgaXMgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBsaXZlLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE2NC0xNjUKICAgIC8vICMgQW4gYWNjb3VudCBjYW4gaGF2ZSBvbmx5IG9uZSByb2xlIGluIHRoZSBwbGF0Zm9ybSAtIGVpdGhlciBVc2VyQ29udHJhY3Qgb3IgR2VuZXJhbFZhbGlkYXRvckFkCiAgICAvLyBhc3NlcnQgc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdID09IDAsICJBY2NvdW50IGRvZXNuJ3QgeWV0IGhhdmUgYSByb2xlLiIKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAhCiAgICBhc3NlcnQgLy8gQWNjb3VudCBkb2Vzbid0IHlldCBoYXZlIGEgcm9sZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNjkKICAgIC8vIGRlcG9zaXQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTY3LTE3MAogICAgLy8gIyBBc3NlcnQgbWluaW11bSB2YWxpZGF0b3IgZGVwb3NpdCB3YXMgcGFpZAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBkZXBvc2l0LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJWYWxpZGF0b3IgZGVwb3NpdCB3YXNuJ3QgbWFkZSB0byBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGRlcG9zaXQgd2Fzbid0IG1hZGUgdG8gbm90aWNlYm9hcmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTcyCiAgICAvLyBkZXBvc2l0LmFtb3VudCA+PSBzZWxmLmRlcG9zaXRfdmFsX21pbgogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBBbW91bnQKICAgIGludCAwCiAgICBieXRlICJkZXBvc2l0X3ZhbF9taW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfdmFsX21pbiBleGlzdHMKICAgIGRpZyAxCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3MS0xNzMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVwb3NpdC5hbW91bnQgPj0gc2VsZi5kZXBvc2l0X3ZhbF9taW4KICAgIC8vICksICJWYWxpZGF0b3IgZGlkbid0IGRlcG9zaXQgbWluaW11bSByZXF1aXJlZCBhbW91bnQuIgogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBkaWRuJ3QgZGVwb3NpdCBtaW5pbXVtIHJlcXVpcmVkIGFtb3VudC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNzUtMTc2CiAgICAvLyAjIE1hcmsgZGVwb3NpdCBhbW91bnQgaW4gdXNlcidzIGxvY2FsIHN0b3JhZ2UKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPSBkZXBvc2l0LmFtb3VudAogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICBkaWcgMgogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3OC0xODYKICAgIC8vICMgQ3JlYXRlIFZhbGRpYXRvckFkCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdmYWN0b3J5VmFsaWRhdG9yQWQuZ2VuZXJhdGVfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBzZWxmLnZhbF9lYXJuX2ZhY3RvciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE4MQogICAgLy8gYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE4MgogICAgLy8gc2VsZi52YWxfZWFybl9mYWN0b3IsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2Vhcm5fZmFjdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfZWFybl9mYWN0b3IgZXhpc3RzCiAgICBpdG9iCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTgzCiAgICAvLyBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODQKICAgIC8vIGFwcF9pZD1zZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCwKICAgIGludCAwCiAgICBieXRlICJ2YWxfZmFjdG9yeV9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9mYWN0b3J5X2FwcF9pZCBleGlzdHMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3OC0xODYKICAgIC8vICMgQ3JlYXRlIFZhbGRpYXRvckFkCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdmYWN0b3J5VmFsaWRhdG9yQWQuZ2VuZXJhdGVfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBzZWxmLnZhbF9lYXJuX2ZhY3RvciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgbWV0aG9kICJnZW5lcmF0ZV92YWxpZGF0b3JfYWQoYWRkcmVzcyx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODUKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTc4LTE4NgogICAgLy8gIyBDcmVhdGUgVmFsZGlhdG9yQWQKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2ZhY3RvcnlWYWxpZGF0b3JBZC5nZW5lcmF0ZV92YWxpZGF0b3JfYWQsCiAgICAvLyAgICAgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHNlbGYudmFsX2Vhcm5fZmFjdG9yLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXQuYW1vdW50KSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi52YWxfZmFjdG9yeV9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTg3CiAgICAvLyBjcmVhdGVkX2FwcF9pZCA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODgtMTg5CiAgICAvLyAjIFN0b3JlIGNyZWF0ZWQgR2VuZXJhbFZhbGlkYXRvckFkIElEIGluIHZhbGlkYXRvcidzIGxvY2FsIHN0b3JhZ2UKICAgIC8vIHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXSA9IGNyZWF0ZWRfYXBwX2lkCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgZGlnIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxOTEtMTkyCiAgICAvLyAjIEFkZCBuZXcgR2VuZXJhbFZhbGlkYXRvckFkIHRvIGxpc3Qgb2YgdmFsaWRhdG9ycwogICAgLy8gYXNzZXJ0IHZhbF9saXN0X2FkZChjcmVhdGVkX2FwcF9pZCksICJWYWxpZGF0b3IgbGlzdCBpcyBmdWxsLiIKICAgIGR1cAogICAgY2FsbHN1YiB2YWxfbGlzdF9hZGQKICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgbGlzdCBpcyBmdWxsLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE5NwogICAgLy8gbWJyX2ZhY3RvcnkucmVjZWl2ZXIgPT0gQXBwbGljYXRpb24oc2VsZi52YWxfZmFjdG9yeV9hcHBfaWQpLmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfZmFjdG9yeV9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9mYWN0b3J5X2FwcF9pZCBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTk0LTE5OAogICAgLy8gIyBBc3NlcnQgaW5jcmVhc2UgaW4gbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IHdhcyBwYWlkIGZvciBOb3RpY2Vib2FyZCBkdWUgdG8KICAgIC8vICMgR2VuZXJhbFZhbGlkYXRvckFkIGNyZWF0aW9uCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl9mYWN0b3J5LnJlY2VpdmVyID09IEFwcGxpY2F0aW9uKHNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkKS5hZGRyZXNzCiAgICAvLyApLCAiTUJSIGluY3JlYXNlIG9mIGZhY3Rvcnkgb2YgdmFsaWRhdG9yIGFkcyBuZWVkcyB0byBiZSBjb3ZlcmVkLiIKICAgIGFzc2VydCAvLyBNQlIgaW5jcmVhc2Ugb2YgZmFjdG9yeSBvZiB2YWxpZGF0b3IgYWRzIG5lZWRzIHRvIGJlIGNvdmVyZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTk5CiAgICAvLyBhc3NlcnQgbWJyX2ZhY3RvcnkuYW1vdW50ID09IE1CUl9WQUxJREFUT1JBRF9DUkVBVElPTgogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIGludCA4OTk1MDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDEtMjAyCiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZAogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSBkZXBvc2l0LmFtb3VudAogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIHVuY292ZXIgMgogICAgKwogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwNgogICAgLy8gbWJyX3ZhbC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDQtMjA3CiAgICAvLyAjIEFzc2VydCBNQlIgd2FzIHBhaWQgZm9yIHZhbGlkYXRvciBhZGRyZXNzLCBzbyB0aGF0IG5vdGljZSBib2FyZCBjYW4gZnVuZCBpdAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfdmFsLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJNQlIgd2Fzbid0IHBhaWQgdG8gbm90aWNlYm9hcmQuIgogICAgYXNzZXJ0IC8vIE1CUiB3YXNuJ3QgcGFpZCB0byBub3RpY2Vib2FyZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDgKICAgIC8vIGFzc2VydCBtYnJfdmFsLmFtb3VudCA9PSBVSW50NjQoCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwOC0yMTAKICAgIC8vIGFzc2VydCBtYnJfdmFsLmFtb3VudCA9PSBVSW50NjQoCiAgICAvLyAgICAgMTAwXzAwMAogICAgLy8gKSwgIlZhbGlkYXRvciBkaWRuJ3QgZGVwb3NpdCBtaW5pbXVtIHJlcXVpcmVkIGFtb3VudCB0byB2YWxpZGF0b3IgYWQuIgogICAgaW50IDEwMDAwMAogICAgPT0KICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgZGlkbid0IGRlcG9zaXQgbWluaW11bSByZXF1aXJlZCBhbW91bnQgdG8gdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIxMgogICAgLy8gcGF5X3RvX2FjYyhVSW50NjQoMTAwXzAwMCksIEFwcGxpY2F0aW9uKGNyZWF0ZWRfYXBwX2lkKS5hZGRyZXNzKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50IDEwMDAwMAogICAgc3dhcAogICAgY2FsbHN1YiBwYXlfdG9fYWNjCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QudmFsX2xpc3RfYWRkKHZhbF9hcHBfaWQ6IHVpbnQ2NCkgLT4gdWludDY0Ogp2YWxfbGlzdF9hZGQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzEzLTcxNQogICAgLy8gIyAtLS0tLS0tIFN1YnJvdXRpbmUgdXRpbHMgLS0tLS0tLQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiB2YWxfbGlzdF9hZGQodmFsX2FwcF9pZDogVUludDY0KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICBpbnQgMAogICAgYnl0ZSAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzI5LTczMAogICAgLy8gIyBHZXQgYm94IHdpdGggdmFsaWRhdG9yIGxpc3QKICAgIC8vIHZhbF9saXN0X2JveCwgYm94X2dldCA9IG9wLkJveC5nZXQoQnl0ZXMoVkFMX0xJU1QpKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBib3hfZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzMxCiAgICAvLyBhc3NlcnQgYm94X2dldCwgIkdvdCBib3giCiAgICBhc3NlcnQgLy8gR290IGJveAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjczNC03MzUKICAgIC8vICMgQWRkIGl0IHRvIHRoZSBmaXJzdCBub24temVybyBwbGFjZQogICAgLy8gdmFsX2FkZGVkID0gRmFsc2UKICAgIGludCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzM2CiAgICAvLyBmb3IgdmFsX2lkeCBpbiB1cmFuZ2UoTUFYX1ZBTF9DTlQpOgogICAgZHVwCgp2YWxfbGlzdF9hZGRfZm9yX2hlYWRlckAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjczNgogICAgLy8gZm9yIHZhbF9pZHggaW4gdXJhbmdlKE1BWF9WQUxfQ05UKToKICAgIGZyYW1lX2RpZyA2CiAgICBpbnQgMTAwCiAgICA8CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfZGlnIDUKICAgIGZyYW1lX2J1cnkgMwogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2J1cnkgMAogICAgYnogdmFsX2xpc3RfYWRkX2FmdGVyX2ZvckA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzM3CiAgICAvLyBpZiB2YWxfbGlzdFt2YWxfaWR4XSA9PSBhcmM0LlVJbnQ2NCgwKToKICAgIGZyYW1lX2RpZyAxCiAgICBhc3NlcnQgLy8gSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyA2CiAgICBpbnQgOAogICAgKgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIGZyYW1lX2RpZyA0CiAgICBzd2FwCiAgICBpbnQgOAogICAgZXh0cmFjdDMKICAgIGJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBiPT0KICAgIGJ6IHZhbF9saXN0X2FkZF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MzgKICAgIC8vIHZhbF9saXN0W3ZhbF9pZHhdID0gYXJjNC5VSW50NjQodmFsX2FwcF9pZCkKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2RpZyAyCiAgICB1bmNvdmVyIDIKICAgIHJlcGxhY2UzCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MzkKICAgIC8vIHZhbF9hZGRlZCA9IFRydWUKICAgIGludCAxCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NDAKICAgIC8vIGJyZWFrCiAgICBiIHZhbF9saXN0X2FkZF9hZnRlcl9mb3JANwoKdmFsX2xpc3RfYWRkX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MzYKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEKICAgICsKICAgIGZyYW1lX2J1cnkgNgogICAgYiB2YWxfbGlzdF9hZGRfZm9yX2hlYWRlckAxCgp2YWxfbGlzdF9hZGRfYWZ0ZXJfZm9yQDc6CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0MgogICAgLy8gb3AuQm94LnB1dChCeXRlcyhWQUxfTElTVCksIHZhbF9saXN0LmJ5dGVzKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBmcmFtZV9kaWcgMAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0NAogICAgLy8gcmV0dXJuIHZhbF9hZGRlZAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24ucGF5X3RvX2FjYyhhbW91bnQ6IHVpbnQ2NCwgYWNjb3VudDogYnl0ZXMpIC0+IHZvaWQ6CnBheV90b19hY2M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTQ0LTE0NQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBwYXlfdG9fYWNjKGFtb3VudDogVUludDY0LCBhY2NvdW50OiBBY2NvdW50KSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTQ2LTE1MAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI9YWNjb3VudCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0NgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0OQogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNDYtMTUwCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1hY2NvdW50LAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5zZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeSh2YWxfY29uZmlnX21hbjogYnl0ZXMsIGxpdmU6IGJ5dGVzLCBtYW5hZ2VyOiBieXRlcywgbWF4X2RlbF9jbnQ6IGJ5dGVzKSAtPiB2b2lkOgpzZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMTQtMjIxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIHNldF92YWxpZGF0b3JfYWRfbWFuZGF0b3J5KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX2NvbmZpZ19tYW46IFZhbENvbmZpZ01hbiwKICAgIC8vICAgICBsaXZlOiBhcmM0LkJvb2wsCiAgICAvLyAgICAgbWFuYWdlcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIG1heF9kZWxfY250OiBhcmM0LlVJbnQ2NCwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDQgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyMwogICAgLy8gc2VsZi5kZXBvc2l0X3N1ZmZpY2llbnQoKQogICAgY2FsbHN1YiBkZXBvc2l0X3N1ZmZpY2llbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMjUKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjI2CiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyOAogICAgLy8gYXNzZXJ0IGRlbF9hcHBfaWQgPT0gVUludDY0KDApLCAiVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuIgogICAgIQogICAgYXNzZXJ0IC8vIFVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyOQogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApLCAiVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4iCiAgICBkdXAKICAgIGFzc2VydCAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIzMS0yMzkKICAgIC8vIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLnNldF9tYW5kYXRvcnksCiAgICAvLyAgICAgdmFsX2NvbmZpZ19tYW4uY29weSgpLAogICAgLy8gICAgIGxpdmUsCiAgICAvLyAgICAgbWFuYWdlci5jb3B5KCksCiAgICAvLyAgICAgbWF4X2RlbF9jbnQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIG1ldGhvZCAic2V0X21hbmRhdG9yeSgodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjM4CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIzMS0yMzkKICAgIC8vIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLnNldF9tYW5kYXRvcnksCiAgICAvLyAgICAgdmFsX2NvbmZpZ19tYW4uY29weSgpLAogICAgLy8gICAgIGxpdmUsCiAgICAvLyAgICAgbWFuYWdlci5jb3B5KCksCiAgICAvLyAgICAgbWF4X2RlbF9jbnQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0MAogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuZGVwb3NpdF9zdWZmaWNpZW50KCkgLT4gdm9pZDoKZGVwb3NpdF9zdWZmaWNpZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcwNS03MDcKICAgIC8vICMgLS0tLS0gQ2hlY2sgaWYgYmVsb3cgaXMgbmVlZGVkIGF0IGFsbCAtLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZGVwb3NpdF9zdWZmaWNpZW50KHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDkKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPiBzZWxmLmRlcG9zaXRfdmFsX21pbgogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfYW10IGV4aXN0cyBmb3IgYWNjb3VudAogICAgaW50IDAKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVwb3NpdF92YWxfbWluIGV4aXN0cwogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcwOC03MTAKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXSA+IHNlbGYuZGVwb3NpdF92YWxfbWluCiAgICAvLyApLCAiQWN0aW9uIGJsb2NrZWQgZHVlIHRvIGluc3VmZmljaWVudCBkZXBvc2l0IgogICAgYXNzZXJ0IC8vIEFjdGlvbiBibG9ja2VkIGR1ZSB0byBpbnN1ZmZpY2llbnQgZGVwb3NpdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLnNldF92YWxpZGF0b3JfYWRfZXh0cmEodmFsX2NvbmZpZ19leHRyYTogYnl0ZXMpIC0+IHZvaWQ6CnNldF92YWxpZGF0b3JfYWRfZXh0cmE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQyLTI0MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBzZXRfdmFsaWRhdG9yX2FkX2V4dHJhKHNlbGYsIHZhbF9jb25maWdfZXh0cmE6IFZhbENvbmZpZ0V4dHJhKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQ1CiAgICAvLyBzZWxmLmRlcG9zaXRfc3VmZmljaWVudCgpCiAgICBjYWxsc3ViIGRlcG9zaXRfc3VmZmljaWVudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0NwogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNDgKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUwCiAgICAvLyBhc3NlcnQgZGVsX2FwcF9pZCA9PSBVSW50NjQoMCksICJVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4iCiAgICAhCiAgICBhc3NlcnQgLy8gVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUxCiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCksICJVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLiIKICAgIGR1cAogICAgYXNzZXJ0IC8vIFVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUzLTI1OAogICAgLy8gdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuc2V0X2V4dHJhLAogICAgLy8gICAgIHZhbF9jb25maWdfZXh0cmEuY29weSgpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInNldF9leHRyYSgoYnl0ZVszMF0sYnl0ZVs3MF0pKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNTcKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUzLTI1OAogICAgLy8gdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuc2V0X2V4dHJhLAogICAgLy8gICAgIHZhbF9jb25maWdfZXh0cmEuY29weSgpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNTkKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmVuZF92YWxpZGF0b3JfYWQoKSAtPiB2b2lkOgplbmRfdmFsaWRhdG9yX2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI2MS0yNjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZW5kX3ZhbGlkYXRvcl9hZCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjY3CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI2OAogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzAKICAgIC8vIGFzc2VydCBkZWxfYXBwX2lkID09IFVJbnQ2NCgwKSwgIlVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLiIKICAgICEKICAgIGFzc2VydCAvLyBVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzEKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSwgIlVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuIgogICAgZHVwCiAgICBhc3NlcnQgLy8gVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzMtMjc4CiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5lbmRfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIG9uX2NvbXBsZXRpb249T25Db21wbGV0ZUFjdGlvbi5EZWxldGVBcHBsaWNhdGlvbiwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzYKICAgIC8vIG9uX2NvbXBsZXRpb249T25Db21wbGV0ZUFjdGlvbi5EZWxldGVBcHBsaWNhdGlvbiwKICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIGR1cAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjczLTI3OAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX3ZhbGlkYXRvcl9hZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBvbl9jb21wbGV0aW9uPU9uQ29tcGxldGVBY3Rpb24uRGVsZXRlQXBwbGljYXRpb24sCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImVuZF92YWxpZGF0b3JfYWQoKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI3NwogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzMtMjc4CiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5lbmRfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIG9uX2NvbXBsZXRpb249T25Db21wbGV0ZUFjdGlvbi5EZWxldGVBcHBsaWNhdGlvbiwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzkKICAgIC8vIHZhbF9lYXJuaW5ncyA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODEtMjgyCiAgICAvLyAjIEluY3JlYXNlIHVzZXIncywgaS5lLiB2YWxpZGF0b3JzLCBlYXJuaW5ncwogICAgLy8gc2VsZi5iYWxhbmNlW1R4bi5zZW5kZXJdICs9IHZhbF9lYXJuaW5ncwogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImJhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgICsKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODQtMjg1CiAgICAvLyAjIFJlbW92ZSBHZW5lcmFsVmFsaWRhdG9yQWQgZnJvbSBsaXN0IG9mIHZhbGlkYXRvcnMKICAgIC8vIGFzc2VydCB2YWxfbGlzdF9yZW1vdmUodmFsX2FwcF9pZCksICJWYWxpZGF0b3IgbGlzdCBkb2Vzbid0IGluY2x1ZGUgdGhlIGFkLiIKICAgIGNhbGxzdWIgdmFsX2xpc3RfcmVtb3ZlCiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGxpc3QgZG9lc24ndCBpbmNsdWRlIHRoZSBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODctMjg4CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKFR4bi5zZW5kZXIpLCAiQ291bGRuJ3QgZnJlZSB2YWxpZGF0b3IuIgogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBmcmVlX3VzZXIKICAgIGFzc2VydCAvLyBDb3VsZG4ndCBmcmVlIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyOTAKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0LnZhbF9saXN0X3JlbW92ZSh2YWxfYXBwX2lkOiB1aW50NjQpIC0+IHVpbnQ2NDoKdmFsX2xpc3RfcmVtb3ZlOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0Ny03NDgKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgdmFsX2xpc3RfcmVtb3ZlKHZhbF9hcHBfaWQ6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgaW50IDAKICAgIGJ5dGUgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc2Mi03NjMKICAgIC8vICMgR2V0IGJveCB3aXRoIHZhbGlkYXRvciBsaXN0CiAgICAvLyB2YWxfbGlzdF9ib3gsIGJveF9nZXQgPSBvcC5Cb3guZ2V0KEJ5dGVzKFZBTF9MSVNUKSkKICAgIGJ5dGUgInZhbF9saXN0IgogICAgYm94X2dldAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc2NAogICAgLy8gYXNzZXJ0IGJveF9nZXQsICJHb3QgYm94IgogICAgYXNzZXJ0IC8vIEdvdCBib3gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjctNzY4CiAgICAvLyAjIFJlbW92ZSB0aGUgZWxlbWVudAogICAgLy8gdmFsX3JlbW92ZSA9IEZhbHNlCiAgICBpbnQgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc2OQogICAgLy8gZm9yIHZhbF9pZHggaW4gdXJhbmdlKE1BWF9WQUxfQ05UKToKICAgIGR1cAoKdmFsX2xpc3RfcmVtb3ZlX2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjkKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEwMAogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9idXJ5IDMKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9idXJ5IDAKICAgIGJ6IHZhbF9saXN0X3JlbW92ZV9hZnRlcl9mb3JANwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3MAogICAgLy8gaWYgdmFsX2xpc3RbdmFsX2lkeF0gPT0gYXJjNC5VSW50NjQodmFsX2FwcF9pZCk6CiAgICBmcmFtZV9kaWcgMQogICAgYXNzZXJ0IC8vIEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgNgogICAgaW50IDgKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICBmcmFtZV9kaWcgNAogICAgc3dhcAogICAgaW50IDgKICAgIGV4dHJhY3QzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGI9PQogICAgYnogdmFsX2xpc3RfcmVtb3ZlX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3MQogICAgLy8gdmFsX2xpc3RbdmFsX2lkeF0gPSBhcmM0LlVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2RpZyAyCiAgICBieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgcmVwbGFjZTMKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3MgogICAgLy8gdmFsX3JlbW92ZSA9IFRydWUKICAgIGludCAxCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NzMKICAgIC8vIGJyZWFrCiAgICBiIHZhbF9saXN0X3JlbW92ZV9hZnRlcl9mb3JANwoKdmFsX2xpc3RfcmVtb3ZlX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjkKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEKICAgICsKICAgIGZyYW1lX2J1cnkgNgogICAgYiB2YWxfbGlzdF9yZW1vdmVfZm9yX2hlYWRlckAxCgp2YWxfbGlzdF9yZW1vdmVfYWZ0ZXJfZm9yQDc6CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3NQogICAgLy8gb3AuQm94LnB1dChCeXRlcyhWQUxfTElTVCksIHZhbF9saXN0LmJ5dGVzKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBmcmFtZV9kaWcgMAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3NwogICAgLy8gcmV0dXJuIHZhbF9yZW1vdmUKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmZyZWVfdXNlcih1c2VyX2FjYzogYnl0ZXMpIC0+IHVpbnQ2NDoKZnJlZV91c2VyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY5OS03MDAKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZnJlZV91c2VyKHNlbGYsIHVzZXJfYWNjOiBBY2NvdW50KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzAxCiAgICAvLyBzZWxmLnZhbF9hcHBfaWRbdXNlcl9hY2NdID0gVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcwMgogICAgLy8gc2VsZi5kZWxfYXBwX2lkW3VzZXJfYWNjXSA9IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDMKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLnZhbF93aXRoZHJhd19lYXJuaW5ncygpIC0+IGJ5dGVzOgp2YWxfd2l0aGRyYXdfZWFybmluZ3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjkyLTI5NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB2YWxfd2l0aGRyYXdfZWFybmluZ3MoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAwIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyOTYKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjk3CiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI5OQogICAgLy8gYXNzZXJ0IGRlbF9hcHBfaWQgPT0gVUludDY0KDApLCAiVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuIgogICAgIQogICAgYXNzZXJ0IC8vIFVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMwMAogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApLCAiVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4iCiAgICBkdXAKICAgIGFzc2VydCAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMwMi0zMDYKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLndpdGhkcmF3X2Vhcm5pbmdzLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgIndpdGhkcmF3X2Vhcm5pbmdzKCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDUKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzAyLTMwNgogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQud2l0aGRyYXdfZWFybmluZ3MsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzA3CiAgICAvLyBlYXJuaW5ncyA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDktMzExCiAgICAvLyAjIFJlbGVhc2UgYmxvY2tlZCBiYWxhbmNlIGluIE5vdGljZWJvYXJkIGZvciBkaWZmZXJlbmNlIGJldHdlZW4gY2hhcmdlZCBmZWVfc2V0dXAgYW5kIGVhcm5pbmdzIG9mIHZhbGlkYXRvciwKICAgIC8vICMgaS5lLiBlYXJuaW5ncyBvZiB0aGUgcGxhdGZvcm0KICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgLT0gZWFybmluZ3MKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBkaWcgMQogICAgLQogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMxMwogICAgLy8gcGF5X3RvX3NlbmRlcihlYXJuaW5ncykKICAgIGR1cAogICAgY2FsbHN1YiBwYXlfdG9fc2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzE1CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoZWFybmluZ3MpCiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24ucGF5X3RvX3NlbmRlcihhbW91bnQ6IHVpbnQ2NCkgLT4gdm9pZDoKcGF5X3RvX3NlbmRlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxMzQtMTM2CiAgICAvLyAjIC0tLS0tLS0gRnVuY3Rpb25zIC0tLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcGF5X3RvX3NlbmRlcihhbW91bnQ6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjEzNy0xNDEKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9YW1vdW50LAogICAgLy8gICAgIHJlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTM5CiAgICAvLyByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjEzNwogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0MAogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxMzctMTQxCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC53aXRoZHJhd19iYWxhbmNlKCkgLT4gYnl0ZXM6CndpdGhkcmF3X2JhbGFuY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzE3LTMyMwogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gICAgICAgICAgIEZvciBhbGwgdXNlcnMgICAgICAgICAgIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB3aXRoZHJhd19iYWxhbmNlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzI1CiAgICAvLyBiYWxhbmNlID0gc2VsZi5iYWxhbmNlW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiYmFsYW5jZSIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBiYWxhbmNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMyNy0zMjgKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgLT0gYmFsYW5jZQogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIGRpZyAxCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzMwCiAgICAvLyBwYXlfdG9fc2VuZGVyKGJhbGFuY2UpCiAgICBkdXAKICAgIGNhbGxzdWIgcGF5X3RvX3NlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMzMi0zMzMKICAgIC8vICMgU2V0IG5ldyBiYWxhbmNlIHRvIHplcm8KICAgIC8vIHNlbGYuYmFsYW5jZVtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiYmFsYW5jZSIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzM1CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoYmFsYW5jZSkKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC53aXRoZHJhd19kZXBvaXN0KCkgLT4gYnl0ZXM6CndpdGhkcmF3X2RlcG9pc3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzM3LTM0MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB3aXRoZHJhd19kZXBvaXN0KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzQxCiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0MgogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNDQtMzQ2CiAgICAvLyBhc3NlcnQgZGVsX2FwcF9pZCA9PSBVSW50NjQoMCkgYW5kIHZhbF9hcHBfaWQgPT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJXaXRoZHJhd2FsIG9mIGRlcG9zaXQgaXMgb25seSBwb3NzaWJsZSBpZiB1c2VyIGlzIG5laXRoZXIgYSB2YWxpZGF0b3Igbm9yIGEgZGVsZWdhdG9yLiIKICAgIGJueiB3aXRoZHJhd19kZXBvaXN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDAKICAgIGJueiB3aXRoZHJhd19kZXBvaXN0X2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIgd2l0aGRyYXdfZGVwb2lzdF9ib29sX21lcmdlQDQKCndpdGhkcmF3X2RlcG9pc3RfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCndpdGhkcmF3X2RlcG9pc3RfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0NC0zNDYKICAgIC8vIGFzc2VydCBkZWxfYXBwX2lkID09IFVJbnQ2NCgwKSBhbmQgdmFsX2FwcF9pZCA9PSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIldpdGhkcmF3YWwgb2YgZGVwb3NpdCBpcyBvbmx5IHBvc3NpYmxlIGlmIHVzZXIgaXMgbmVpdGhlciBhIHZhbGlkYXRvciBub3IgYSBkZWxlZ2F0b3IuIgogICAgYXNzZXJ0IC8vIFdpdGhkcmF3YWwgb2YgZGVwb3NpdCBpcyBvbmx5IHBvc3NpYmxlIGlmIHVzZXIgaXMgbmVpdGhlciBhIHZhbGlkYXRvciBub3IgYSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzQ4CiAgICAvLyBkZXBvc2l0ID0gc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfYW10IGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM1MC0zNTEKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIHRoZSBkZXBvc2l0CiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IGRlcG9zaXQKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBkaWcgMQogICAgLQogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM1MwogICAgLy8gcGF5X3RvX3NlbmRlcihkZXBvc2l0KQogICAgZHVwCiAgICBjYWxsc3ViIHBheV90b19zZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNTUtMzU2CiAgICAvLyAjIFNldCBuZXcgZGVwb3NpdCB0byB6ZXJvCiAgICAvLyBzZWxmLmRlcG9zaXRfYW10W1R4bi5zZW5kZXJdID0gVUludDY0KDApCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJkZXBvc2l0X2FtdCIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzU4CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoZGVwb3NpdCkKICAgIGl0b2IKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC51c2VyX29wdF9pbigpIC0+IHZvaWQ6CnVzZXJfb3B0X2luOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM2MC0zNjMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiT3B0SW4iXSkKICAgIC8vIGRlZiB1c2VyX29wdF9pbigKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzcwCiAgICAvLyBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM3MQogICAgLy8gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gVUludDY0KDApCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNzIKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNzMKICAgIC8vIHNlbGYuYmFsYW5jZVtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiYmFsYW5jZSIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzc1CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0KHZhbF9hcHBfaWQ6IGJ5dGVzLCBkZXBvc2l0X3BheW1lbnQ6IHVpbnQ2NCwgZmVlX3NldHVwX3BheW1lbnQ6IHVpbnQ2NCwgbWJyOiB1aW50NjQsIHJvdW5kX3N0YXJ0OiBieXRlcywgcm91bmRfZW5kOiBieXRlcykgLT4gdm9pZDoKY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozODEtMzkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfYXBwX2lkOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICBkZXBvc2l0X3BheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIGZlZV9zZXR1cF9wYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICAgICBtYnI6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByb3VuZF9lbmQ6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzkxCiAgICAvLyBhc3NlcnQgc2VsZi5saXZlLCAiTm90aWNlYm9hcmQgaXMgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBsaXZlLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM5NwogICAgLy8gYXNzZXJ0IHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXSA9PSAwLCAiQWNjb3VudCBkb2Vzbid0IHlldCBoYXZlIGEgcm9sZS4iCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgIQogICAgYXNzZXJ0IC8vIEFjY291bnQgZG9lc24ndCB5ZXQgaGF2ZSBhIHJvbGUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDAyCiAgICAvLyBtYnIucmVjZWl2ZXIgPT0gQXBwbGljYXRpb24odmFsX2FwcF9pZC5uYXRpdmUpLmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtNgogICAgYnRvaQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzk5LTQwMwogICAgLy8gIyBBc3NlcnQgaW5jcmVhc2UgaW4gbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IHdhcyBwYWlkIGZvciBWYWxkaWF0b3JBZCBkdWUgdG8KICAgIC8vICMgRGVsZWdhdG9yQ29udHJhY3QgY3JlYXRpb24KICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyLnJlY2VpdmVyID09IEFwcGxpY2F0aW9uKHZhbF9hcHBfaWQubmF0aXZlKS5hZGRyZXNzCiAgICAvLyApLCAiTUJSIHdhc24ndCBwYWlkIHRvIHRoZSB2YWxkaWF0b3IgYWQuIgogICAgYXNzZXJ0IC8vIE1CUiB3YXNuJ3QgcGFpZCB0byB0aGUgdmFsZGlhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQwNQogICAgLy8gbWJyLmFtb3VudCA9PSBNQlJfREVMRUdBVE9SQ09OVFJBQ1RfQ1JFQVRJT04KICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGludCA3ODUwMDAKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDA0LTQwNgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnIuYW1vdW50ID09IE1CUl9ERUxFR0FUT1JDT05UUkFDVF9DUkVBVElPTgogICAgLy8gKSwgIk1CUiBwYXkgaGFkIGluc3VmZmljaWVudCBhbW91bnQgZm9yIGNyZWF0aW9uIG9mIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIE1CUiBwYXkgaGFkIGluc3VmZmljaWVudCBhbW91bnQgZm9yIGNyZWF0aW9uIG9mIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDEwCiAgICAvLyBkZXBvc2l0X3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDA4LTQxMQogICAgLy8gIyBBc3NlcnQgbWluaW11bSBkZWxlZ2F0b3IgZGVwb3NpdCB3YXMgcGFpZCB0byB0aGUgbm90aWNlYm9hcmQgKGFtb3VudCBjaGVja2VkIGluIEdlbmVyYWxWYWxpZGF0b3JBZCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVwb3NpdF9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJEZXBvc2l0IHdhc24ndCBwYWlkIHRvIHRoZSBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gRGVwb3NpdCB3YXNuJ3QgcGFpZCB0byB0aGUgbm90aWNlYm9hcmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDE0CiAgICAvLyBmZWVfc2V0dXBfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MTItNDE1CiAgICAvLyAjIEFzc2VydCBjb3JyZWN0IGFtb3VudCBvZiBzZXR1cCBmZWUgd2FzIHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkIChhbW91bnQgY2hlY2tlZCBpbiBHZW5lcmFsVmFsaWRhdG9yQWQpCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGZlZV9zZXR1cF9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLiIKICAgIGFzc2VydCAvLyBTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQxNy00MjcKICAgIC8vICMgQ3JlYXRlIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QgZm9yIHRoZSBjaG9zZW4gdmFsaWRhdG9yCiAgICAvLyBjcmVhdGVkX2RlbF9hcHBfaWQsIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVwb3NpdF9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZmVlX3NldHVwX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBhcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgcm91bmRfc3RhcnQsCiAgICAvLyAgICAgcm91bmRfZW5kLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLm5hdGl2ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjAKICAgIC8vIGFyYzQuVUludDY0KGRlcG9zaXRfcGF5bWVudC5hbW91bnQpLAogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBBbW91bnQKICAgIGR1cAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQyMQogICAgLy8gYXJjNC5VSW50NjQoZmVlX3NldHVwX3BheW1lbnQuYW1vdW50KSwKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjIKICAgIC8vIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIHN3YXAKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MTctNDI3CiAgICAvLyAjIENyZWF0ZSBuZXcgZGVsZWdhdG9yIGNvbnRyYWN0IGZvciB0aGUgY2hvc2VuIHZhbGlkYXRvcgogICAgLy8gY3JlYXRlZF9kZWxfYXBwX2lkLCB0eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0LAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXRfcGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZC5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QodWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjYKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDE3LTQyNwogICAgLy8gIyBDcmVhdGUgbmV3IGRlbGVnYXRvciBjb250cmFjdCBmb3IgdGhlIGNob3NlbiB2YWxpZGF0b3IKICAgIC8vIGNyZWF0ZWRfZGVsX2FwcF9pZCwgdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0X3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQubmF0aXZlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQyOC00MjkKICAgIC8vICMgU3RvcmUgdGhlIGNyZWF0ZWQgZGVsZWdhdG9yIGNvbnRyYWN0IGFwcCBJRAogICAgLy8gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gY3JlYXRlZF9kZWxfYXBwX2lkLm5hdGl2ZQogICAgYnRvaQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIHVuY292ZXIgMgogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzMC00MzEKICAgIC8vICMgU3RvcmUgc2VsZWN0ZWQgdmFsaWRhdG9yIGNvbnRyYWN0IGFwcCBJRAogICAgLy8gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gdmFsX2FwcF9pZC5uYXRpdmUKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICB1bmNvdmVyIDUKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MzMtNDM0CiAgICAvLyAjIE1hcmsgZGVsZWdhdG9ycyBkZXBvc2l0IGFtb3VudAogICAgLy8gc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXSA9IGRlcG9zaXRfcGF5bWVudC5hbW91bnQKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgZGlnIDMKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MzYtNDM3CiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSAoCiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGJsb2NrZWRfYW10IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzOAogICAgLy8gZGVwb3NpdF9wYXltZW50LmFtb3VudCArIGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCArIG1ici5hbW91bnQKICAgIHVuY292ZXIgMgogICAgKwogICAgdW5jb3ZlciAyCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM2LTQzOQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgKz0gKAogICAgLy8gICAgIGRlcG9zaXRfcGF5bWVudC5hbW91bnQgKyBmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQgKyBtYnIuYW1vdW50CiAgICAvLyApCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM2LTQzNwogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgKz0gKAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM2LTQzOQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgKz0gKAogICAgLy8gICAgIGRlcG9zaXRfcGF5bWVudC5hbW91bnQgKyBmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQgKyBtYnIuYW1vdW50CiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ0MQogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuZGVwb3NpdF9rZXlzKGRlbF9hY2M6IGJ5dGVzLCBzZWxfa2V5OiBieXRlcywgdm90ZV9rZXk6IGJ5dGVzLCBzdGF0ZV9wcm9vZl9rZXk6IGJ5dGVzLCB2b3RlX2tleV9kaWx1dGlvbjogYnl0ZXMsIHJvdW5kX3N0YXJ0OiBieXRlcywgcm91bmRfZW5kOiBieXRlcykgLT4gdm9pZDoKZGVwb3NpdF9rZXlzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ0My00NTMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGVwb3NpdF9rZXlzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FjYzogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHNlbF9rZXk6IFNlbEtleSwKICAgIC8vICAgICB2b3RlX2tleTogVm90ZUtleSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXk6IFN0YXRlUHJvb2ZLZXksCiAgICAvLyAgICAgdm90ZV9rZXlfZGlsdXRpb246IGFyYzQuVUludDY0LAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByb3VuZF9lbmQ6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDU1CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC03CiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ1NgogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtNwogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTgtNDcwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5kZXBvc2l0X2tleXMsCiAgICAvLyAgICAgVHhuLnNlbmRlciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDYxCiAgICAvLyBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NjAKICAgIC8vIFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBBY2NvdW50cwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ1OC00NzAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmRlcG9zaXRfa2V5cywKICAgIC8vICAgICBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIHNlbF9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5LmNvcHkoKSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5X2RpbHV0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIG1ldGhvZCAiZGVwb3NpdF9rZXlzKGFjY291bnQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDYwCiAgICAvLyBUeG4uc2VuZGVyLAogICAgYnl0ZSAweDAxCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTgtNDcwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5kZXBvc2l0X2tleXMsCiAgICAvLyAgICAgVHhuLnNlbmRlciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ2OQogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTgtNDcwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5kZXBvc2l0X2tleXMsCiAgICAvLyAgICAgVHhuLnNlbmRlciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDcxCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0Lm5hdGl2ZQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ3My00NzQKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmcgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc2CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5jb25maXJtX2tleXMoa2V5cmVnX3R4bl9pbmRleDogYnl0ZXMsIGZlZV9vcGVyYXRpb25fcGF5bWVudDogdWludDY0KSAtPiB2b2lkOgpjb25maXJtX2tleXM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc4LTQ4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb25maXJtX2tleXMoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBrZXlyZWdfdHhuX2luZGV4OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICBmZWVfb3BlcmF0aW9uX3BheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg1CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0ODYKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg4LTQ5MAogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGJ6IGNvbmZpcm1fa2V5c19ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAxCiAgICBieiBjb25maXJtX2tleXNfYm9vbF9mYWxzZUAzCiAgICBpbnQgMQogICAgYiBjb25maXJtX2tleXNfYm9vbF9tZXJnZUA0Cgpjb25maXJtX2tleXNfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCmNvbmZpcm1fa2V5c19ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg4LTQ5MAogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBTZW5kZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDkzCiAgICAvLyBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAzCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBpbnQgMwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTItNDk0CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIEdsb2JhbC5ncm91cF9zaXplID09IDMKICAgIC8vICksICJDaGVjayBndHhuIHNpemUgaXMgZXhhY3RseSB0aHJlZSAtIGZlZSBwYXltZW50LCBhcHAgY2FsbCwgYW5kIGtleSByZWcuIgogICAgYXNzZXJ0IC8vIENoZWNrIGd0eG4gc2l6ZSBpcyBleGFjdGx5IHRocmVlIC0gZmVlIHBheW1lbnQsIGFwcCBjYWxsLCBhbmQga2V5IHJlZy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTgKICAgIC8vIGZlZV9vcGVyYXRpb25fcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTYtNDk5CiAgICAvLyAjIEFzc2VydCBjb3JyZWN0IGFtb3VudCBvZiBvcGVyYXRpb25hbCBmZWUgd2FzIHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkIChhbW91bnQgY2hlY2tlZCBpbiBEZWxlZ2F0b3JDb250cmFjdCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZmVlX29wZXJhdGlvbl9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLiIKICAgIGFzc2VydCAvLyBTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUwMgogICAgLy8gb3AuR1R4bi50eXBlX2VudW0oa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGJ0b2kKICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDMKICAgIC8vID09IFRyYW5zYWN0aW9uVHlwZS5LZXlSZWdpc3RyYXRpb24KICAgIGludCBrZXlyZWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDItNTAzCiAgICAvLyBvcC5HVHhuLnR5cGVfZW51bShrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vID09IFRyYW5zYWN0aW9uVHlwZS5LZXlSZWdpc3RyYXRpb24KICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTAxLTUwNAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBvcC5HVHhuLnR5cGVfZW51bShrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vICAgICA9PSBUcmFuc2FjdGlvblR5cGUuS2V5UmVnaXN0cmF0aW9uCiAgICAvLyApLCAiS2V5IHJlZyB0cmFuc2FjdGlvbi4iCiAgICBhc3NlcnQgLy8gS2V5IHJlZyB0cmFuc2FjdGlvbi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDcKICAgIC8vIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICBkdXAKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDYtNTA4CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICAvLyApLCAiS2V5IHJlZyBpcyBmcm9tIHRoZSBzYW1lIGFjY291bnQgYXMgdGhlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gS2V5IHJlZyBpcyBmcm9tIHRoZSBzYW1lIGFjY291bnQgYXMgdGhlIGRlbGVnYXRvciBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTAKICAgIC8vIHNlbF9rZXkgPSBTZWxLZXkuZnJvbV9ieXRlcyhvcC5HVHhuLnNlbGVjdGlvbl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkpCiAgICBkdXAKICAgIGd0eG5zIFNlbGVjdGlvblBLCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTExCiAgICAvLyB2b3RlX2tleSA9IFZvdGVLZXkuZnJvbV9ieXRlcyhvcC5HVHhuLnZvdGVfcGsoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpKQogICAgZHVwCiAgICBndHhucyBWb3RlUEsKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTItNTE0CiAgICAvLyBzdGF0ZV9wcm9vZl9rZXkgPSBTdGF0ZVByb29mS2V5LmZyb21fYnl0ZXMoCiAgICAvLyAgICAgb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxMwogICAgLy8gb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIGd0eG5zIFN0YXRlUHJvb2ZQSwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxMi01MTQKICAgIC8vIHN0YXRlX3Byb29mX2tleSA9IFN0YXRlUHJvb2ZLZXkuZnJvbV9ieXRlcygKICAgIC8vICAgICBvcC5HVHhuLnN0YXRlX3Byb29mX3BrKGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxNgogICAgLy8gdm90ZV9rZXlfZGlsdXRpb24gPSBvcC5HVHhuLnZvdGVfa2V5X2RpbHV0aW9uKGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZHVwCiAgICBndHhucyBWb3RlS2V5RGlsdXRpb24KICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTcKICAgIC8vIHJvdW5kX3N0YXJ0ID0gb3AuR1R4bi52b3RlX2ZpcnN0KGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZHVwCiAgICBndHhucyBWb3RlRmlyc3QKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTgKICAgIC8vIHJvdW5kX2VuZCA9IG9wLkdUeG4udm90ZV9sYXN0KGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZ3R4bnMgVm90ZUxhc3QKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjAtNTMyCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5jb25maXJtX2tleXMsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZmVlX29wZXJhdGlvbl9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgc2VsX2tleS5jb3B5KCksCiAgICAvLyAgICAgdm90ZV9rZXkuY29weSgpLAogICAgLy8gICAgIHN0YXRlX3Byb29mX2tleS5jb3B5KCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQodm90ZV9rZXlfZGlsdXRpb24pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX3N0YXJ0KSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChyb3VuZF9lbmQpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMgogICAgLy8gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICBmcmFtZV9kaWcgMQogICAgaXRvYgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMwogICAgLy8gYXJjNC5VSW50NjQoZmVlX29wZXJhdGlvbl9wYXltZW50LmFtb3VudCksCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTI3CiAgICAvLyBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjgKICAgIC8vIGFyYzQuVUludDY0KHJvdW5kX3N0YXJ0KSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyOQogICAgLy8gYXJjNC5VSW50NjQocm91bmRfZW5kKSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgc3dhcAogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMC01MzIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNvbmZpcm1fa2V5cywKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfb3BlcmF0aW9uX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICAvLyAgICAgYXJjNC5VSW50NjQocm91bmRfc3RhcnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX2VuZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImNvbmZpcm1fa2V5cyh1aW50NjQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTMxCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMC01MzIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNvbmZpcm1fa2V5cywKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfb3BlcmF0aW9uX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICAvLyAgICAgYXJjNC5VSW50NjQocm91bmRfc3RhcnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX2VuZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTMzCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0Lm5hdGl2ZQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzNS01MzYKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmcgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTM4LTUzOQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UgZm9yIG9wZXJ0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ICs9IGZlZV9vcGVyYXRpb25fcGF5bWVudC5hbW91bnQKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICArCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTQxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5rZXlzX25vdF9nZW5lcmF0ZWQoZGVsX2FjYzogYnl0ZXMpIC0+IHZvaWQ6CmtleXNfbm90X2dlbmVyYXRlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NDMtNTQ3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGtleXNfbm90X2dlbmVyYXRlZCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hY2M6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU0OQogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTUwCiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1Mi01NTQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBieiBrZXlzX25vdF9nZW5lcmF0ZWRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMQogICAgYnoga2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIga2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfbWVyZ2VANAoKa2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgprZXlzX25vdF9nZW5lcmF0ZWRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1Mi01NTQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1Ni01NjEKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2dlbmVyYXRlZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTgKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgZnJhbWVfZGlnIDEKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTYtNTYxCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5rZXlzX25vdF9nZW5lcmF0ZWQsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImtleXNfbm90X2dlbmVyYXRlZCh1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU2MAogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTYtNTYxCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5rZXlzX25vdF9nZW5lcmF0ZWQsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTYyCiAgICAvLyBmZWVfc2V0dXAgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTY0LTU2NQogICAgLy8gIyBSZWZ1bmQgc2V0dXAgZmVlIHRvIGRlbGVnYXRvcidzIGJhbGFuY2UKICAgIC8vIHNlbGYuYmFsYW5jZVtkZWxfYWNjLm5hdGl2ZV0gKz0gZmVlX3NldHVwCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICArCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NjctNTY4CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKFR4bi5zZW5kZXIpLCAiQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuIgogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBmcmVlX3VzZXIKICAgIGFzc2VydCAvLyBDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzAKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmtleXNfbm90X2NvbmZpcm1lZChkZWxfYWNjOiBieXRlcykgLT4gdm9pZDoKa2V5c19ub3RfY29uZmlybWVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU3Mi01NzYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYga2V5c19ub3RfY29uZmlybWVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FjYzogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTc4CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzkKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbZGVsX2FjYy5uYXRpdmVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTgxLTU4MwogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiQWNjb3VudCBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBieiBrZXlzX25vdF9jb25maXJtZWRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMQogICAgYnoga2V5c19ub3RfY29uZmlybWVkX2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIga2V5c19ub3RfY29uZmlybWVkX2Jvb2xfbWVyZ2VANAoKa2V5c19ub3RfY29uZmlybWVkX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgprZXlzX25vdF9jb25maXJtZWRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4MS01ODMKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIkFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIEFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTg1LTU5MAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQua2V5c19ub3RfY29uZmlybWVkLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4NwogICAgLy8gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICBmcmFtZV9kaWcgMQogICAgaXRvYgogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4NS01OTAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIG1ldGhvZCAia2V5c19ub3RfY29uZmlybWVkKHVpbnQ2NCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTg5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4NS01OTAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1OTEKICAgIC8vIHBsYXRmb3JtX2Vhcm5pbmcgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTkzLTU5NAogICAgLy8gIyBSZWxlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZCBmb3IgZWFybmluZ3Mgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTk2LTU5NwogICAgLy8gIyBGcmVlIHVzZXIKICAgIC8vIGFzc2VydCBzZWxmLmZyZWVfdXNlcihkZWxfYWNjLm5hdGl2ZSksICJDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTk5CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FjYzogYnl0ZXMpIC0+IHZvaWQ6CmVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MDEtNjA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hY2M6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgYnl0ZSAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYwOAogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjA5CiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxMS02MTMKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIkFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDIKICAgIGJ6IGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX21lcmdlQDQKCmVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MTEtNjEzCiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCkgYW5kIGRlbF9hcHBfaWQgIT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJBY2NvdW50IGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBBY2NvdW50IGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxNS02MTgKICAgIC8vICMgUmVhZCBnbG9iYWwgc3RhdGUgb2YgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfZW5kX3JvdW5kLCBkZWxfZW5kX3JvdW5kX2V4aXN0ID0gb3AuQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgLy8gKQogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxNwogICAgLy8gZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgYnl0ZSAicm91bmRfZW5kIgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxNS02MTgKICAgIC8vICMgUmVhZCBnbG9iYWwgc3RhdGUgb2YgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfZW5kX3JvdW5kLCBkZWxfZW5kX3JvdW5kX2V4aXN0ID0gb3AuQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MTkKICAgIC8vIGFzc2VydCBkZWxfZW5kX3JvdW5kX2V4aXN0LCAiRGVsZWdhdG9yIGNvbnRyYWN0IGhhcyByb3VuZF9lbmQuIgogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBoYXMgcm91bmRfZW5kLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyMQogICAgLy8gZGVsX2FwcF9pZCwgQnl0ZXMoYiJjb250cmFjdF9icmVhY2hlZCIpCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MjAtNjIyCiAgICAvLyBkZWxfY29udHJhY3RfYnJlYWNoZWQsIGRlbF9jb250cmFjdF9icmVhY2hlZF9leGlzdCA9IG9wLkFwcEdsb2JhbC5nZXRfZXhfdWludDY0KAogICAgLy8gICAgIGRlbF9hcHBfaWQsIEJ5dGVzKGIiY29udHJhY3RfYnJlYWNoZWQiKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyMwogICAgLy8gYXNzZXJ0IGRlbF9jb250cmFjdF9icmVhY2hlZF9leGlzdCwgIkRlbGVnYXRvciBjb250cmFjdCBoYXMgY29udHJhY3RfYnJlYWNoZWQuIgogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBoYXMgY29udHJhY3RfYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjI2CiAgICAvLyBkZWxfZW5kX3JvdW5kIDwgR2xvYmFsLnJvdW5kIG9yIGRlbF9jb250cmFjdF9icmVhY2hlZAogICAgZ2xvYmFsIFJvdW5kCiAgICA8CiAgICBibnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfdHJ1ZUA2CiAgICBmcmFtZV9kaWcgMAogICAgYnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VANwoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfdHJ1ZUA2OgogICAgaW50IDEKICAgIGIgZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfbWVyZ2VAOAoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VANzoKICAgIGludCAwCgplbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyNS02MjcKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVsX2VuZF9yb3VuZCA8IEdsb2JhbC5yb3VuZCBvciBkZWxfY29udHJhY3RfYnJlYWNoZWQKICAgIC8vICksICJBbnlvbmUgY2FuIGVuZCBjb250cmFjdCBpZiBpdCBoYXMgZXhwaXJlZCBhbHJlYWR5IG9yIHdhcyBicmVhY2hlZC4iCiAgICBhc3NlcnQgLy8gQW55b25lIGNhbiBlbmQgY29udHJhY3QgaWYgaXQgaGFzIGV4cGlyZWQgYWxyZWFkeSBvciB3YXMgYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjI5CiAgICAvLyBzZWxmLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FwcF9pZCwgdmFsX2FwcF9pZCwgZGVsX2FjYy5uYXRpdmUpCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBlbmRfZGVsZWdhdG9yX2NvbnRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjMxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfZGVsZWdhdG9yX2NvbnRyYWN0KGRlbF9hcHBfaWQ6IHVpbnQ2NCwgdmFsX2FwcF9pZDogdWludDY0LCBhY2M6IGJ5dGVzKSAtPiB2b2lkOgplbmRfZGVsZWdhdG9yX2NvbnRyYWN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY2MS02NzAKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIEludGVybmFsIGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZW5kX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHBfaWQ6IFVJbnQ2NCwKICAgIC8vICAgICB2YWxfYXBwX2lkOiBVSW50NjQsCiAgICAvLyAgICAgYWNjOiBBY2NvdW50LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njc1LTY4MAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX2RlbGVnYXRvcl9jb250cmFjdCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NzcKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY3NS02ODAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImVuZF9kZWxlZ2F0b3JfY29udHJhY3QodWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njc5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY3NS02ODAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjgxCiAgICAvLyBkZXBvc2l0ID0gcmVzdWx0LmEKICAgIGR1cAogICAgZXh0cmFjdCAwIDgKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2ODIKICAgIC8vIHJlZnVuZCA9IHJlc3VsdC5iCiAgICBkdXAKICAgIGV4dHJhY3QgOCA4CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjgzCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0LmMKICAgIGV4dHJhY3QgMTYgOAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY4NS02ODYKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmdzIG9mIHRoZSBwbGF0Zm9ybQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCAtPSBwbGF0Zm9ybV9lYXJuaW5nLm5hdGl2ZQogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIHN3YXAKICAgIGJ0b2kKICAgIC0KICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2ODgtNjg5CiAgICAvLyAjIFJldHVybiByZWZ1bmQgdW51c2VkIG9wZXJhdGlvbmFsIGZlZSB0byBkZWxlZ2F0b3IncyBiYWxhbmNlCiAgICAvLyBzZWxmLmJhbGFuY2VbYWNjXSArPSByZWZ1bmQubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBzd2FwCiAgICBidG9pCiAgICArCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2OTEtNjkyCiAgICAvLyAjIFNldCBkZXBvc2l0IHRvIGRlbGVnYXRvcidzIGxvY2FsIHN0YXRlIC0gYmVjYXVzZSBpdCBjb3VsZCBoYXZlIGJlZW4gc2llemVkIGR1ZSB0byBicmVhY2hlcwogICAgLy8gc2VsZi5kZXBvc2l0X2FtdFthY2NdID0gZGVwb3NpdC5uYXRpdmUKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMQogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2OTQtNjk1CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKGFjYyksICJDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njk3CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdChrZXlyZWdfdHhuX2luZGV4OiBieXRlcykgLT4gdm9pZDoKZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjMzLTYzNwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGtleXJlZ190eG5faW5kZXg6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQwCiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NDEKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQzLTY0NQogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGJ6IGVuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDEKICAgIGJ6IGVuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIgZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA0CgplbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY0My02NDUKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY0OAogICAgLy8gR2xvYmFsLmdyb3VwX3NpemUgPT0gMgogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50IDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQ3LTY0OQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAyCiAgICAvLyApLCAiQ2hlY2sgZ3R4biBzaXplIGlzIGV4YWN0bHkgdHdvIC0gYXBwIGNhbGwsIGFuZCBrZXkgZGVyZWcuIgogICAgYXNzZXJ0IC8vIENoZWNrIGd0eG4gc2l6ZSBpcyBleGFjdGx5IHR3byAtIGFwcCBjYWxsLCBhbmQga2V5IGRlcmVnLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY1MgogICAgLy8gb3AuR1R4bi5zZW5kZXIoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpID09IFR4bi5zZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYnRvaQogICAgZHVwCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjUxLTY1MwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBvcC5HVHhuLnNlbmRlcihrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkgPT0gVHhuLnNlbmRlcgogICAgLy8gKSwgIktleSAoZGUpcmVnIGlzIGZyb20gdGhlIHNhbWUgYWNjb3VudCBhcyB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBLZXkgKGRlKXJlZyBpcyBmcm9tIHRoZSBzYW1lIGFjY291bnQgYXMgdGhlIGRlbGVnYXRvciBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NTUKICAgIC8vIGFzc2VydCBpc19rZXlfZGVyZWcoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpLCAiVHJhbnNhY3Rpb24gaXMgbm90IGtleSBkZXJlZy4iCiAgICBjYWxsc3ViIGlzX2tleV9kZXJlZwogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIG5vdCBrZXkgZGVyZWcuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjU3CiAgICAvLyBzZWxmLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FwcF9pZCwgdmFsX2FwcF9pZCwgVHhuLnNlbmRlcikKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgMAogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGVuZF9kZWxlZ2F0b3JfY29udHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NTkKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmhlbHBlcnMuY29tbW9uLmlzX2tleV9kZXJlZyh0eF9pZHg6IHVpbnQ2NCkgLT4gdWludDY0Ogppc19rZXlfZGVyZWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTUzLTE1NAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBpc19rZXlfZGVyZWcodHhfaWR4OiBVSW50NjQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTYKICAgIC8vIG9wLkdUeG4udHlwZV9lbnVtKHR4X2lkeCkgPT0gVHJhbnNhY3Rpb25UeXBlLktleVJlZ2lzdHJhdGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IGtleXJlZwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTUtMTU3CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG9wLkdUeG4udHlwZV9lbnVtKHR4X2lkeCkgPT0gVHJhbnNhY3Rpb25UeXBlLktleVJlZ2lzdHJhdGlvbgogICAgLy8gKSwgIktleSAoZGUpcmVnIHRyYW5zYWN0aW9uLiIKICAgIGFzc2VydCAvLyBLZXkgKGRlKXJlZyB0cmFuc2FjdGlvbi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTktMTYwCiAgICAvLyAjIENoZWNrIGlmIGtleSByZWcgaXMgZGVyZWdpc3RyYXRpb24KICAgIC8vIGFzc2VydCBvcC5HVHhuLnNlbGVjdGlvbl9wayh0eF9pZHgpID09IG9wLmJ6ZXJvKDMyKQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZWxlY3Rpb25QSwogICAgaW50IDMyCiAgICBiemVybwogICAgZHVwCiAgICBjb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTYxCiAgICAvLyBhc3NlcnQgb3AuR1R4bi52b3RlX3BrKHR4X2lkeCkgPT0gb3AuYnplcm8oMzIpCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFZvdGVQSwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2MgogICAgLy8gYXNzZXJ0IG9wLkdUeG4uc3RhdGVfcHJvb2ZfcGsodHhfaWR4KSA9PSBvcC5iemVybyg2NCkKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU3RhdGVQcm9vZlBLCiAgICBpbnQgNjQKICAgIGJ6ZXJvCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTYzCiAgICAvLyBhc3NlcnQgb3AuR1R4bi52b3RlX2tleV9kaWx1dGlvbih0eF9pZHgpID09IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBWb3RlS2V5RGlsdXRpb24KICAgICEKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2NAogICAgLy8gYXNzZXJ0IG9wLkdUeG4udm90ZV9maXJzdCh0eF9pZHgpID09IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBWb3RlRmlyc3QKICAgICEKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2NQogICAgLy8gYXNzZXJ0IG9wLkdUeG4udm90ZV9sYXN0KHR4X2lkeCkgPT0gVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFZvdGVMYXN0CiAgICAhCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNjcKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLl9faW5pdF9fKCkgLT4gdm9pZDoKX19pbml0X186CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6ODgKICAgIC8vIGRlZiBfX2luaXRfXyhzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6ODktOTAKICAgIC8vICMgRGVmaW5lIGdsb2JhbCBzdGF0ZQogICAgLy8gc2VsZi5kZXBvc2l0X3ZhbF9taW4gPSBVSW50NjQoMCkKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjkxCiAgICAvLyBzZWxmLmRlcG9zaXRfZGVsX21pbiA9IFVJbnQ2NCgwKQogICAgYnl0ZSAiZGVwb3NpdF9kZWxfbWluIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6OTIKICAgIC8vIHNlbGYudmFsX2Vhcm5fZmFjdG9yID0gVUludDY0KDApCiAgICBieXRlICJ2YWxfZWFybl9mYWN0b3IiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo5MwogICAgLy8gc2VsZi52YWxfZmFjdG9yeV9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGUgInZhbF9mYWN0b3J5X2FwcF9pZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojk0CiAgICAvLyBzZWxmLm1hbmFnZXIgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlICJtYW5hZ2VyIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojk2CiAgICAvLyBzZWxmLmxpdmUgPSBGYWxzZQogICAgYnl0ZSAibGl2ZSIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ID0gVUludDY0KDApCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuY2xlYXJfc3RhdGVfcHJvZ3JhbToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICBpbnQgMQogICAgcmV0dXJuCg=="
    },
    "state": {
        "global": {
            "num_byte_slices": 1,
            "num_uints": 6
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 4
        }
    },
    "schema": {
        "global": {
            "declared": {
                "blocked_amt": {
                    "type": "uint64",
                    "key": "blocked_amt"
                },
                "deposit_del_min": {
                    "type": "uint64",
                    "key": "deposit_del_min"
                },
                "deposit_val_min": {
                    "type": "uint64",
                    "key": "deposit_val_min"
                },
                "live": {
                    "type": "uint64",
                    "key": "live"
                },
                "manager": {
                    "type": "bytes",
                    "key": "manager"
                },
                "val_earn_factor": {
                    "type": "uint64",
                    "key": "val_earn_factor"
                },
                "val_factory_app_id": {
                    "type": "uint64",
                    "key": "val_factory_app_id"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {
                "balance": {
                    "type": "uint64",
                    "key": "balance"
                },
                "del_app_id": {
                    "type": "uint64",
                    "key": "del_app_id"
                },
                "deposit_amt": {
                    "type": "uint64",
                    "key": "deposit_amt"
                },
                "val_app_id": {
                    "type": "uint64",
                    "key": "val_app_id"
                }
            },
            "reserved": {}
        }
    },
    "contract": {
        "name": "Noticeboard",
        "methods": [
            {
                "name": "setup",
                "args": [
                    {
                        "type": "uint64",
                        "name": "deposit_val_min"
                    },
                    {
                        "type": "uint64",
                        "name": "deposit_del_min"
                    },
                    {
                        "type": "uint64",
                        "name": "val_earn_factor"
                    },
                    {
                        "type": "uint64",
                        "name": "val_factory_app_id"
                    },
                    {
                        "type": "address",
                        "name": "manager"
                    },
                    {
                        "type": "pay",
                        "name": "mbr"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "create_validator_ad",
                "args": [
                    {
                        "type": "pay",
                        "name": "deposit"
                    },
                    {
                        "type": "pay",
                        "name": "mbr_factory"
                    },
                    {
                        "type": "pay",
                        "name": "mbr_val"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "set_validator_ad_mandatory",
                "args": [
                    {
                        "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
                        "name": "val_config_man"
                    },
                    {
                        "type": "bool",
                        "name": "live"
                    },
                    {
                        "type": "address",
                        "name": "manager"
                    },
                    {
                        "type": "uint64",
                        "name": "max_del_cnt"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Creates or updates mandatory part of validator ad and sets liveliness status"
            },
            {
                "name": "set_validator_ad_extra",
                "args": [
                    {
                        "type": "(byte[30],byte[70])",
                        "name": "val_config_extra"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Creates or updates extra part of validator ad"
            },
            {
                "name": "end_validator_ad",
                "args": [],
                "returns": {
                    "type": "void"
                },
                "desc": "Sender can delete the validator ad."
            },
            {
                "name": "val_withdraw_earnings",
                "args": [],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "withdraw_balance",
                "args": [],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "withdraw_depoist",
                "args": [],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "user_opt_in",
                "args": [],
                "returns": {
                    "type": "void"
                },
                "desc": "assert not Txn.sender.is_opted_in(\nGlobal.current_application_id ), \"Account has already opted-in the app.\""
            },
            {
                "name": "create_delegator_contract",
                "args": [
                    {
                        "type": "uint64",
                        "name": "val_app_id"
                    },
                    {
                        "type": "pay",
                        "name": "deposit_payment"
                    },
                    {
                        "type": "pay",
                        "name": "fee_setup_payment"
                    },
                    {
                        "type": "pay",
                        "name": "mbr"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "deposit_keys",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    },
                    {
                        "type": "byte[32]",
                        "name": "sel_key"
                    },
                    {
                        "type": "byte[32]",
                        "name": "vote_key"
                    },
                    {
                        "type": "byte[64]",
                        "name": "state_proof_key"
                    },
                    {
                        "type": "uint64",
                        "name": "vote_key_dilution"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "confirm_keys",
                "args": [
                    {
                        "type": "uint64",
                        "name": "keyreg_txn_index"
                    },
                    {
                        "type": "pay",
                        "name": "fee_operation_payment"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "keys_not_generated",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "keys_not_confirmed",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "end_expired_or_breached_delegator_contract",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Anyone can delete the delegator contract after its expiry or when it was breached."
            },
            {
                "name": "end_active_delegator_contract",
                "args": [
                    {
                        "type": "uint64",
                        "name": "keyreg_txn_index"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Delegator can withdraw from contract and get refunded remaining operational fee."
            }
        ],
        "networks": {},
        "desc": "\n    Platform for peer-to-peer consensus delegation.\n    Node runners, i.e. validators can post ads to offer their services to users.\n    Users, i.e. delegators, can open requests for the service and conclude a contract with a node runner.\n\n    Global state\n    ------------\n        Configuration parameters\n        ------------------------\n        deposit_val_min : UInt64\n            Minimum deposit required to be made by validator to the Noticeboard\n        deposit_del_min : UInt64\n            Minimum deposit required to be made by delegator to the Noticeboard\n        val_earn_factor : UInt64\n            Value scaled to (1-0), representing 1 - percentage of fees taken by the platform\n\n        Variables\n        ---------\n        live : bool\n            Whether the contract is live (true) or has ended (false)\n        blocked_amt : UInt64\n            Balance on the Noticeboard account that can't be withdrawn.\n            It is part either of active deposits or not finalized payments.\n\n    Local state\n    -----------\n        val_app_id : UInt64\n            GeneralValidatorAd ID of the asccount - either as owner of validator or selected validator for UserContract\n        del_app_id : UInt64\n            UserContract ID of the account if the account is user; equals 0 for validator accounts.\n        deposit_amt : UInt64\n            Amount the account has deposited in the Noticeboard\n\n    Boxes\n    -----\n        val_list : Box\n            {key = val_id, value = [val_app_id: UInt64, prev_val_id: UInt64, next_val_id: UInt64] }\n\n    Methods\n    -------\n\n    "
    },
    "bare_call_config": {
        "no_op": "CREATE"
    }
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data)
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class SetupArgs(_ArgsBase[None]):
    deposit_val_min: int
    deposit_del_min: int
    val_earn_factor: int
    val_factory_app_id: int
    manager: str
    mbr: TransactionWithSigner

    @staticmethod
    def method() -> str:
        return "setup(uint64,uint64,uint64,uint64,address,pay)void"


@dataclasses.dataclass(kw_only=True)
class CreateValidatorAdArgs(_ArgsBase[None]):
    deposit: TransactionWithSigner
    mbr_factory: TransactionWithSigner
    mbr_val: TransactionWithSigner

    @staticmethod
    def method() -> str:
        return "create_validator_ad(pay,pay,pay)void"


@dataclasses.dataclass(kw_only=True)
class ValConfigMan:
    hw_cat: int
    min_amt: int
    max_amt: int
    fee_setup: int
    fee_round: int
    deposit: int
    setup_rounds: int
    confirmation_rounds: int
    max_breach: int
    breach_rounds: int
    uptime_gar: int


@dataclasses.dataclass(kw_only=True)
class SetValidatorAdMandatoryArgs(_ArgsBase[None]):
    """Creates or updates mandatory part of validator ad and sets liveliness status"""

    val_config_man: ValConfigMan
    live: bool
    manager: str
    max_del_cnt: int

    @staticmethod
    def method() -> str:
        return "set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void"


@dataclasses.dataclass(kw_only=True)
class ValConfigExtra:
    name: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    link: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class SetValidatorAdExtraArgs(_ArgsBase[None]):
    """Creates or updates extra part of validator ad"""

    val_config_extra: ValConfigExtra

    @staticmethod
    def method() -> str:
        return "set_validator_ad_extra((byte[30],byte[70]))void"


@dataclasses.dataclass(kw_only=True)
class EndValidatorAdArgs(_ArgsBase[None]):
    """Sender can delete the validator ad."""

    @staticmethod
    def method() -> str:
        return "end_validator_ad()void"


@dataclasses.dataclass(kw_only=True)
class ValWithdrawEarningsArgs(_ArgsBase[int]):
    @staticmethod
    def method() -> str:
        return "val_withdraw_earnings()uint64"


@dataclasses.dataclass(kw_only=True)
class WithdrawBalanceArgs(_ArgsBase[int]):
    @staticmethod
    def method() -> str:
        return "withdraw_balance()uint64"


@dataclasses.dataclass(kw_only=True)
class WithdrawDepoistArgs(_ArgsBase[int]):
    @staticmethod
    def method() -> str:
        return "withdraw_depoist()uint64"


@dataclasses.dataclass(kw_only=True)
class CreateDelegatorContractArgs(_ArgsBase[None]):
    val_app_id: int
    deposit_payment: TransactionWithSigner
    fee_setup_payment: TransactionWithSigner
    mbr: TransactionWithSigner
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class DepositKeysArgs(_ArgsBase[None]):
    del_acc: str
    sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key_dilution: int
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class ConfirmKeysArgs(_ArgsBase[None]):
    keyreg_txn_index: int
    fee_operation_payment: TransactionWithSigner

    @staticmethod
    def method() -> str:
        return "confirm_keys(uint64,pay)void"


@dataclasses.dataclass(kw_only=True)
class KeysNotGeneratedArgs(_ArgsBase[None]):
    del_acc: str

    @staticmethod
    def method() -> str:
        return "keys_not_generated(address)void"


@dataclasses.dataclass(kw_only=True)
class KeysNotConfirmedArgs(_ArgsBase[None]):
    del_acc: str

    @staticmethod
    def method() -> str:
        return "keys_not_confirmed(address)void"


@dataclasses.dataclass(kw_only=True)
class EndExpiredOrBreachedDelegatorContractArgs(_ArgsBase[None]):
    """Anyone can delete the delegator contract after its expiry or when it was breached."""

    del_acc: str

    @staticmethod
    def method() -> str:
        return "end_expired_or_breached_delegator_contract(address)void"


@dataclasses.dataclass(kw_only=True)
class EndActiveDelegatorContractArgs(_ArgsBase[None]):
    """Delegator can withdraw from contract and get refunded remaining operational fee."""

    keyreg_txn_index: int

    @staticmethod
    def method() -> str:
        return "end_active_delegator_contract(uint64)void"


@dataclasses.dataclass(kw_only=True)
class UserOptInArgs(_ArgsBase[None]):
    """assert not Txn.sender.is_opted_in(
    Global.current_application_id ), "Account has already opted-in the app." """

    @staticmethod
    def method() -> str:
        return "user_opt_in()void"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.blocked_amt = typing.cast(int, data.get(b"blocked_amt"))
        self.deposit_del_min = typing.cast(int, data.get(b"deposit_del_min"))
        self.deposit_val_min = typing.cast(int, data.get(b"deposit_val_min"))
        self.live = typing.cast(int, data.get(b"live"))
        self.manager = ByteReader(typing.cast(bytes, data.get(b"manager")))
        self.val_earn_factor = typing.cast(int, data.get(b"val_earn_factor"))
        self.val_factory_app_id = typing.cast(int, data.get(b"val_factory_app_id"))


class LocalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.balance = typing.cast(int, data.get(b"balance"))
        self.del_app_id = typing.cast(int, data.get(b"del_app_id"))
        self.deposit_amt = typing.cast(int, data.get(b"deposit_amt"))
        self.val_app_id = typing.cast(int, data.get(b"val_app_id"))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def setup(
        self,
        *,
        deposit_val_min: int,
        deposit_del_min: int,
        val_earn_factor: int,
        val_factory_app_id: int,
        manager: str,
        mbr: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `setup(uint64,uint64,uint64,uint64,address,pay)void` ABI method
        
        :param int deposit_val_min: The `deposit_val_min` ABI parameter
        :param int deposit_del_min: The `deposit_del_min` ABI parameter
        :param int val_earn_factor: The `val_earn_factor` ABI parameter
        :param int val_factory_app_id: The `val_factory_app_id` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetupArgs(
            deposit_val_min=deposit_val_min,
            deposit_del_min=deposit_del_min,
            val_earn_factor=val_earn_factor,
            val_factory_app_id=val_factory_app_id,
            manager=manager,
            mbr=mbr,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_validator_ad(
        self,
        *,
        deposit: TransactionWithSigner,
        mbr_factory: TransactionWithSigner,
        mbr_val: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `create_validator_ad(pay,pay,pay)void` ABI method
        
        :param TransactionWithSigner deposit: The `deposit` ABI parameter
        :param TransactionWithSigner mbr_factory: The `mbr_factory` ABI parameter
        :param TransactionWithSigner mbr_val: The `mbr_val` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateValidatorAdArgs(
            deposit=deposit,
            mbr_factory=mbr_factory,
            mbr_val=mbr_val,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def set_validator_ad_mandatory(
        self,
        *,
        val_config_man: ValConfigMan,
        live: bool,
        manager: str,
        max_del_cnt: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Creates or updates mandatory part of validator ad and sets liveliness status
        
        Adds a call to `set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void` ABI method
        
        :param ValConfigMan val_config_man: The `val_config_man` ABI parameter
        :param bool live: The `live` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param int max_del_cnt: The `max_del_cnt` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetValidatorAdMandatoryArgs(
            val_config_man=val_config_man,
            live=live,
            manager=manager,
            max_del_cnt=max_del_cnt,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def set_validator_ad_extra(
        self,
        *,
        val_config_extra: ValConfigExtra,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Creates or updates extra part of validator ad
        
        Adds a call to `set_validator_ad_extra((byte[30],byte[70]))void` ABI method
        
        :param ValConfigExtra val_config_extra: The `val_config_extra` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetValidatorAdExtraArgs(
            val_config_extra=val_config_extra,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def end_validator_ad(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Sender can delete the validator ad.
        
        Adds a call to `end_validator_ad()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndValidatorAdArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def val_withdraw_earnings(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `val_withdraw_earnings()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ValWithdrawEarningsArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def withdraw_balance(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `withdraw_balance()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = WithdrawBalanceArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def withdraw_depoist(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `withdraw_depoist()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = WithdrawDepoistArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_delegator_contract(
        self,
        *,
        val_app_id: int,
        deposit_payment: TransactionWithSigner,
        fee_setup_payment: TransactionWithSigner,
        mbr: TransactionWithSigner,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void` ABI method
        
        :param int val_app_id: The `val_app_id` ABI parameter
        :param TransactionWithSigner deposit_payment: The `deposit_payment` ABI parameter
        :param TransactionWithSigner fee_setup_payment: The `fee_setup_payment` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateDelegatorContractArgs(
            val_app_id=val_app_id,
            deposit_payment=deposit_payment,
            fee_setup_payment=fee_setup_payment,
            mbr=mbr,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def deposit_keys(
        self,
        *,
        del_acc: str,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = DepositKeysArgs(
            del_acc=del_acc,
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def confirm_keys(
        self,
        *,
        keyreg_txn_index: int,
        fee_operation_payment: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `confirm_keys(uint64,pay)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param TransactionWithSigner fee_operation_payment: The `fee_operation_payment` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ConfirmKeysArgs(
            keyreg_txn_index=keyreg_txn_index,
            fee_operation_payment=fee_operation_payment,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_generated(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `keys_not_generated(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotGeneratedArgs(
            del_acc=del_acc,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_confirmed(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `keys_not_confirmed(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotConfirmedArgs(
            del_acc=del_acc,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def end_expired_or_breached_delegator_contract(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Anyone can delete the delegator contract after its expiry or when it was breached.
        
        Adds a call to `end_expired_or_breached_delegator_contract(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndExpiredOrBreachedDelegatorContractArgs(
            del_acc=del_acc,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def end_active_delegator_contract(
        self,
        *,
        keyreg_txn_index: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator can withdraw from contract and get refunded remaining operational fee.
        
        Adds a call to `end_active_delegator_contract(uint64)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndActiveDelegatorContractArgs(
            keyreg_txn_index=keyreg_txn_index,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_bare(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to create an application using the no_op bare method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        self.app_client.compose_create(
            self.atc,
            call_abi_method=False,
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
        )
        return self

    def opt_in_user_opt_in(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """assert not Txn.sender.is_opted_in(
        Global.current_application_id ), "Account has already opted-in the app."
        
        Adds a call to `user_opt_in()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = UserOptInArgs()
        self.app_client.compose_opt_in(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class NoticeboardClient:
    """
        Platform for peer-to-peer consensus delegation.
        Node runners, i.e. validators can post ads to offer their services to users.
        Users, i.e. delegators, can open requests for the service and conclude a contract with a node runner.
    
        Global state
        ------------
            Configuration parameters
            ------------------------
            deposit_val_min : UInt64
                Minimum deposit required to be made by validator to the Noticeboard
            deposit_del_min : UInt64
                Minimum deposit required to be made by delegator to the Noticeboard
            val_earn_factor : UInt64
                Value scaled to (1-0), representing 1 - percentage of fees taken by the platform
    
            Variables
            ---------
            live : bool
                Whether the contract is live (true) or has ended (false)
            blocked_amt : UInt64
                Balance on the Noticeboard account that can't be withdrawn.
                It is part either of active deposits or not finalized payments.
    
        Local state
        -----------
            val_app_id : UInt64
                GeneralValidatorAd ID of the asccount - either as owner of validator or selected validator for UserContract
            del_app_id : UInt64
                UserContract ID of the account if the account is user; equals 0 for validator accounts.
            deposit_amt : UInt64
                Amount the account has deposited in the Noticeboard
    
        Boxes
        -----
            val_list : Box
                {key = val_id, value = [val_app_id: UInt64, prev_val_id: UInt64, next_val_id: UInt64] }
    
        Methods
        -------
    
        
    
    A class for interacting with the Noticeboard app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        NoticeboardClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def get_local_state(self, account: str | None = None) -> LocalState:
        """Returns the application's local state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_local_state(account, raw=True))
        return LocalState(state)

    def setup(
        self,
        *,
        deposit_val_min: int,
        deposit_del_min: int,
        val_earn_factor: int,
        val_factory_app_id: int,
        manager: str,
        mbr: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `setup(uint64,uint64,uint64,uint64,address,pay)void` ABI method
        
        :param int deposit_val_min: The `deposit_val_min` ABI parameter
        :param int deposit_del_min: The `deposit_del_min` ABI parameter
        :param int val_earn_factor: The `val_earn_factor` ABI parameter
        :param int val_factory_app_id: The `val_factory_app_id` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetupArgs(
            deposit_val_min=deposit_val_min,
            deposit_del_min=deposit_del_min,
            val_earn_factor=val_earn_factor,
            val_factory_app_id=val_factory_app_id,
            manager=manager,
            mbr=mbr,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_validator_ad(
        self,
        *,
        deposit: TransactionWithSigner,
        mbr_factory: TransactionWithSigner,
        mbr_val: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `create_validator_ad(pay,pay,pay)void` ABI method
        
        :param TransactionWithSigner deposit: The `deposit` ABI parameter
        :param TransactionWithSigner mbr_factory: The `mbr_factory` ABI parameter
        :param TransactionWithSigner mbr_val: The `mbr_val` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CreateValidatorAdArgs(
            deposit=deposit,
            mbr_factory=mbr_factory,
            mbr_val=mbr_val,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def set_validator_ad_mandatory(
        self,
        *,
        val_config_man: ValConfigMan,
        live: bool,
        manager: str,
        max_del_cnt: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Creates or updates mandatory part of validator ad and sets liveliness status
        
        Calls `set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void` ABI method
        
        :param ValConfigMan val_config_man: The `val_config_man` ABI parameter
        :param bool live: The `live` ABI parameter
        :param str manager: The `manager` ABI parameter
        :param int max_del_cnt: The `max_del_cnt` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetValidatorAdMandatoryArgs(
            val_config_man=val_config_man,
            live=live,
            manager=manager,
            max_del_cnt=max_del_cnt,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def set_validator_ad_extra(
        self,
        *,
        val_config_extra: ValConfigExtra,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Creates or updates extra part of validator ad
        
        Calls `set_validator_ad_extra((byte[30],byte[70]))void` ABI method
        
        :param ValConfigExtra val_config_extra: The `val_config_extra` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetValidatorAdExtraArgs(
            val_config_extra=val_config_extra,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def end_validator_ad(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Sender can delete the validator ad.
        
        Calls `end_validator_ad()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = EndValidatorAdArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def val_withdraw_earnings(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `val_withdraw_earnings()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = ValWithdrawEarningsArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def withdraw_balance(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `withdraw_balance()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = WithdrawBalanceArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def withdraw_depoist(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `withdraw_depoist()uint64` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = WithdrawDepoistArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_delegator_contract(
        self,
        *,
        val_app_id: int,
        deposit_payment: TransactionWithSigner,
        fee_setup_payment: TransactionWithSigner,
        mbr: TransactionWithSigner,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void` ABI method
        
        :param int val_app_id: The `val_app_id` ABI parameter
        :param TransactionWithSigner deposit_payment: The `deposit_payment` ABI parameter
        :param TransactionWithSigner fee_setup_payment: The `fee_setup_payment` ABI parameter
        :param TransactionWithSigner mbr: The `mbr` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CreateDelegatorContractArgs(
            val_app_id=val_app_id,
            deposit_payment=deposit_payment,
            fee_setup_payment=fee_setup_payment,
            mbr=mbr,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def deposit_keys(
        self,
        *,
        del_acc: str,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = DepositKeysArgs(
            del_acc=del_acc,
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def confirm_keys(
        self,
        *,
        keyreg_txn_index: int,
        fee_operation_payment: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `confirm_keys(uint64,pay)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param TransactionWithSigner fee_operation_payment: The `fee_operation_payment` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = ConfirmKeysArgs(
            keyreg_txn_index=keyreg_txn_index,
            fee_operation_payment=fee_operation_payment,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_not_generated(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `keys_not_generated(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = KeysNotGeneratedArgs(
            del_acc=del_acc,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_not_confirmed(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `keys_not_confirmed(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = KeysNotConfirmedArgs(
            del_acc=del_acc,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def end_expired_or_breached_delegator_contract(
        self,
        *,
        del_acc: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Anyone can delete the delegator contract after its expiry or when it was breached.
        
        Calls `end_expired_or_breached_delegator_contract(address)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = EndExpiredOrBreachedDelegatorContractArgs(
            del_acc=del_acc,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def end_active_delegator_contract(
        self,
        *,
        keyreg_txn_index: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Delegator can withdraw from contract and get refunded remaining operational fee.
        
        Calls `end_active_delegator_contract(uint64)void` ABI method
        
        :param int keyreg_txn_index: The `keyreg_txn_index` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = EndActiveDelegatorContractArgs(
            keyreg_txn_index=keyreg_txn_index,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_bare(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Creates an application using the no_op bare method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.TransactionResponse: The result of the transaction"""

        result = self.app_client.create(
            call_abi_method=False,
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
        )
        return result

    def opt_in_user_opt_in(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """assert not Txn.sender.is_opted_in(
        Global.current_application_id ), "Account has already opted-in the app."
        
        Calls `user_opt_in()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = UserOptInArgs()
        result = self.app_client.opt_in(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: algokit_utils.DeployCallArgs | None = None,
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: algokit_utils.DeployCallArgs | None = None,
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param algokit_utils.DeployCallArgs | None create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param algokit_utils.DeployCallArgs | None delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())
