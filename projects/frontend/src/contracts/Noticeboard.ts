/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  AppStorageSchema,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "setup(uint64,uint64,uint64,uint64,address,pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "create_validator_ad(pay,pay,pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "val_config_man": {
          "name": "ValConfigMan",
          "elements": [
            [
              "hw_cat",
              "uint64"
            ],
            [
              "min_amt",
              "uint64"
            ],
            [
              "max_amt",
              "uint64"
            ],
            [
              "fee_setup",
              "uint64"
            ],
            [
              "fee_round",
              "uint64"
            ],
            [
              "deposit",
              "uint64"
            ],
            [
              "setup_rounds",
              "uint64"
            ],
            [
              "confirmation_rounds",
              "uint64"
            ],
            [
              "max_breach",
              "uint64"
            ],
            [
              "breach_rounds",
              "uint64"
            ],
            [
              "uptime_gar",
              "uint64"
            ]
          ]
        }
      }
    },
    "set_validator_ad_extra((byte[30],byte[70]))void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "val_config_extra": {
          "name": "ValConfigExtra",
          "elements": [
            [
              "name",
              "byte[30]"
            ],
            [
              "link",
              "byte[70]"
            ]
          ]
        }
      }
    },
    "end_validator_ad()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "val_withdraw_earnings()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "withdraw_balance()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "withdraw_depoist()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "user_opt_in()void": {
      "call_config": {
        "opt_in": "CALL"
      }
    },
    "create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "confirm_keys(uint64,pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "keys_not_generated(address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "keys_not_confirmed(address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "end_expired_or_breached_delegator_contract(address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "end_active_delegator_contract(uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuYXBwcm92YWxfcHJvZ3JhbToKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9lbnRyeXBvaW50QDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fZW50cnlwb2ludEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AyMgogICAgbWV0aG9kICJzZXR1cCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxwYXkpdm9pZCIKICAgIG1ldGhvZCAiY3JlYXRlX3ZhbGlkYXRvcl9hZChwYXkscGF5LHBheSl2b2lkIgogICAgbWV0aG9kICJzZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeSgodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzZXRfdmFsaWRhdG9yX2FkX2V4dHJhKChieXRlWzMwXSxieXRlWzcwXSkpdm9pZCIKICAgIG1ldGhvZCAiZW5kX3ZhbGlkYXRvcl9hZCgpdm9pZCIKICAgIG1ldGhvZCAidmFsX3dpdGhkcmF3X2Vhcm5pbmdzKCl1aW50NjQiCiAgICBtZXRob2QgIndpdGhkcmF3X2JhbGFuY2UoKXVpbnQ2NCIKICAgIG1ldGhvZCAid2l0aGRyYXdfZGVwb2lzdCgpdWludDY0IgogICAgbWV0aG9kICJ1c2VyX29wdF9pbigpdm9pZCIKICAgIG1ldGhvZCAiY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCh1aW50NjQscGF5LHBheSxwYXksdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJkZXBvc2l0X2tleXMoYWRkcmVzcyxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJjb25maXJtX2tleXModWludDY0LHBheSl2b2lkIgogICAgbWV0aG9kICJrZXlzX25vdF9nZW5lcmF0ZWQoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJrZXlzX25vdF9jb25maXJtZWQoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJlbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3QoYWRkcmVzcyl2b2lkIgogICAgbWV0aG9kICJlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdCh1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fc2V0dXBfcm91dGVANCBtYWluX2NyZWF0ZV92YWxpZGF0b3JfYWRfcm91dGVANSBtYWluX3NldF92YWxpZGF0b3JfYWRfbWFuZGF0b3J5X3JvdXRlQDYgbWFpbl9zZXRfdmFsaWRhdG9yX2FkX2V4dHJhX3JvdXRlQDcgbWFpbl9lbmRfdmFsaWRhdG9yX2FkX3JvdXRlQDggbWFpbl92YWxfd2l0aGRyYXdfZWFybmluZ3Nfcm91dGVAOSBtYWluX3dpdGhkcmF3X2JhbGFuY2Vfcm91dGVAMTAgbWFpbl93aXRoZHJhd19kZXBvaXN0X3JvdXRlQDExIG1haW5fdXNlcl9vcHRfaW5fcm91dGVAMTIgbWFpbl9jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDEzIG1haW5fZGVwb3NpdF9rZXlzX3JvdXRlQDE0IG1haW5fY29uZmlybV9rZXlzX3JvdXRlQDE1IG1haW5fa2V5c19ub3RfZ2VuZXJhdGVkX3JvdXRlQDE2IG1haW5fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDE3IG1haW5fZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDE4IG1haW5fZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3Rfcm91dGVAMTkKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fc2V0dXBfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBzZXR1cAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfdmFsaWRhdG9yX2FkX3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTUyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMwogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNyZWF0ZV92YWxpZGF0b3JfYWQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnlfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIxNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X3ZhbGlkYXRvcl9hZF9tYW5kYXRvcnkKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZhbGlkYXRvcl9hZF9leHRyYV9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBzZXRfdmFsaWRhdG9yX2FkX2V4dHJhCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF92YWxpZGF0b3JfYWRfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNjEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGVuZF92YWxpZGF0b3JfYWQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fdmFsX3dpdGhkcmF3X2Vhcm5pbmdzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjkyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB2YWxfd2l0aGRyYXdfZWFybmluZ3MKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fd2l0aGRyYXdfYmFsYW5jZV9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMTctMzIwCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAgICAgICAgICAgRm9yIGFsbCB1c2VycyAgICAgICAgICAgLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhd19iYWxhbmNlCiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X2RlcG9pc3Rfcm91dGVAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzM3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhd19kZXBvaXN0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3VzZXJfb3B0X2luX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM2MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJPcHRJbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgaW50IE9wdEluCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBPcHRJbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgdXNlcl9vcHRfaW4KICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdF9yb3V0ZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozODEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAzCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDIKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM4MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9kZXBvc2l0X2tleXNfcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGRlcG9zaXRfa2V5cwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jb25maXJtX2tleXNfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzLTQ0CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgTm90aWNlYm9hcmQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29uZmlybV9rZXlzCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2tleXNfbm90X2dlbmVyYXRlZF9yb3V0ZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU0MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19ub3RfZ2VuZXJhdGVkCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2tleXNfbm90X2NvbmZpcm1lZF9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU3MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19ub3RfY29uZmlybWVkCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYwMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0CiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X3JvdXRlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYzMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjMzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDMtNDQKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBOb3RpY2Vib2FyZChBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5zZXR1cChkZXBvc2l0X3ZhbF9taW46IGJ5dGVzLCBkZXBvc2l0X2RlbF9taW46IGJ5dGVzLCB2YWxfZWFybl9mYWN0b3I6IGJ5dGVzLCB2YWxfZmFjdG9yeV9hcHBfaWQ6IGJ5dGVzLCBtYW5hZ2VyOiBieXRlcywgbWJyOiB1aW50NjQpIC0+IHZvaWQ6CnNldHVwOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEwNS0xMTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0dXAoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZXBvc2l0X3ZhbF9taW46IGFyYzQuVUludDY0LAogICAgLy8gICAgIGRlcG9zaXRfZGVsX21pbjogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgdmFsX2Vhcm5fZmFjdG9yOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICB2YWxfZmFjdG9yeV9hcHBfaWQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIG1hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBtYnI6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTE1CiAgICAvLyBhc3NlcnQgbm90IHNlbGYubGl2ZSwgIk5vdGljZWJvYXJkIGlzIG5vdCB5ZXQgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBub3QgeWV0IGxpdmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTE3CiAgICAvLyBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMTYtMTE4CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcwogICAgLy8gKSwgIlNldHVwIGNhbiBiZSBkb25lIG9ubHkgYnkgY29udHJhY3QgY3JlYXRvci4iCiAgICBhc3NlcnQgLy8gU2V0dXAgY2FuIGJlIGRvbmUgb25seSBieSBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEyMQogICAgLy8gZGVwb3NpdF9kZWxfbWluLm5hdGl2ZSAqIE1BWF9ERUxfQ05UIDw9IGRlcG9zaXRfdmFsX21pbi5uYXRpdmUKICAgIGZyYW1lX2RpZyAtNQogICAgYnRvaQogICAgZHVwCiAgICBpbnQgNAogICAgKgogICAgZnJhbWVfZGlnIC02CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTIwLTEyMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBkZXBvc2l0X2RlbF9taW4ubmF0aXZlICogTUFYX0RFTF9DTlQgPD0gZGVwb3NpdF92YWxfbWluLm5hdGl2ZQogICAgLy8gKSwgIlZhbGlkYXRvcidzIGRlcG9zaXQgbXVzdCBjb3ZlciBhdCBsZWFzdCBlYWNoIGRlbGVnYXRvcidzIGRlcG9zaXQuIgogICAgYXNzZXJ0IC8vIFZhbGlkYXRvcidzIGRlcG9zaXQgbXVzdCBjb3ZlciBhdCBsZWFzdCBlYWNoIGRlbGVnYXRvcidzIGRlcG9zaXQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI0CiAgICAvLyBzZWxmLmRlcG9zaXRfdmFsX21pbiA9IGRlcG9zaXRfdmFsX21pbi5uYXRpdmUKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI1CiAgICAvLyBzZWxmLmRlcG9zaXRfZGVsX21pbiA9IGRlcG9zaXRfZGVsX21pbi5uYXRpdmUKICAgIGJ5dGUgImRlcG9zaXRfZGVsX21pbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTI4CiAgICAvLyBVSW50NjQoMCkgPCB2YWxfZWFybl9mYWN0b3IubmF0aXZlIDwgVUludDY0KDEwMCkKICAgIGZyYW1lX2RpZyAtNAogICAgYnRvaQogICAgZHVwCiAgICBieiBzZXR1cF9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAwCiAgICBpbnQgMTAwCiAgICA8CiAgICBieiBzZXR1cF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIHNldHVwX2Jvb2xfbWVyZ2VANAoKc2V0dXBfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCnNldHVwX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMjctMTI5CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFVJbnQ2NCgwKSA8IHZhbF9lYXJuX2ZhY3Rvci5uYXRpdmUgPCBVSW50NjQoMTAwKQogICAgLy8gKSwgIlZhbGlkYXRvciBmYWN0b3IgY2FuJ3QgYmUgbGFyZ2VyIHRoYW4gMTAwIG9yIHNtYWxsZXIgdGhhbiAwLiIKICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgZmFjdG9yIGNhbid0IGJlIGxhcmdlciB0aGFuIDEwMCBvciBzbWFsbGVyIHRoYW4gMC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzEKICAgIC8vIHNlbGYudmFsX2Vhcm5fZmFjdG9yID0gdmFsX2Vhcm5fZmFjdG9yLm5hdGl2ZQogICAgYnl0ZSAidmFsX2Vhcm5fZmFjdG9yIgogICAgZnJhbWVfZGlnIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTMyCiAgICAvLyBzZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCA9IHZhbF9mYWN0b3J5X2FwcF9pZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMwogICAgYnRvaQogICAgYnl0ZSAidmFsX2ZhY3RvcnlfYXBwX2lkIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzMKICAgIC8vIHNlbGYubWFuYWdlciA9IG1hbmFnZXIubmF0aXZlCiAgICBieXRlICJtYW5hZ2VyIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjEzNS0xMzYKICAgIC8vICMgQ3JlYXRlIGJveCBmb3IgbGlzdCBvZiB2YWxpZGF0b3JzCiAgICAvLyBhc3NlcnQgb3AuQm94LmNyZWF0ZShCeXRlcyhWQUxfTElTVCksIFZBTF9MSVNUX0VMX0JZVEVfU0laRSAqIE1BWF9WQUxfQ05UKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBpbnQgODAwCiAgICBib3hfY3JlYXRlCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDAKICAgIC8vIG1ici5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxMzgtMTQxCiAgICAvLyAjIEFzc2VydCBpbmNyZWFzZSBpbiBtaW5pbXVtIGJhbGFuY2UgcmVxdWlyZW1lbnQgZm9yIGJveCBmb3IgdmFsaWRhdG9yIGxpc3QKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJNQlIgaW5jcmVhc2UgZm9yIGJveCBvZiB2YWxpZGF0b3IgbGlzdCBuZWVkcyB0byBiZSBjb3ZlcmVkLiIKICAgIGFzc2VydCAvLyBNQlIgaW5jcmVhc2UgZm9yIGJveCBvZiB2YWxpZGF0b3IgbGlzdCBuZWVkcyB0byBiZSBjb3ZlcmVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE0MgogICAgLy8gYXNzZXJ0IG1ici5hbW91bnQgPT0gTUJSX0JPWF9WQUxfTElTVF9DUkVBVElPTgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludCAzMjU3MDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDQKICAgIC8vIHNlbGYubGl2ZSA9IFRydWUKICAgIGJ5dGUgImxpdmUiCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNDYKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmNyZWF0ZV92YWxpZGF0b3JfYWQoZGVwb3NpdDogdWludDY0LCBtYnJfZmFjdG9yeTogdWludDY0LCBtYnJfdmFsOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZV92YWxpZGF0b3JfYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTUyLTE1OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfdmFsaWRhdG9yX2FkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVwb3NpdDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWJyX2ZhY3Rvcnk6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIG1icl92YWw6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTU5CiAgICAvLyBhc3NlcnQgc2VsZi5saXZlLCAiTm90aWNlYm9hcmQgaXMgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBsaXZlLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE2NC0xNjUKICAgIC8vICMgQW4gYWNjb3VudCBjYW4gaGF2ZSBvbmx5IG9uZSByb2xlIGluIHRoZSBwbGF0Zm9ybSAtIGVpdGhlciBVc2VyQ29udHJhY3Qgb3IgR2VuZXJhbFZhbGlkYXRvckFkCiAgICAvLyBhc3NlcnQgc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdID09IDAsICJBY2NvdW50IGRvZXNuJ3QgeWV0IGhhdmUgYSByb2xlLiIKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAhCiAgICBhc3NlcnQgLy8gQWNjb3VudCBkb2Vzbid0IHlldCBoYXZlIGEgcm9sZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNjkKICAgIC8vIGRlcG9zaXQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTY3LTE3MAogICAgLy8gIyBBc3NlcnQgbWluaW11bSB2YWxpZGF0b3IgZGVwb3NpdCB3YXMgcGFpZAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBkZXBvc2l0LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJWYWxpZGF0b3IgZGVwb3NpdCB3YXNuJ3QgbWFkZSB0byBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGRlcG9zaXQgd2Fzbid0IG1hZGUgdG8gbm90aWNlYm9hcmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTcyCiAgICAvLyBkZXBvc2l0LmFtb3VudCA+PSBzZWxmLmRlcG9zaXRfdmFsX21pbgogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBBbW91bnQKICAgIGludCAwCiAgICBieXRlICJkZXBvc2l0X3ZhbF9taW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfdmFsX21pbiBleGlzdHMKICAgIGRpZyAxCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3MS0xNzMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVwb3NpdC5hbW91bnQgPj0gc2VsZi5kZXBvc2l0X3ZhbF9taW4KICAgIC8vICksICJWYWxpZGF0b3IgZGlkbid0IGRlcG9zaXQgbWluaW11bSByZXF1aXJlZCBhbW91bnQuIgogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBkaWRuJ3QgZGVwb3NpdCBtaW5pbXVtIHJlcXVpcmVkIGFtb3VudC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxNzUtMTc2CiAgICAvLyAjIE1hcmsgZGVwb3NpdCBhbW91bnQgaW4gdXNlcidzIGxvY2FsIHN0b3JhZ2UKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPSBkZXBvc2l0LmFtb3VudAogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICBkaWcgMgogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3OC0xODYKICAgIC8vICMgQ3JlYXRlIFZhbGRpYXRvckFkCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdmYWN0b3J5VmFsaWRhdG9yQWQuZ2VuZXJhdGVfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBzZWxmLnZhbF9lYXJuX2ZhY3RvciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE4MQogICAgLy8gYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE4MgogICAgLy8gc2VsZi52YWxfZWFybl9mYWN0b3IsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2Vhcm5fZmFjdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfZWFybl9mYWN0b3IgZXhpc3RzCiAgICBpdG9iCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTgzCiAgICAvLyBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODQKICAgIC8vIGFwcF9pZD1zZWxmLnZhbF9mYWN0b3J5X2FwcF9pZCwKICAgIGludCAwCiAgICBieXRlICJ2YWxfZmFjdG9yeV9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9mYWN0b3J5X2FwcF9pZCBleGlzdHMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE3OC0xODYKICAgIC8vICMgQ3JlYXRlIFZhbGRpYXRvckFkCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdmYWN0b3J5VmFsaWRhdG9yQWQuZ2VuZXJhdGVfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBzZWxmLnZhbF9lYXJuX2ZhY3RvciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0LmFtb3VudCksCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgbWV0aG9kICJnZW5lcmF0ZV92YWxpZGF0b3JfYWQoYWRkcmVzcyx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODUKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTc4LTE4NgogICAgLy8gIyBDcmVhdGUgVmFsZGlhdG9yQWQKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2ZhY3RvcnlWYWxpZGF0b3JBZC5nZW5lcmF0ZV92YWxpZGF0b3JfYWQsCiAgICAvLyAgICAgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHNlbGYudmFsX2Vhcm5fZmFjdG9yLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXQuYW1vdW50KSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi52YWxfZmFjdG9yeV9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTg3CiAgICAvLyBjcmVhdGVkX2FwcF9pZCA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxODgtMTg5CiAgICAvLyAjIFN0b3JlIGNyZWF0ZWQgR2VuZXJhbFZhbGlkYXRvckFkIElEIGluIHZhbGlkYXRvcidzIGxvY2FsIHN0b3JhZ2UKICAgIC8vIHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXSA9IGNyZWF0ZWRfYXBwX2lkCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgZGlnIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToxOTEtMTkyCiAgICAvLyAjIEFkZCBuZXcgR2VuZXJhbFZhbGlkYXRvckFkIHRvIGxpc3Qgb2YgdmFsaWRhdG9ycwogICAgLy8gYXNzZXJ0IHZhbF9saXN0X2FkZChjcmVhdGVkX2FwcF9pZCksICJWYWxpZGF0b3IgbGlzdCBpcyBmdWxsLiIKICAgIGR1cAogICAgY2FsbHN1YiB2YWxfbGlzdF9hZGQKICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgbGlzdCBpcyBmdWxsLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjE5NwogICAgLy8gbWJyX2ZhY3RvcnkucmVjZWl2ZXIgPT0gQXBwbGljYXRpb24oc2VsZi52YWxfZmFjdG9yeV9hcHBfaWQpLmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfZmFjdG9yeV9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9mYWN0b3J5X2FwcF9pZCBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTk0LTE5OAogICAgLy8gIyBBc3NlcnQgaW5jcmVhc2UgaW4gbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IHdhcyBwYWlkIGZvciBOb3RpY2Vib2FyZCBkdWUgdG8KICAgIC8vICMgR2VuZXJhbFZhbGlkYXRvckFkIGNyZWF0aW9uCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl9mYWN0b3J5LnJlY2VpdmVyID09IEFwcGxpY2F0aW9uKHNlbGYudmFsX2ZhY3RvcnlfYXBwX2lkKS5hZGRyZXNzCiAgICAvLyApLCAiTUJSIGluY3JlYXNlIG9mIGZhY3Rvcnkgb2YgdmFsaWRhdG9yIGFkcyBuZWVkcyB0byBiZSBjb3ZlcmVkLiIKICAgIGFzc2VydCAvLyBNQlIgaW5jcmVhc2Ugb2YgZmFjdG9yeSBvZiB2YWxpZGF0b3IgYWRzIG5lZWRzIHRvIGJlIGNvdmVyZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MTk5CiAgICAvLyBhc3NlcnQgbWJyX2ZhY3RvcnkuYW1vdW50ID09IE1CUl9WQUxJREFUT1JBRF9DUkVBVElPTgogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIGludCA4OTk1MDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDEtMjAyCiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZAogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSBkZXBvc2l0LmFtb3VudAogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIHVuY292ZXIgMgogICAgKwogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwNgogICAgLy8gbWJyX3ZhbC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDQtMjA3CiAgICAvLyAjIEFzc2VydCBNQlIgd2FzIHBhaWQgZm9yIHZhbGlkYXRvciBhZGRyZXNzLCBzbyB0aGF0IG5vdGljZSBib2FyZCBjYW4gZnVuZCBpdAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfdmFsLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJNQlIgd2Fzbid0IHBhaWQgdG8gbm90aWNlYm9hcmQuIgogICAgYXNzZXJ0IC8vIE1CUiB3YXNuJ3QgcGFpZCB0byBub3RpY2Vib2FyZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMDgKICAgIC8vIGFzc2VydCBtYnJfdmFsLmFtb3VudCA9PSBVSW50NjQoCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIwOC0yMTAKICAgIC8vIGFzc2VydCBtYnJfdmFsLmFtb3VudCA9PSBVSW50NjQoCiAgICAvLyAgICAgMTAwXzAwMAogICAgLy8gKSwgIlZhbGlkYXRvciBkaWRuJ3QgZGVwb3NpdCBtaW5pbXVtIHJlcXVpcmVkIGFtb3VudCB0byB2YWxpZGF0b3IgYWQuIgogICAgaW50IDEwMDAwMAogICAgPT0KICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgZGlkbid0IGRlcG9zaXQgbWluaW11bSByZXF1aXJlZCBhbW91bnQgdG8gdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIxMgogICAgLy8gcGF5X3RvX2FjYyhVSW50NjQoMTAwXzAwMCksIEFwcGxpY2F0aW9uKGNyZWF0ZWRfYXBwX2lkKS5hZGRyZXNzKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50IDEwMDAwMAogICAgc3dhcAogICAgY2FsbHN1YiBwYXlfdG9fYWNjCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QudmFsX2xpc3RfYWRkKHZhbF9hcHBfaWQ6IHVpbnQ2NCkgLT4gdWludDY0Ogp2YWxfbGlzdF9hZGQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzEzLTcxNQogICAgLy8gIyAtLS0tLS0tIFN1YnJvdXRpbmUgdXRpbHMgLS0tLS0tLQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiB2YWxfbGlzdF9hZGQodmFsX2FwcF9pZDogVUludDY0KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICBpbnQgMAogICAgYnl0ZSAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzI5LTczMAogICAgLy8gIyBHZXQgYm94IHdpdGggdmFsaWRhdG9yIGxpc3QKICAgIC8vIHZhbF9saXN0X2JveCwgYm94X2dldCA9IG9wLkJveC5nZXQoQnl0ZXMoVkFMX0xJU1QpKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBib3hfZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzMxCiAgICAvLyBhc3NlcnQgYm94X2dldCwgIkdvdCBib3giCiAgICBhc3NlcnQgLy8gR290IGJveAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjczNC03MzUKICAgIC8vICMgQWRkIGl0IHRvIHRoZSBmaXJzdCBub24temVybyBwbGFjZQogICAgLy8gdmFsX2FkZGVkID0gRmFsc2UKICAgIGludCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzM2CiAgICAvLyBmb3IgdmFsX2lkeCBpbiB1cmFuZ2UoTUFYX1ZBTF9DTlQpOgogICAgZHVwCgp2YWxfbGlzdF9hZGRfZm9yX2hlYWRlckAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjczNgogICAgLy8gZm9yIHZhbF9pZHggaW4gdXJhbmdlKE1BWF9WQUxfQ05UKToKICAgIGZyYW1lX2RpZyA2CiAgICBpbnQgMTAwCiAgICA8CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfZGlnIDUKICAgIGZyYW1lX2J1cnkgMwogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2J1cnkgMAogICAgYnogdmFsX2xpc3RfYWRkX2FmdGVyX2ZvckA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzM3CiAgICAvLyBpZiB2YWxfbGlzdFt2YWxfaWR4XSA9PSBhcmM0LlVJbnQ2NCgwKToKICAgIGZyYW1lX2RpZyAxCiAgICBhc3NlcnQgLy8gSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyA2CiAgICBpbnQgOAogICAgKgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIGZyYW1lX2RpZyA0CiAgICBzd2FwCiAgICBpbnQgOAogICAgZXh0cmFjdDMKICAgIGJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBiPT0KICAgIGJ6IHZhbF9saXN0X2FkZF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MzgKICAgIC8vIHZhbF9saXN0W3ZhbF9pZHhdID0gYXJjNC5VSW50NjQodmFsX2FwcF9pZCkKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2RpZyAyCiAgICB1bmNvdmVyIDIKICAgIHJlcGxhY2UzCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MzkKICAgIC8vIHZhbF9hZGRlZCA9IFRydWUKICAgIGludCAxCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NDAKICAgIC8vIGJyZWFrCiAgICBiIHZhbF9saXN0X2FkZF9hZnRlcl9mb3JANwoKdmFsX2xpc3RfYWRkX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MzYKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEKICAgICsKICAgIGZyYW1lX2J1cnkgNgogICAgYiB2YWxfbGlzdF9hZGRfZm9yX2hlYWRlckAxCgp2YWxfbGlzdF9hZGRfYWZ0ZXJfZm9yQDc6CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0MgogICAgLy8gb3AuQm94LnB1dChCeXRlcyhWQUxfTElTVCksIHZhbF9saXN0LmJ5dGVzKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBmcmFtZV9kaWcgMAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0NAogICAgLy8gcmV0dXJuIHZhbF9hZGRlZAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24ucGF5X3RvX2FjYyhhbW91bnQ6IHVpbnQ2NCwgYWNjb3VudDogYnl0ZXMpIC0+IHZvaWQ6CnBheV90b19hY2M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTQ0LTE0NQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBwYXlfdG9fYWNjKGFtb3VudDogVUludDY0LCBhY2NvdW50OiBBY2NvdW50KSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTQ2LTE1MAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI9YWNjb3VudCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0NgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0OQogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNDYtMTUwCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1hY2NvdW50LAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5zZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeSh2YWxfY29uZmlnX21hbjogYnl0ZXMsIGxpdmU6IGJ5dGVzLCBtYW5hZ2VyOiBieXRlcywgbWF4X2RlbF9jbnQ6IGJ5dGVzKSAtPiB2b2lkOgpzZXRfdmFsaWRhdG9yX2FkX21hbmRhdG9yeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMTQtMjIxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIHNldF92YWxpZGF0b3JfYWRfbWFuZGF0b3J5KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX2NvbmZpZ19tYW46IFZhbENvbmZpZ01hbiwKICAgIC8vICAgICBsaXZlOiBhcmM0LkJvb2wsCiAgICAvLyAgICAgbWFuYWdlcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIG1heF9kZWxfY250OiBhcmM0LlVJbnQ2NCwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDQgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyMwogICAgLy8gc2VsZi5kZXBvc2l0X3N1ZmZpY2llbnQoKQogICAgY2FsbHN1YiBkZXBvc2l0X3N1ZmZpY2llbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyMjUKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjI2CiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyOAogICAgLy8gYXNzZXJ0IGRlbF9hcHBfaWQgPT0gVUludDY0KDApLCAiVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuIgogICAgIQogICAgYXNzZXJ0IC8vIFVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIyOQogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApLCAiVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4iCiAgICBkdXAKICAgIGFzc2VydCAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIzMS0yMzkKICAgIC8vIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLnNldF9tYW5kYXRvcnksCiAgICAvLyAgICAgdmFsX2NvbmZpZ19tYW4uY29weSgpLAogICAgLy8gICAgIGxpdmUsCiAgICAvLyAgICAgbWFuYWdlci5jb3B5KCksCiAgICAvLyAgICAgbWF4X2RlbF9jbnQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIG1ldGhvZCAic2V0X21hbmRhdG9yeSgodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjM4CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjIzMS0yMzkKICAgIC8vIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLnNldF9tYW5kYXRvcnksCiAgICAvLyAgICAgdmFsX2NvbmZpZ19tYW4uY29weSgpLAogICAgLy8gICAgIGxpdmUsCiAgICAvLyAgICAgbWFuYWdlci5jb3B5KCksCiAgICAvLyAgICAgbWF4X2RlbF9jbnQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0MAogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuZGVwb3NpdF9zdWZmaWNpZW50KCkgLT4gdm9pZDoKZGVwb3NpdF9zdWZmaWNpZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcwNS03MDcKICAgIC8vICMgLS0tLS0gQ2hlY2sgaWYgYmVsb3cgaXMgbmVlZGVkIGF0IGFsbCAtLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZGVwb3NpdF9zdWZmaWNpZW50KHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDkKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPiBzZWxmLmRlcG9zaXRfdmFsX21pbgogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfYW10IGV4aXN0cyBmb3IgYWNjb3VudAogICAgaW50IDAKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVwb3NpdF92YWxfbWluIGV4aXN0cwogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcwOC03MTAKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXSA+IHNlbGYuZGVwb3NpdF92YWxfbWluCiAgICAvLyApLCAiQWN0aW9uIGJsb2NrZWQgZHVlIHRvIGluc3VmZmljaWVudCBkZXBvc2l0IgogICAgYXNzZXJ0IC8vIEFjdGlvbiBibG9ja2VkIGR1ZSB0byBpbnN1ZmZpY2llbnQgZGVwb3NpdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLnNldF92YWxpZGF0b3JfYWRfZXh0cmEodmFsX2NvbmZpZ19leHRyYTogYnl0ZXMpIC0+IHZvaWQ6CnNldF92YWxpZGF0b3JfYWRfZXh0cmE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQyLTI0MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBzZXRfdmFsaWRhdG9yX2FkX2V4dHJhKHNlbGYsIHZhbF9jb25maWdfZXh0cmE6IFZhbENvbmZpZ0V4dHJhKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjQ1CiAgICAvLyBzZWxmLmRlcG9zaXRfc3VmZmljaWVudCgpCiAgICBjYWxsc3ViIGRlcG9zaXRfc3VmZmljaWVudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI0NwogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNDgKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUwCiAgICAvLyBhc3NlcnQgZGVsX2FwcF9pZCA9PSBVSW50NjQoMCksICJVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4iCiAgICAhCiAgICBhc3NlcnQgLy8gVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUxCiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCksICJVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLiIKICAgIGR1cAogICAgYXNzZXJ0IC8vIFVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUzLTI1OAogICAgLy8gdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuc2V0X2V4dHJhLAogICAgLy8gICAgIHZhbF9jb25maWdfZXh0cmEuY29weSgpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgInNldF9leHRyYSgoYnl0ZVszMF0sYnl0ZVs3MF0pKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNTcKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjUzLTI1OAogICAgLy8gdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuc2V0X2V4dHJhLAogICAgLy8gICAgIHZhbF9jb25maWdfZXh0cmEuY29weSgpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNTkKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmVuZF92YWxpZGF0b3JfYWQoKSAtPiB2b2lkOgplbmRfdmFsaWRhdG9yX2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI2MS0yNjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZW5kX3ZhbGlkYXRvcl9hZCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjY3CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI2OAogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzAKICAgIC8vIGFzc2VydCBkZWxfYXBwX2lkID09IFVJbnQ2NCgwKSwgIlVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLiIKICAgICEKICAgIGFzc2VydCAvLyBVc2VyIGlzIG5vdCBhIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzEKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSwgIlVzZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSB2YWxpZGF0b3IgYWQuIgogICAgZHVwCiAgICBhc3NlcnQgLy8gVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzMtMjc4CiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5lbmRfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIG9uX2NvbXBsZXRpb249T25Db21wbGV0ZUFjdGlvbi5EZWxldGVBcHBsaWNhdGlvbiwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzYKICAgIC8vIG9uX2NvbXBsZXRpb249T25Db21wbGV0ZUFjdGlvbi5EZWxldGVBcHBsaWNhdGlvbiwKICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIGR1cAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjczLTI3OAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX3ZhbGlkYXRvcl9hZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBvbl9jb21wbGV0aW9uPU9uQ29tcGxldGVBY3Rpb24uRGVsZXRlQXBwbGljYXRpb24sCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImVuZF92YWxpZGF0b3JfYWQoKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI3NwogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzMtMjc4CiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5lbmRfdmFsaWRhdG9yX2FkLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIG9uX2NvbXBsZXRpb249T25Db21wbGV0ZUFjdGlvbi5EZWxldGVBcHBsaWNhdGlvbiwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyNzkKICAgIC8vIHZhbF9lYXJuaW5ncyA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODEtMjgyCiAgICAvLyAjIEluY3JlYXNlIHVzZXIncywgaS5lLiB2YWxpZGF0b3JzLCBlYXJuaW5ncwogICAgLy8gc2VsZi5iYWxhbmNlW1R4bi5zZW5kZXJdICs9IHZhbF9lYXJuaW5ncwogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImJhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgICsKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODQtMjg1CiAgICAvLyAjIFJlbW92ZSBHZW5lcmFsVmFsaWRhdG9yQWQgZnJvbSBsaXN0IG9mIHZhbGlkYXRvcnMKICAgIC8vIGFzc2VydCB2YWxfbGlzdF9yZW1vdmUodmFsX2FwcF9pZCksICJWYWxpZGF0b3IgbGlzdCBkb2Vzbid0IGluY2x1ZGUgdGhlIGFkLiIKICAgIGNhbGxzdWIgdmFsX2xpc3RfcmVtb3ZlCiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGxpc3QgZG9lc24ndCBpbmNsdWRlIHRoZSBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyODctMjg4CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKFR4bi5zZW5kZXIpLCAiQ291bGRuJ3QgZnJlZSB2YWxpZGF0b3IuIgogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBmcmVlX3VzZXIKICAgIGFzc2VydCAvLyBDb3VsZG4ndCBmcmVlIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyOTAKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0LnZhbF9saXN0X3JlbW92ZSh2YWxfYXBwX2lkOiB1aW50NjQpIC0+IHVpbnQ2NDoKdmFsX2xpc3RfcmVtb3ZlOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc0Ny03NDgKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgdmFsX2xpc3RfcmVtb3ZlKHZhbF9hcHBfaWQ6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgaW50IDAKICAgIGJ5dGUgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc2Mi03NjMKICAgIC8vICMgR2V0IGJveCB3aXRoIHZhbGlkYXRvciBsaXN0CiAgICAvLyB2YWxfbGlzdF9ib3gsIGJveF9nZXQgPSBvcC5Cb3guZ2V0KEJ5dGVzKFZBTF9MSVNUKSkKICAgIGJ5dGUgInZhbF9saXN0IgogICAgYm94X2dldAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc2NAogICAgLy8gYXNzZXJ0IGJveF9nZXQsICJHb3QgYm94IgogICAgYXNzZXJ0IC8vIEdvdCBib3gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjctNzY4CiAgICAvLyAjIFJlbW92ZSB0aGUgZWxlbWVudAogICAgLy8gdmFsX3JlbW92ZSA9IEZhbHNlCiAgICBpbnQgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc2OQogICAgLy8gZm9yIHZhbF9pZHggaW4gdXJhbmdlKE1BWF9WQUxfQ05UKToKICAgIGR1cAoKdmFsX2xpc3RfcmVtb3ZlX2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjkKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEwMAogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9idXJ5IDMKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9idXJ5IDAKICAgIGJ6IHZhbF9saXN0X3JlbW92ZV9hZnRlcl9mb3JANwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3MAogICAgLy8gaWYgdmFsX2xpc3RbdmFsX2lkeF0gPT0gYXJjNC5VSW50NjQodmFsX2FwcF9pZCk6CiAgICBmcmFtZV9kaWcgMQogICAgYXNzZXJ0IC8vIEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgNgogICAgaW50IDgKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICBmcmFtZV9kaWcgNAogICAgc3dhcAogICAgaW50IDgKICAgIGV4dHJhY3QzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGI9PQogICAgYnogdmFsX2xpc3RfcmVtb3ZlX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3MQogICAgLy8gdmFsX2xpc3RbdmFsX2lkeF0gPSBhcmM0LlVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2RpZyAyCiAgICBieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgcmVwbGFjZTMKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3MgogICAgLy8gdmFsX3JlbW92ZSA9IFRydWUKICAgIGludCAxCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NzMKICAgIC8vIGJyZWFrCiAgICBiIHZhbF9saXN0X3JlbW92ZV9hZnRlcl9mb3JANwoKdmFsX2xpc3RfcmVtb3ZlX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3NjkKICAgIC8vIGZvciB2YWxfaWR4IGluIHVyYW5nZShNQVhfVkFMX0NOVCk6CiAgICBmcmFtZV9kaWcgNgogICAgaW50IDEKICAgICsKICAgIGZyYW1lX2J1cnkgNgogICAgYiB2YWxfbGlzdF9yZW1vdmVfZm9yX2hlYWRlckAxCgp2YWxfbGlzdF9yZW1vdmVfYWZ0ZXJfZm9yQDc6CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3NQogICAgLy8gb3AuQm94LnB1dChCeXRlcyhWQUxfTElTVCksIHZhbF9saXN0LmJ5dGVzKQogICAgYnl0ZSAidmFsX2xpc3QiCiAgICBmcmFtZV9kaWcgMAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojc3NwogICAgLy8gcmV0dXJuIHZhbF9yZW1vdmUKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmZyZWVfdXNlcih1c2VyX2FjYzogYnl0ZXMpIC0+IHVpbnQ2NDoKZnJlZV91c2VyOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY5OS03MDAKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZnJlZV91c2VyKHNlbGYsIHVzZXJfYWNjOiBBY2NvdW50KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NzAxCiAgICAvLyBzZWxmLnZhbF9hcHBfaWRbdXNlcl9hY2NdID0gVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjcwMgogICAgLy8gc2VsZi5kZWxfYXBwX2lkW3VzZXJfYWNjXSA9IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo3MDMKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLnZhbF93aXRoZHJhd19lYXJuaW5ncygpIC0+IGJ5dGVzOgp2YWxfd2l0aGRyYXdfZWFybmluZ3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MjkyLTI5NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB2YWxfd2l0aGRyYXdfZWFybmluZ3MoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAwIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weToyOTYKICAgIC8vIHZhbF9hcHBfaWQgPSBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mjk3CiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjI5OQogICAgLy8gYXNzZXJ0IGRlbF9hcHBfaWQgPT0gVUludDY0KDApLCAiVXNlciBpcyBub3QgYSB2YWxpZGF0b3IuIgogICAgIQogICAgYXNzZXJ0IC8vIFVzZXIgaXMgbm90IGEgdmFsaWRhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMwMAogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApLCAiVXNlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIHZhbGlkYXRvciBhZC4iCiAgICBkdXAKICAgIGFzc2VydCAvLyBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMwMi0zMDYKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLndpdGhkcmF3X2Vhcm5pbmdzLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBtZXRob2QgIndpdGhkcmF3X2Vhcm5pbmdzKCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDUKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzAyLTMwNgogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQud2l0aGRyYXdfZWFybmluZ3MsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzA3CiAgICAvLyBlYXJuaW5ncyA9IHJlc3VsdC5uYXRpdmUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozMDktMzExCiAgICAvLyAjIFJlbGVhc2UgYmxvY2tlZCBiYWxhbmNlIGluIE5vdGljZWJvYXJkIGZvciBkaWZmZXJlbmNlIGJldHdlZW4gY2hhcmdlZCBmZWVfc2V0dXAgYW5kIGVhcm5pbmdzIG9mIHZhbGlkYXRvciwKICAgIC8vICMgaS5lLiBlYXJuaW5ncyBvZiB0aGUgcGxhdGZvcm0KICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgLT0gZWFybmluZ3MKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBkaWcgMQogICAgLQogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMxMwogICAgLy8gcGF5X3RvX3NlbmRlcihlYXJuaW5ncykKICAgIGR1cAogICAgY2FsbHN1YiBwYXlfdG9fc2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzE1CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoZWFybmluZ3MpCiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24ucGF5X3RvX3NlbmRlcihhbW91bnQ6IHVpbnQ2NCkgLT4gdm9pZDoKcGF5X3RvX3NlbmRlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxMzQtMTM2CiAgICAvLyAjIC0tLS0tLS0gRnVuY3Rpb25zIC0tLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcGF5X3RvX3NlbmRlcihhbW91bnQ6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjEzNy0xNDEKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9YW1vdW50LAogICAgLy8gICAgIHJlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTM5CiAgICAvLyByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjEzNwogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE0MAogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxMzctMTQxCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC53aXRoZHJhd19iYWxhbmNlKCkgLT4gYnl0ZXM6CndpdGhkcmF3X2JhbGFuY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzE3LTMyMwogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gICAgICAgICAgIEZvciBhbGwgdXNlcnMgICAgICAgICAgIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB3aXRoZHJhd19iYWxhbmNlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzI1CiAgICAvLyBiYWxhbmNlID0gc2VsZi5iYWxhbmNlW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAiYmFsYW5jZSIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBiYWxhbmNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMyNy0zMjgKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgLT0gYmFsYW5jZQogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIGRpZyAxCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzMwCiAgICAvLyBwYXlfdG9fc2VuZGVyKGJhbGFuY2UpCiAgICBkdXAKICAgIGNhbGxzdWIgcGF5X3RvX3NlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjMzMi0zMzMKICAgIC8vICMgU2V0IG5ldyBiYWxhbmNlIHRvIHplcm8KICAgIC8vIHNlbGYuYmFsYW5jZVtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiYmFsYW5jZSIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzM1CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoYmFsYW5jZSkKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC53aXRoZHJhd19kZXBvaXN0KCkgLT4gYnl0ZXM6CndpdGhkcmF3X2RlcG9pc3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzM3LTM0MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB3aXRoZHJhd19kZXBvaXN0KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzQxCiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0MgogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNDQtMzQ2CiAgICAvLyBhc3NlcnQgZGVsX2FwcF9pZCA9PSBVSW50NjQoMCkgYW5kIHZhbF9hcHBfaWQgPT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJXaXRoZHJhd2FsIG9mIGRlcG9zaXQgaXMgb25seSBwb3NzaWJsZSBpZiB1c2VyIGlzIG5laXRoZXIgYSB2YWxpZGF0b3Igbm9yIGEgZGVsZWdhdG9yLiIKICAgIGJueiB3aXRoZHJhd19kZXBvaXN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDAKICAgIGJueiB3aXRoZHJhd19kZXBvaXN0X2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIgd2l0aGRyYXdfZGVwb2lzdF9ib29sX21lcmdlQDQKCndpdGhkcmF3X2RlcG9pc3RfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCndpdGhkcmF3X2RlcG9pc3RfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM0NC0zNDYKICAgIC8vIGFzc2VydCBkZWxfYXBwX2lkID09IFVJbnQ2NCgwKSBhbmQgdmFsX2FwcF9pZCA9PSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIldpdGhkcmF3YWwgb2YgZGVwb3NpdCBpcyBvbmx5IHBvc3NpYmxlIGlmIHVzZXIgaXMgbmVpdGhlciBhIHZhbGlkYXRvciBub3IgYSBkZWxlZ2F0b3IuIgogICAgYXNzZXJ0IC8vIFdpdGhkcmF3YWwgb2YgZGVwb3NpdCBpcyBvbmx5IHBvc3NpYmxlIGlmIHVzZXIgaXMgbmVpdGhlciBhIHZhbGlkYXRvciBub3IgYSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzQ4CiAgICAvLyBkZXBvc2l0ID0gc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXQogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGRlcG9zaXRfYW10IGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM1MC0zNTEKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIHRoZSBkZXBvc2l0CiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IGRlcG9zaXQKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBkaWcgMQogICAgLQogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM1MwogICAgLy8gcGF5X3RvX3NlbmRlcihkZXBvc2l0KQogICAgZHVwCiAgICBjYWxsc3ViIHBheV90b19zZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNTUtMzU2CiAgICAvLyAjIFNldCBuZXcgZGVwb3NpdCB0byB6ZXJvCiAgICAvLyBzZWxmLmRlcG9zaXRfYW10W1R4bi5zZW5kZXJdID0gVUludDY0KDApCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJkZXBvc2l0X2FtdCIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzU4CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoZGVwb3NpdCkKICAgIGl0b2IKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC51c2VyX29wdF9pbigpIC0+IHZvaWQ6CnVzZXJfb3B0X2luOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM2MC0zNjMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiT3B0SW4iXSkKICAgIC8vIGRlZiB1c2VyX29wdF9pbigKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzcwCiAgICAvLyBzZWxmLnZhbF9hcHBfaWRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBpbnQgMAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM3MQogICAgLy8gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gVUludDY0KDApCiAgICB0eG4gU2VuZGVyCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNzIKICAgIC8vIHNlbGYuZGVwb3NpdF9hbXRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgaW50IDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozNzMKICAgIC8vIHNlbGYuYmFsYW5jZVtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiYmFsYW5jZSIKICAgIGludCAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzc1CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0KHZhbF9hcHBfaWQ6IGJ5dGVzLCBkZXBvc2l0X3BheW1lbnQ6IHVpbnQ2NCwgZmVlX3NldHVwX3BheW1lbnQ6IHVpbnQ2NCwgbWJyOiB1aW50NjQsIHJvdW5kX3N0YXJ0OiBieXRlcywgcm91bmRfZW5kOiBieXRlcykgLT4gdm9pZDoKY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTozODEtMzkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfYXBwX2lkOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICBkZXBvc2l0X3BheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIGZlZV9zZXR1cF9wYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICAgICBtYnI6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByb3VuZF9lbmQ6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6MzkxCiAgICAvLyBhc3NlcnQgc2VsZi5saXZlLCAiTm90aWNlYm9hcmQgaXMgbGl2ZS4iCiAgICBpbnQgMAogICAgYnl0ZSAibGl2ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgbGl2ZSBleGlzdHMKICAgIGFzc2VydCAvLyBOb3RpY2Vib2FyZCBpcyBsaXZlLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjM5NwogICAgLy8gYXNzZXJ0IHNlbGYudmFsX2FwcF9pZFtUeG4uc2VuZGVyXSA9PSAwLCAiQWNjb3VudCBkb2Vzbid0IHlldCBoYXZlIGEgcm9sZS4iCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgIQogICAgYXNzZXJ0IC8vIEFjY291bnQgZG9lc24ndCB5ZXQgaGF2ZSBhIHJvbGUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDAyCiAgICAvLyBtYnIucmVjZWl2ZXIgPT0gQXBwbGljYXRpb24odmFsX2FwcF9pZC5uYXRpdmUpLmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtNgogICAgYnRvaQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Mzk5LTQwMwogICAgLy8gIyBBc3NlcnQgaW5jcmVhc2UgaW4gbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IHdhcyBwYWlkIGZvciBWYWxkaWF0b3JBZCBkdWUgdG8KICAgIC8vICMgRGVsZWdhdG9yQ29udHJhY3QgY3JlYXRpb24KICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyLnJlY2VpdmVyID09IEFwcGxpY2F0aW9uKHZhbF9hcHBfaWQubmF0aXZlKS5hZGRyZXNzCiAgICAvLyApLCAiTUJSIHdhc24ndCBwYWlkIHRvIHRoZSB2YWxkaWF0b3IgYWQuIgogICAgYXNzZXJ0IC8vIE1CUiB3YXNuJ3QgcGFpZCB0byB0aGUgdmFsZGlhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQwNQogICAgLy8gbWJyLmFtb3VudCA9PSBNQlJfREVMRUdBVE9SQ09OVFJBQ1RfQ1JFQVRJT04KICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGludCA3ODUwMDAKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDA0LTQwNgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnIuYW1vdW50ID09IE1CUl9ERUxFR0FUT1JDT05UUkFDVF9DUkVBVElPTgogICAgLy8gKSwgIk1CUiBwYXkgaGFkIGluc3VmZmljaWVudCBhbW91bnQgZm9yIGNyZWF0aW9uIG9mIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIE1CUiBwYXkgaGFkIGluc3VmZmljaWVudCBhbW91bnQgZm9yIGNyZWF0aW9uIG9mIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDEwCiAgICAvLyBkZXBvc2l0X3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDA4LTQxMQogICAgLy8gIyBBc3NlcnQgbWluaW11bSBkZWxlZ2F0b3IgZGVwb3NpdCB3YXMgcGFpZCB0byB0aGUgbm90aWNlYm9hcmQgKGFtb3VudCBjaGVja2VkIGluIEdlbmVyYWxWYWxpZGF0b3JBZCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVwb3NpdF9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJEZXBvc2l0IHdhc24ndCBwYWlkIHRvIHRoZSBub3RpY2Vib2FyZC4iCiAgICBhc3NlcnQgLy8gRGVwb3NpdCB3YXNuJ3QgcGFpZCB0byB0aGUgbm90aWNlYm9hcmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDE0CiAgICAvLyBmZWVfc2V0dXBfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MTItNDE1CiAgICAvLyAjIEFzc2VydCBjb3JyZWN0IGFtb3VudCBvZiBzZXR1cCBmZWUgd2FzIHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkIChhbW91bnQgY2hlY2tlZCBpbiBHZW5lcmFsVmFsaWRhdG9yQWQpCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGZlZV9zZXR1cF9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLiIKICAgIGFzc2VydCAvLyBTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQxNy00MjcKICAgIC8vICMgQ3JlYXRlIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QgZm9yIHRoZSBjaG9zZW4gdmFsaWRhdG9yCiAgICAvLyBjcmVhdGVkX2RlbF9hcHBfaWQsIHR4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVwb3NpdF9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZmVlX3NldHVwX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBhcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgcm91bmRfc3RhcnQsCiAgICAvLyAgICAgcm91bmRfZW5kLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLm5hdGl2ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjAKICAgIC8vIGFyYzQuVUludDY0KGRlcG9zaXRfcGF5bWVudC5hbW91bnQpLAogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBBbW91bnQKICAgIGR1cAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQyMQogICAgLy8gYXJjNC5VSW50NjQoZmVlX3NldHVwX3BheW1lbnQuYW1vdW50KSwKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjIKICAgIC8vIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIHN3YXAKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MTctNDI3CiAgICAvLyAjIENyZWF0ZSBuZXcgZGVsZWdhdG9yIGNvbnRyYWN0IGZvciB0aGUgY2hvc2VuIHZhbGlkYXRvcgogICAgLy8gY3JlYXRlZF9kZWxfYXBwX2lkLCB0eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5jcmVhdGVfZGVsZWdhdG9yX2NvbnRyYWN0LAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXRfcGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZC5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImNyZWF0ZV9kZWxlZ2F0b3JfY29udHJhY3QodWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MjYKICAgIC8vIGZlZT0wLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDE3LTQyNwogICAgLy8gIyBDcmVhdGUgbmV3IGRlbGVnYXRvciBjb250cmFjdCBmb3IgdGhlIGNob3NlbiB2YWxpZGF0b3IKICAgIC8vIGNyZWF0ZWRfZGVsX2FwcF9pZCwgdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuY3JlYXRlX2RlbGVnYXRvcl9jb250cmFjdCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZXBvc2l0X3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQubmF0aXZlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQyOC00MjkKICAgIC8vICMgU3RvcmUgdGhlIGNyZWF0ZWQgZGVsZWdhdG9yIGNvbnRyYWN0IGFwcCBJRAogICAgLy8gc2VsZi5kZWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gY3JlYXRlZF9kZWxfYXBwX2lkLm5hdGl2ZQogICAgYnRvaQogICAgdHhuIFNlbmRlcgogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIHVuY292ZXIgMgogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzMC00MzEKICAgIC8vICMgU3RvcmUgc2VsZWN0ZWQgdmFsaWRhdG9yIGNvbnRyYWN0IGFwcCBJRAogICAgLy8gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdID0gdmFsX2FwcF9pZC5uYXRpdmUKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICB1bmNvdmVyIDUKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MzMtNDM0CiAgICAvLyAjIE1hcmsgZGVsZWdhdG9ycyBkZXBvc2l0IGFtb3VudAogICAgLy8gc2VsZi5kZXBvc2l0X2FtdFtUeG4uc2VuZGVyXSA9IGRlcG9zaXRfcGF5bWVudC5hbW91bnQKICAgIHR4biBTZW5kZXIKICAgIGJ5dGUgImRlcG9zaXRfYW10IgogICAgZGlnIDMKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0MzYtNDM3CiAgICAvLyAjIEluY3JlYXNlIGJsb2NrZWQgYmFsYW5jZQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCArPSAoCiAgICBpbnQgMAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGJsb2NrZWRfYW10IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQzOAogICAgLy8gZGVwb3NpdF9wYXltZW50LmFtb3VudCArIGZlZV9zZXR1cF9wYXltZW50LmFtb3VudCArIG1ici5hbW91bnQKICAgIHVuY292ZXIgMgogICAgKwogICAgdW5jb3ZlciAyCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM2LTQzOQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgKz0gKAogICAgLy8gICAgIGRlcG9zaXRfcGF5bWVudC5hbW91bnQgKyBmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQgKyBtYnIuYW1vdW50CiAgICAvLyApCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM2LTQzNwogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgKz0gKAogICAgYnl0ZSAiYmxvY2tlZF9hbXQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDM2LTQzOQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UKICAgIC8vIHNlbGYuYmxvY2tlZF9hbXQgKz0gKAogICAgLy8gICAgIGRlcG9zaXRfcGF5bWVudC5hbW91bnQgKyBmZWVfc2V0dXBfcGF5bWVudC5hbW91bnQgKyBtYnIuYW1vdW50CiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ0MQogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuZGVwb3NpdF9rZXlzKGRlbF9hY2M6IGJ5dGVzLCBzZWxfa2V5OiBieXRlcywgdm90ZV9rZXk6IGJ5dGVzLCBzdGF0ZV9wcm9vZl9rZXk6IGJ5dGVzLCB2b3RlX2tleV9kaWx1dGlvbjogYnl0ZXMsIHJvdW5kX3N0YXJ0OiBieXRlcywgcm91bmRfZW5kOiBieXRlcykgLT4gdm9pZDoKZGVwb3NpdF9rZXlzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ0My00NTMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGVwb3NpdF9rZXlzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FjYzogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHNlbF9rZXk6IFNlbEtleSwKICAgIC8vICAgICB2b3RlX2tleTogVm90ZUtleSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXk6IFN0YXRlUHJvb2ZLZXksCiAgICAvLyAgICAgdm90ZV9rZXlfZGlsdXRpb246IGFyYzQuVUludDY0LAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByb3VuZF9lbmQ6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDU1CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC03CiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ1NgogICAgLy8gZGVsX2FwcF9pZCA9IHNlbGYuZGVsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtNwogICAgaW50IDAKICAgIGJ5dGUgImRlbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZGVsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTgtNDcwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5kZXBvc2l0X2tleXMsCiAgICAvLyAgICAgVHhuLnNlbmRlciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDYxCiAgICAvLyBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NjAKICAgIC8vIFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBBY2NvdW50cwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ1OC00NzAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmRlcG9zaXRfa2V5cywKICAgIC8vICAgICBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIHNlbF9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5LmNvcHkoKSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXkuY29weSgpLAogICAgLy8gICAgIHZvdGVfa2V5X2RpbHV0aW9uLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0LAogICAgLy8gICAgIHJvdW5kX2VuZCwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIG1ldGhvZCAiZGVwb3NpdF9rZXlzKGFjY291bnQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDYwCiAgICAvLyBUeG4uc2VuZGVyLAogICAgYnl0ZSAweDAxCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTgtNDcwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5kZXBvc2l0X2tleXMsCiAgICAvLyAgICAgVHhuLnNlbmRlciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ2OQogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0NTgtNDcwCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5kZXBvc2l0X2tleXMsCiAgICAvLyAgICAgVHhuLnNlbmRlciwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbiwKICAgIC8vICAgICByb3VuZF9zdGFydCwKICAgIC8vICAgICByb3VuZF9lbmQsCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDcxCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0Lm5hdGl2ZQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjQ3My00NzQKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmcgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc2CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5jb25maXJtX2tleXMoa2V5cmVnX3R4bl9pbmRleDogYnl0ZXMsIGZlZV9vcGVyYXRpb25fcGF5bWVudDogdWludDY0KSAtPiB2b2lkOgpjb25maXJtX2tleXM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDc4LTQ4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb25maXJtX2tleXMoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBrZXlyZWdfdHhuX2luZGV4OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICBmZWVfb3BlcmF0aW9uX3BheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg1CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0ODYKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg4LTQ5MAogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGJ6IGNvbmZpcm1fa2V5c19ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAxCiAgICBieiBjb25maXJtX2tleXNfYm9vbF9mYWxzZUAzCiAgICBpbnQgMQogICAgYiBjb25maXJtX2tleXNfYm9vbF9tZXJnZUA0Cgpjb25maXJtX2tleXNfYm9vbF9mYWxzZUAzOgogICAgaW50IDAKCmNvbmZpcm1fa2V5c19ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDg4LTQ5MAogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBTZW5kZXIgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NDkzCiAgICAvLyBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAzCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBpbnQgMwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTItNDk0CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIEdsb2JhbC5ncm91cF9zaXplID09IDMKICAgIC8vICksICJDaGVjayBndHhuIHNpemUgaXMgZXhhY3RseSB0aHJlZSAtIGZlZSBwYXltZW50LCBhcHAgY2FsbCwgYW5kIGtleSByZWcuIgogICAgYXNzZXJ0IC8vIENoZWNrIGd0eG4gc2l6ZSBpcyBleGFjdGx5IHRocmVlIC0gZmVlIHBheW1lbnQsIGFwcCBjYWxsLCBhbmQga2V5IHJlZy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTgKICAgIC8vIGZlZV9vcGVyYXRpb25fcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0OTYtNDk5CiAgICAvLyAjIEFzc2VydCBjb3JyZWN0IGFtb3VudCBvZiBvcGVyYXRpb25hbCBmZWUgd2FzIHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkIChhbW91bnQgY2hlY2tlZCBpbiBEZWxlZ2F0b3JDb250cmFjdCkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZmVlX29wZXJhdGlvbl9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLiIKICAgIGFzc2VydCAvLyBTZXR1cCBmZWUgd2Fzbid0IHBhaWQgdG8gdGhlIG5vdGljZWJvYXJkLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUwMgogICAgLy8gb3AuR1R4bi50eXBlX2VudW0oa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGJ0b2kKICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDMKICAgIC8vID09IFRyYW5zYWN0aW9uVHlwZS5LZXlSZWdpc3RyYXRpb24KICAgIGludCBrZXlyZWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDItNTAzCiAgICAvLyBvcC5HVHhuLnR5cGVfZW51bShrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vID09IFRyYW5zYWN0aW9uVHlwZS5LZXlSZWdpc3RyYXRpb24KICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTAxLTUwNAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBvcC5HVHhuLnR5cGVfZW51bShrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vICAgICA9PSBUcmFuc2FjdGlvblR5cGUuS2V5UmVnaXN0cmF0aW9uCiAgICAvLyApLCAiS2V5IHJlZyB0cmFuc2FjdGlvbi4iCiAgICBhc3NlcnQgLy8gS2V5IHJlZyB0cmFuc2FjdGlvbi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDcKICAgIC8vIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICBkdXAKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MDYtNTA4CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG9wLkdUeG4uc2VuZGVyKGtleXJlZ190eG5faW5kZXgubmF0aXZlKSA9PSBUeG4uc2VuZGVyCiAgICAvLyApLCAiS2V5IHJlZyBpcyBmcm9tIHRoZSBzYW1lIGFjY291bnQgYXMgdGhlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gS2V5IHJlZyBpcyBmcm9tIHRoZSBzYW1lIGFjY291bnQgYXMgdGhlIGRlbGVnYXRvciBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTAKICAgIC8vIHNlbF9rZXkgPSBTZWxLZXkuZnJvbV9ieXRlcyhvcC5HVHhuLnNlbGVjdGlvbl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkpCiAgICBkdXAKICAgIGd0eG5zIFNlbGVjdGlvblBLCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTExCiAgICAvLyB2b3RlX2tleSA9IFZvdGVLZXkuZnJvbV9ieXRlcyhvcC5HVHhuLnZvdGVfcGsoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpKQogICAgZHVwCiAgICBndHhucyBWb3RlUEsKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTItNTE0CiAgICAvLyBzdGF0ZV9wcm9vZl9rZXkgPSBTdGF0ZVByb29mS2V5LmZyb21fYnl0ZXMoCiAgICAvLyAgICAgb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxMwogICAgLy8gb3AuR1R4bi5zdGF0ZV9wcm9vZl9wayhrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkKICAgIGd0eG5zIFN0YXRlUHJvb2ZQSwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxMi01MTQKICAgIC8vIHN0YXRlX3Byb29mX2tleSA9IFN0YXRlUHJvb2ZLZXkuZnJvbV9ieXRlcygKICAgIC8vICAgICBvcC5HVHhuLnN0YXRlX3Byb29mX3BrKGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUxNgogICAgLy8gdm90ZV9rZXlfZGlsdXRpb24gPSBvcC5HVHhuLnZvdGVfa2V5X2RpbHV0aW9uKGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZHVwCiAgICBndHhucyBWb3RlS2V5RGlsdXRpb24KICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTcKICAgIC8vIHJvdW5kX3N0YXJ0ID0gb3AuR1R4bi52b3RlX2ZpcnN0KGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZHVwCiAgICBndHhucyBWb3RlRmlyc3QKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MTgKICAgIC8vIHJvdW5kX2VuZCA9IG9wLkdUeG4udm90ZV9sYXN0KGtleXJlZ190eG5faW5kZXgubmF0aXZlKQogICAgZ3R4bnMgVm90ZUxhc3QKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjAtNTMyCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5jb25maXJtX2tleXMsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZmVlX29wZXJhdGlvbl9wYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgc2VsX2tleS5jb3B5KCksCiAgICAvLyAgICAgdm90ZV9rZXkuY29weSgpLAogICAgLy8gICAgIHN0YXRlX3Byb29mX2tleS5jb3B5KCksCiAgICAvLyAgICAgYXJjNC5VSW50NjQodm90ZV9rZXlfZGlsdXRpb24pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX3N0YXJ0KSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChyb3VuZF9lbmQpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMgogICAgLy8gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICBmcmFtZV9kaWcgMQogICAgaXRvYgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMwogICAgLy8gYXJjNC5VSW50NjQoZmVlX29wZXJhdGlvbl9wYXltZW50LmFtb3VudCksCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTI3CiAgICAvLyBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1MjgKICAgIC8vIGFyYzQuVUludDY0KHJvdW5kX3N0YXJ0KSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyOQogICAgLy8gYXJjNC5VSW50NjQocm91bmRfZW5kKSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgc3dhcAogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMC01MzIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNvbmZpcm1fa2V5cywKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfb3BlcmF0aW9uX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICAvLyAgICAgYXJjNC5VSW50NjQocm91bmRfc3RhcnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX2VuZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImNvbmZpcm1fa2V5cyh1aW50NjQsdWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTMxCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUyMC01MzIKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmNvbmZpcm1fa2V5cywKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChmZWVfb3BlcmF0aW9uX3BheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICBzZWxfa2V5LmNvcHkoKSwKICAgIC8vICAgICB2b3RlX2tleS5jb3B5KCksCiAgICAvLyAgICAgc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCh2b3RlX2tleV9kaWx1dGlvbiksCiAgICAvLyAgICAgYXJjNC5VSW50NjQocm91bmRfc3RhcnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJvdW5kX2VuZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTMzCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0Lm5hdGl2ZQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjUzNS01MzYKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmcgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTM4LTUzOQogICAgLy8gIyBJbmNyZWFzZSBibG9ja2VkIGJhbGFuY2UgZm9yIG9wZXJ0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ICs9IGZlZV9vcGVyYXRpb25fcGF5bWVudC5hbW91bnQKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICArCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTQxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5rZXlzX25vdF9nZW5lcmF0ZWQoZGVsX2FjYzogYnl0ZXMpIC0+IHZvaWQ6CmtleXNfbm90X2dlbmVyYXRlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NDMtNTQ3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGtleXNfbm90X2dlbmVyYXRlZCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hY2M6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU0OQogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTUwCiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1Mi01NTQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBieiBrZXlzX25vdF9nZW5lcmF0ZWRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMQogICAgYnoga2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIga2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfbWVyZ2VANAoKa2V5c19ub3RfZ2VuZXJhdGVkX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgprZXlzX25vdF9nZW5lcmF0ZWRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1Mi01NTQKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU1Ni01NjEKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2dlbmVyYXRlZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTgKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgZnJhbWVfZGlnIDEKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTYtNTYxCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5rZXlzX25vdF9nZW5lcmF0ZWQsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImtleXNfbm90X2dlbmVyYXRlZCh1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnQgYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU2MAogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NTYtNTYxCiAgICAvLyByZXN1bHQsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIEdlbmVyYWxWYWxpZGF0b3JBZC5rZXlzX25vdF9nZW5lcmF0ZWQsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTYyCiAgICAvLyBmZWVfc2V0dXAgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTY0LTU2NQogICAgLy8gIyBSZWZ1bmQgc2V0dXAgZmVlIHRvIGRlbGVnYXRvcidzIGJhbGFuY2UKICAgIC8vIHNlbGYuYmFsYW5jZVtkZWxfYWNjLm5hdGl2ZV0gKz0gZmVlX3NldHVwCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICArCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NjctNTY4CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKFR4bi5zZW5kZXIpLCAiQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuIgogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBmcmVlX3VzZXIKICAgIGFzc2VydCAvLyBDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzAKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLmtleXNfbm90X2NvbmZpcm1lZChkZWxfYWNjOiBieXRlcykgLT4gdm9pZDoKa2V5c19ub3RfY29uZmlybWVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU3Mi01NzYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYga2V5c19ub3RfY29uZmlybWVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FjYzogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTc4CiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1NzkKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbZGVsX2FjYy5uYXRpdmVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTgxLTU4MwogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiQWNjb3VudCBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBieiBrZXlzX25vdF9jb25maXJtZWRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMQogICAgYnoga2V5c19ub3RfY29uZmlybWVkX2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIga2V5c19ub3RfY29uZmlybWVkX2Jvb2xfbWVyZ2VANAoKa2V5c19ub3RfY29uZmlybWVkX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgprZXlzX25vdF9jb25maXJtZWRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4MS01ODMKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIkFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYXNzZXJ0IC8vIEFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTg1LTU5MAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQua2V5c19ub3RfY29uZmlybWVkLAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgLy8gICAgIGFwcF9pZD12YWxfYXBwX2lkLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4NwogICAgLy8gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICBmcmFtZV9kaWcgMQogICAgaXRvYgogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4NS01OTAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIG1ldGhvZCAia2V5c19ub3RfY29uZmlybWVkKHVpbnQ2NCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTg5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjU4NS01OTAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo1OTEKICAgIC8vIHBsYXRmb3JtX2Vhcm5pbmcgPSByZXN1bHQubmF0aXZlCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTkzLTU5NAogICAgLy8gIyBSZWxlYXNlIGJsb2NrZWQgYmFsYW5jZSBpbiBOb3RpY2Vib2FyZCBmb3IgZWFybmluZ3Mgb2YgdGhlIHBsYXRmb3JtCiAgICAvLyBzZWxmLmJsb2NrZWRfYW10IC09IHBsYXRmb3JtX2Vhcm5pbmcKICAgIGludCAwCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgYmxvY2tlZF9hbXQgZXhpc3RzCiAgICBzd2FwCiAgICAtCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTk2LTU5NwogICAgLy8gIyBGcmVlIHVzZXIKICAgIC8vIGFzc2VydCBzZWxmLmZyZWVfdXNlcihkZWxfYWNjLm5hdGl2ZSksICJDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NTk5CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FjYzogYnl0ZXMpIC0+IHZvaWQ6CmVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MDEtNjA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hY2M6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgYnl0ZSAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYwOAogICAgLy8gdmFsX2FwcF9pZCA9IHNlbGYudmFsX2FwcF9pZFtkZWxfYWNjLm5hdGl2ZV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9hcHBfaWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjA5CiAgICAvLyBkZWxfYXBwX2lkID0gc2VsZi5kZWxfYXBwX2lkW2RlbF9hY2MubmF0aXZlXQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgYnl0ZSAiZGVsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYXBwX2lkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxMS02MTMKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIkFjY291bnQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBkZWxlZ2F0b3IgY29udHJhY3QuIgogICAgYnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDIKICAgIGJ6IGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDMKICAgIGludCAxCiAgICBiIGVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX21lcmdlQDQKCmVuZF9leHBpcmVkX29yX2JyZWFjaGVkX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MTEtNjEzCiAgICAvLyBhc3NlcnQgdmFsX2FwcF9pZCAhPSBVSW50NjQoMCkgYW5kIGRlbF9hcHBfaWQgIT0gVUludDY0KAogICAgLy8gICAgIDAKICAgIC8vICksICJBY2NvdW50IGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBBY2NvdW50IGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxNS02MTgKICAgIC8vICMgUmVhZCBnbG9iYWwgc3RhdGUgb2YgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfZW5kX3JvdW5kLCBkZWxfZW5kX3JvdW5kX2V4aXN0ID0gb3AuQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgLy8gKQogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxNwogICAgLy8gZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgYnl0ZSAicm91bmRfZW5kIgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYxNS02MTgKICAgIC8vICMgUmVhZCBnbG9iYWwgc3RhdGUgb2YgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfZW5kX3JvdW5kLCBkZWxfZW5kX3JvdW5kX2V4aXN0ID0gb3AuQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgZGVsX2FwcF9pZCwgQnl0ZXMoYiJyb3VuZF9lbmQiKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MTkKICAgIC8vIGFzc2VydCBkZWxfZW5kX3JvdW5kX2V4aXN0LCAiRGVsZWdhdG9yIGNvbnRyYWN0IGhhcyByb3VuZF9lbmQuIgogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBoYXMgcm91bmRfZW5kLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyMQogICAgLy8gZGVsX2FwcF9pZCwgQnl0ZXMoYiJjb250cmFjdF9icmVhY2hlZCIpCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2MjAtNjIyCiAgICAvLyBkZWxfY29udHJhY3RfYnJlYWNoZWQsIGRlbF9jb250cmFjdF9icmVhY2hlZF9leGlzdCA9IG9wLkFwcEdsb2JhbC5nZXRfZXhfdWludDY0KAogICAgLy8gICAgIGRlbF9hcHBfaWQsIEJ5dGVzKGIiY29udHJhY3RfYnJlYWNoZWQiKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyMwogICAgLy8gYXNzZXJ0IGRlbF9jb250cmFjdF9icmVhY2hlZF9leGlzdCwgIkRlbGVnYXRvciBjb250cmFjdCBoYXMgY29udHJhY3RfYnJlYWNoZWQuIgogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBoYXMgY29udHJhY3RfYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjI2CiAgICAvLyBkZWxfZW5kX3JvdW5kIDwgR2xvYmFsLnJvdW5kIG9yIGRlbF9jb250cmFjdF9icmVhY2hlZAogICAgZ2xvYmFsIFJvdW5kCiAgICA8CiAgICBibnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfdHJ1ZUA2CiAgICBmcmFtZV9kaWcgMAogICAgYnogZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VANwoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfdHJ1ZUA2OgogICAgaW50IDEKICAgIGIgZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfbWVyZ2VAOAoKZW5kX2V4cGlyZWRfb3JfYnJlYWNoZWRfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VANzoKICAgIGludCAwCgplbmRfZXhwaXJlZF9vcl9icmVhY2hlZF9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjYyNS02MjcKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZGVsX2VuZF9yb3VuZCA8IEdsb2JhbC5yb3VuZCBvciBkZWxfY29udHJhY3RfYnJlYWNoZWQKICAgIC8vICksICJBbnlvbmUgY2FuIGVuZCBjb250cmFjdCBpZiBpdCBoYXMgZXhwaXJlZCBhbHJlYWR5IG9yIHdhcyBicmVhY2hlZC4iCiAgICBhc3NlcnQgLy8gQW55b25lIGNhbiBlbmQgY29udHJhY3QgaWYgaXQgaGFzIGV4cGlyZWQgYWxyZWFkeSBvciB3YXMgYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjI5CiAgICAvLyBzZWxmLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FwcF9pZCwgdmFsX2FwcF9pZCwgZGVsX2FjYy5uYXRpdmUpCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBlbmRfZGVsZWdhdG9yX2NvbnRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjMxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfZGVsZWdhdG9yX2NvbnRyYWN0KGRlbF9hcHBfaWQ6IHVpbnQ2NCwgdmFsX2FwcF9pZDogdWludDY0LCBhY2M6IGJ5dGVzKSAtPiB2b2lkOgplbmRfZGVsZWdhdG9yX2NvbnRyYWN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY2MS02NzAKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIEludGVybmFsIGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZW5kX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHBfaWQ6IFVJbnQ2NCwKICAgIC8vICAgICB2YWxfYXBwX2lkOiBVSW50NjQsCiAgICAvLyAgICAgYWNjOiBBY2NvdW50LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njc1LTY4MAogICAgLy8gcmVzdWx0LCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBHZW5lcmFsVmFsaWRhdG9yQWQuZW5kX2RlbGVnYXRvcl9jb250cmFjdCwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKSwKICAgIC8vICAgICBhcHBfaWQ9dmFsX2FwcF9pZCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NzcKICAgIC8vIGFyYzQuVUludDY0KGRlbF9hcHBfaWQpLAogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY3NS02ODAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBtZXRob2QgImVuZF9kZWxlZ2F0b3JfY29udHJhY3QodWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njc5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY3NS02ODAKICAgIC8vIHJlc3VsdCwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgR2VuZXJhbFZhbGlkYXRvckFkLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QsCiAgICAvLyAgICAgYXJjNC5VSW50NjQoZGVsX2FwcF9pZCksCiAgICAvLyAgICAgYXBwX2lkPXZhbF9hcHBfaWQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjgxCiAgICAvLyBkZXBvc2l0ID0gcmVzdWx0LmEKICAgIGR1cAogICAgZXh0cmFjdCAwIDgKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2ODIKICAgIC8vIHJlZnVuZCA9IHJlc3VsdC5iCiAgICBkdXAKICAgIGV4dHJhY3QgOCA4CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjgzCiAgICAvLyBwbGF0Zm9ybV9lYXJuaW5nID0gcmVzdWx0LmMKICAgIGV4dHJhY3QgMTYgOAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY4NS02ODYKICAgIC8vICMgUmVsZWFzZSBibG9ja2VkIGJhbGFuY2UgaW4gTm90aWNlYm9hcmQgZm9yIGVhcm5pbmdzIG9mIHRoZSBwbGF0Zm9ybQogICAgLy8gc2VsZi5ibG9ja2VkX2FtdCAtPSBwbGF0Zm9ybV9lYXJuaW5nLm5hdGl2ZQogICAgaW50IDAKICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBibG9ja2VkX2FtdCBleGlzdHMKICAgIHN3YXAKICAgIGJ0b2kKICAgIC0KICAgIGJ5dGUgImJsb2NrZWRfYW10IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2ODgtNjg5CiAgICAvLyAjIFJldHVybiByZWZ1bmQgdW51c2VkIG9wZXJhdGlvbmFsIGZlZSB0byBkZWxlZ2F0b3IncyBiYWxhbmNlCiAgICAvLyBzZWxmLmJhbGFuY2VbYWNjXSArPSByZWZ1bmQubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBieXRlICJiYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGJhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBzd2FwCiAgICBidG9pCiAgICArCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGUgImJhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2OTEtNjkyCiAgICAvLyAjIFNldCBkZXBvc2l0IHRvIGRlbGVnYXRvcidzIGxvY2FsIHN0YXRlIC0gYmVjYXVzZSBpdCBjb3VsZCBoYXZlIGJlZW4gc2llemVkIGR1ZSB0byBicmVhY2hlcwogICAgLy8gc2VsZi5kZXBvc2l0X2FtdFthY2NdID0gZGVwb3NpdC5uYXRpdmUKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMQogICAgYnl0ZSAiZGVwb3NpdF9hbXQiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2OTQtNjk1CiAgICAvLyAjIEZyZWUgdXNlcgogICAgLy8gYXNzZXJ0IHNlbGYuZnJlZV91c2VyKGFjYyksICJDb3VsZG4ndCBmcmVlIGRlbGVnYXRvci4iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZnJlZV91c2VyCiAgICBhc3NlcnQgLy8gQ291bGRuJ3QgZnJlZSBkZWxlZ2F0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6Njk3CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ub3RpY2Vib2FyZC5jb250cmFjdC5Ob3RpY2Vib2FyZC5lbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdChrZXlyZWdfdHhuX2luZGV4OiBieXRlcykgLT4gdm9pZDoKZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjMzLTYzNwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBlbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGtleXJlZ190eG5faW5kZXg6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQwCiAgICAvLyB2YWxfYXBwX2lkID0gc2VsZi52YWxfYXBwX2lkW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NDEKICAgIC8vIGRlbF9hcHBfaWQgPSBzZWxmLmRlbF9hcHBfaWRbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICBieXRlICJkZWxfYXBwX2lkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGRlbF9hcHBfaWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQzLTY0NQogICAgLy8gYXNzZXJ0IHZhbF9hcHBfaWQgIT0gVUludDY0KDApIGFuZCBkZWxfYXBwX2lkICE9IFVJbnQ2NCgKICAgIC8vICAgICAwCiAgICAvLyApLCAiU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGJ6IGVuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDEKICAgIGJ6IGVuZF9hY3RpdmVfZGVsZWdhdG9yX2NvbnRyYWN0X2Jvb2xfZmFsc2VAMwogICAgaW50IDEKICAgIGIgZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA0CgplbmRfYWN0aXZlX2RlbGVnYXRvcl9jb250cmFjdF9ib29sX2ZhbHNlQDM6CiAgICBpbnQgMAoKZW5kX2FjdGl2ZV9kZWxlZ2F0b3JfY29udHJhY3RfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY0My02NDUKICAgIC8vIGFzc2VydCB2YWxfYXBwX2lkICE9IFVJbnQ2NCgwKSBhbmQgZGVsX2FwcF9pZCAhPSBVSW50NjQoCiAgICAvLyAgICAgMAogICAgLy8gKSwgIlNlbmRlciBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGRlbGVnYXRvciBjb250cmFjdC4iCiAgICBhc3NlcnQgLy8gU2VuZGVyIGRvZXNuJ3QgaGF2ZSBhbiBhY3RpdmUgZGVsZWdhdG9yIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY0OAogICAgLy8gR2xvYmFsLmdyb3VwX3NpemUgPT0gMgogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50IDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjQ3LTY0OQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAyCiAgICAvLyApLCAiQ2hlY2sgZ3R4biBzaXplIGlzIGV4YWN0bHkgdHdvIC0gYXBwIGNhbGwsIGFuZCBrZXkgZGVyZWcuIgogICAgYXNzZXJ0IC8vIENoZWNrIGd0eG4gc2l6ZSBpcyBleGFjdGx5IHR3byAtIGFwcCBjYWxsLCBhbmQga2V5IGRlcmVnLgogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjY1MgogICAgLy8gb3AuR1R4bi5zZW5kZXIoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpID09IFR4bi5zZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYnRvaQogICAgZHVwCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjUxLTY1MwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBvcC5HVHhuLnNlbmRlcihrZXlyZWdfdHhuX2luZGV4Lm5hdGl2ZSkgPT0gVHhuLnNlbmRlcgogICAgLy8gKSwgIktleSAoZGUpcmVnIGlzIGZyb20gdGhlIHNhbWUgYWNjb3VudCBhcyB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0LiIKICAgIGFzc2VydCAvLyBLZXkgKGRlKXJlZyBpcyBmcm9tIHRoZSBzYW1lIGFjY291bnQgYXMgdGhlIGRlbGVnYXRvciBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NTUKICAgIC8vIGFzc2VydCBpc19rZXlfZGVyZWcoa2V5cmVnX3R4bl9pbmRleC5uYXRpdmUpLCAiVHJhbnNhY3Rpb24gaXMgbm90IGtleSBkZXJlZy4iCiAgICBjYWxsc3ViIGlzX2tleV9kZXJlZwogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIG5vdCBrZXkgZGVyZWcuCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6NjU3CiAgICAvLyBzZWxmLmVuZF9kZWxlZ2F0b3JfY29udHJhY3QoZGVsX2FwcF9pZCwgdmFsX2FwcF9pZCwgVHhuLnNlbmRlcikKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgMAogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGVuZF9kZWxlZ2F0b3JfY29udHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo2NTkKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmhlbHBlcnMuY29tbW9uLmlzX2tleV9kZXJlZyh0eF9pZHg6IHVpbnQ2NCkgLT4gdWludDY0Ogppc19rZXlfZGVyZWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTUzLTE1NAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBpc19rZXlfZGVyZWcodHhfaWR4OiBVSW50NjQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTYKICAgIC8vIG9wLkdUeG4udHlwZV9lbnVtKHR4X2lkeCkgPT0gVHJhbnNhY3Rpb25UeXBlLktleVJlZ2lzdHJhdGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IGtleXJlZwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTUtMTU3CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG9wLkdUeG4udHlwZV9lbnVtKHR4X2lkeCkgPT0gVHJhbnNhY3Rpb25UeXBlLktleVJlZ2lzdHJhdGlvbgogICAgLy8gKSwgIktleSAoZGUpcmVnIHRyYW5zYWN0aW9uLiIKICAgIGFzc2VydCAvLyBLZXkgKGRlKXJlZyB0cmFuc2FjdGlvbi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNTktMTYwCiAgICAvLyAjIENoZWNrIGlmIGtleSByZWcgaXMgZGVyZWdpc3RyYXRpb24KICAgIC8vIGFzc2VydCBvcC5HVHhuLnNlbGVjdGlvbl9wayh0eF9pZHgpID09IG9wLmJ6ZXJvKDMyKQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZWxlY3Rpb25QSwogICAgaW50IDMyCiAgICBiemVybwogICAgZHVwCiAgICBjb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTYxCiAgICAvLyBhc3NlcnQgb3AuR1R4bi52b3RlX3BrKHR4X2lkeCkgPT0gb3AuYnplcm8oMzIpCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFZvdGVQSwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2MgogICAgLy8gYXNzZXJ0IG9wLkdUeG4uc3RhdGVfcHJvb2ZfcGsodHhfaWR4KSA9PSBvcC5iemVybyg2NCkKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU3RhdGVQcm9vZlBLCiAgICBpbnQgNjQKICAgIGJ6ZXJvCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6MTYzCiAgICAvLyBhc3NlcnQgb3AuR1R4bi52b3RlX2tleV9kaWx1dGlvbih0eF9pZHgpID09IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBWb3RlS2V5RGlsdXRpb24KICAgICEKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2NAogICAgLy8gYXNzZXJ0IG9wLkdUeG4udm90ZV9maXJzdCh0eF9pZHgpID09IFVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBWb3RlRmlyc3QKICAgICEKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjE2NQogICAgLy8gYXNzZXJ0IG9wLkdUeG4udm90ZV9sYXN0KHR4X2lkeCkgPT0gVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFZvdGVMYXN0CiAgICAhCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weToxNjcKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLm5vdGljZWJvYXJkLmNvbnRyYWN0Lk5vdGljZWJvYXJkLl9faW5pdF9fKCkgLT4gdm9pZDoKX19pbml0X186CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6ODgKICAgIC8vIGRlZiBfX2luaXRfXyhzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6ODktOTAKICAgIC8vICMgRGVmaW5lIGdsb2JhbCBzdGF0ZQogICAgLy8gc2VsZi5kZXBvc2l0X3ZhbF9taW4gPSBVSW50NjQoMCkKICAgIGJ5dGUgImRlcG9zaXRfdmFsX21pbiIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5OjkxCiAgICAvLyBzZWxmLmRlcG9zaXRfZGVsX21pbiA9IFVJbnQ2NCgwKQogICAgYnl0ZSAiZGVwb3NpdF9kZWxfbWluIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbm90aWNlYm9hcmQvY29udHJhY3QucHk6OTIKICAgIC8vIHNlbGYudmFsX2Vhcm5fZmFjdG9yID0gVUludDY0KDApCiAgICBieXRlICJ2YWxfZWFybl9mYWN0b3IiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo5MwogICAgLy8gc2VsZi52YWxfZmFjdG9yeV9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGUgInZhbF9mYWN0b3J5X2FwcF9pZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojk0CiAgICAvLyBzZWxmLm1hbmFnZXIgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlICJtYW5hZ2VyIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojk2CiAgICAvLyBzZWxmLmxpdmUgPSBGYWxzZQogICAgYnl0ZSAibGl2ZSIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL25vdGljZWJvYXJkL2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBzZWxmLmJsb2NrZWRfYW10ID0gVUludDY0KDApCiAgICBieXRlICJibG9ja2VkX2FtdCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMubm90aWNlYm9hcmQuY29udHJhY3QuTm90aWNlYm9hcmQuY2xlYXJfc3RhdGVfcHJvZ3JhbToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ub3RpY2Vib2FyZC9jb250cmFjdC5weTo0My00NAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIE5vdGljZWJvYXJkKEFSQzRDb250cmFjdCk6CiAgICBpbnQgMQogICAgcmV0dXJuCg=="
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 6
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 4
    }
  },
  "schema": {
    "global": {
      "declared": {
        "blocked_amt": {
          "type": "uint64",
          "key": "blocked_amt"
        },
        "deposit_del_min": {
          "type": "uint64",
          "key": "deposit_del_min"
        },
        "deposit_val_min": {
          "type": "uint64",
          "key": "deposit_val_min"
        },
        "live": {
          "type": "uint64",
          "key": "live"
        },
        "manager": {
          "type": "bytes",
          "key": "manager"
        },
        "val_earn_factor": {
          "type": "uint64",
          "key": "val_earn_factor"
        },
        "val_factory_app_id": {
          "type": "uint64",
          "key": "val_factory_app_id"
        }
      },
      "reserved": {}
    },
    "local": {
      "declared": {
        "balance": {
          "type": "uint64",
          "key": "balance"
        },
        "del_app_id": {
          "type": "uint64",
          "key": "del_app_id"
        },
        "deposit_amt": {
          "type": "uint64",
          "key": "deposit_amt"
        },
        "val_app_id": {
          "type": "uint64",
          "key": "val_app_id"
        }
      },
      "reserved": {}
    }
  },
  "contract": {
    "name": "Noticeboard",
    "desc": "\n    Platform for peer-to-peer consensus delegation.\n    Node runners, i.e. validators can post ads to offer their services to users.\n    Users, i.e. delegators, can open requests for the service and conclude a contract with a node runner.\n\n    Global state\n    ------------\n        Configuration parameters\n        ------------------------\n        deposit_val_min : UInt64\n            Minimum deposit required to be made by validator to the Noticeboard\n        deposit_del_min : UInt64\n            Minimum deposit required to be made by delegator to the Noticeboard\n        val_earn_factor : UInt64\n            Value scaled to (1-0), representing 1 - percentage of fees taken by the platform\n\n        Variables\n        ---------\n        live : bool\n            Whether the contract is live (true) or has ended (false)\n        blocked_amt : UInt64\n            Balance on the Noticeboard account that can't be withdrawn.\n            It is part either of active deposits or not finalized payments.\n\n    Local state\n    -----------\n        val_app_id : UInt64\n            GeneralValidatorAd ID of the asccount - either as owner of validator or selected validator for UserContract\n        del_app_id : UInt64\n            UserContract ID of the account if the account is user; equals 0 for validator accounts.\n        deposit_amt : UInt64\n            Amount the account has deposited in the Noticeboard\n\n    Boxes\n    -----\n        val_list : Box\n            {key = val_id, value = [val_app_id: UInt64, prev_val_id: UInt64, next_val_id: UInt64] }\n\n    Methods\n    -------\n\n    ",
    "methods": [
      {
        "name": "setup",
        "args": [
          {
            "type": "uint64",
            "name": "deposit_val_min"
          },
          {
            "type": "uint64",
            "name": "deposit_del_min"
          },
          {
            "type": "uint64",
            "name": "val_earn_factor"
          },
          {
            "type": "uint64",
            "name": "val_factory_app_id"
          },
          {
            "type": "address",
            "name": "manager"
          },
          {
            "type": "pay",
            "name": "mbr"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "create_validator_ad",
        "args": [
          {
            "type": "pay",
            "name": "deposit"
          },
          {
            "type": "pay",
            "name": "mbr_factory"
          },
          {
            "type": "pay",
            "name": "mbr_val"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "set_validator_ad_mandatory",
        "args": [
          {
            "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
            "name": "val_config_man"
          },
          {
            "type": "bool",
            "name": "live"
          },
          {
            "type": "address",
            "name": "manager"
          },
          {
            "type": "uint64",
            "name": "max_del_cnt"
          }
        ],
        "returns": {
          "type": "void"
        },
        "desc": "Creates or updates mandatory part of validator ad and sets liveliness status"
      },
      {
        "name": "set_validator_ad_extra",
        "args": [
          {
            "type": "(byte[30],byte[70])",
            "name": "val_config_extra"
          }
        ],
        "returns": {
          "type": "void"
        },
        "desc": "Creates or updates extra part of validator ad"
      },
      {
        "name": "end_validator_ad",
        "args": [],
        "returns": {
          "type": "void"
        },
        "desc": "Sender can delete the validator ad."
      },
      {
        "name": "val_withdraw_earnings",
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "withdraw_balance",
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "withdraw_depoist",
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "user_opt_in",
        "args": [],
        "returns": {
          "type": "void"
        },
        "desc": "assert not Txn.sender.is_opted_in(\nGlobal.current_application_id ), \"Account has already opted-in the app.\""
      },
      {
        "name": "create_delegator_contract",
        "args": [
          {
            "type": "uint64",
            "name": "val_app_id"
          },
          {
            "type": "pay",
            "name": "deposit_payment"
          },
          {
            "type": "pay",
            "name": "fee_setup_payment"
          },
          {
            "type": "pay",
            "name": "mbr"
          },
          {
            "type": "uint64",
            "name": "round_start"
          },
          {
            "type": "uint64",
            "name": "round_end"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "deposit_keys",
        "args": [
          {
            "type": "address",
            "name": "del_acc"
          },
          {
            "type": "byte[32]",
            "name": "sel_key"
          },
          {
            "type": "byte[32]",
            "name": "vote_key"
          },
          {
            "type": "byte[64]",
            "name": "state_proof_key"
          },
          {
            "type": "uint64",
            "name": "vote_key_dilution"
          },
          {
            "type": "uint64",
            "name": "round_start"
          },
          {
            "type": "uint64",
            "name": "round_end"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "confirm_keys",
        "args": [
          {
            "type": "uint64",
            "name": "keyreg_txn_index"
          },
          {
            "type": "pay",
            "name": "fee_operation_payment"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "keys_not_generated",
        "args": [
          {
            "type": "address",
            "name": "del_acc"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "keys_not_confirmed",
        "args": [
          {
            "type": "address",
            "name": "del_acc"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "end_expired_or_breached_delegator_contract",
        "args": [
          {
            "type": "address",
            "name": "del_acc"
          }
        ],
        "returns": {
          "type": "void"
        },
        "desc": "Anyone can delete the delegator contract after its expiry or when it was breached."
      },
      {
        "name": "end_active_delegator_contract",
        "args": [
          {
            "type": "uint64",
            "name": "keyreg_txn_index"
          }
        ],
        "returns": {
          "type": "void"
        },
        "desc": "Delegator can withdraw from contract and get refunded remaining operational fee."
      }
    ],
    "networks": {}
  },
  "bare_call_config": {
    "no_op": "CREATE"
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

export type IncludeSchema = {
  /**
   * Any overrides for the storage schema to request for the created app; by default the schema indicated by the app spec is used.
   */
  schema?: Partial<AppStorageSchema>
}

/**
 * Defines the types of available calls and state of the Noticeboard smart contract.
 */
export type Noticeboard = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'setup(uint64,uint64,uint64,uint64,address,pay)void' | 'setup', {
      argsObj: {
        depositValMin: bigint | number
        depositDelMin: bigint | number
        valEarnFactor: bigint | number
        valFactoryAppId: bigint | number
        manager: string
        mbr: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [depositValMin: bigint | number, depositDelMin: bigint | number, valEarnFactor: bigint | number, valFactoryAppId: bigint | number, manager: string, mbr: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'create_validator_ad(pay,pay,pay)void' | 'create_validator_ad', {
      argsObj: {
        deposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        mbrFactory: TransactionToSign | Transaction | Promise<SendTransactionResult>
        mbrVal: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [deposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, mbrFactory: TransactionToSign | Transaction | Promise<SendTransactionResult>, mbrVal: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void' | 'set_validator_ad_mandatory', {
      argsObj: {
        valConfigMan: [bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number]
        live: boolean
        manager: string
        maxDelCnt: bigint | number
      }
      argsTuple: [valConfigMan: [bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number, bigint | number], live: boolean, manager: string, maxDelCnt: bigint | number]
      returns: void
    }>
    & Record<'set_validator_ad_extra((byte[30],byte[70]))void' | 'set_validator_ad_extra', {
      argsObj: {
        valConfigExtra: [Uint8Array, Uint8Array]
      }
      argsTuple: [valConfigExtra: [Uint8Array, Uint8Array]]
      returns: void
    }>
    & Record<'end_validator_ad()void' | 'end_validator_ad', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'val_withdraw_earnings()uint64' | 'val_withdraw_earnings', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'withdraw_balance()uint64' | 'withdraw_balance', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'withdraw_depoist()uint64' | 'withdraw_depoist', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'user_opt_in()void' | 'user_opt_in', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void' | 'create_delegator_contract', {
      argsObj: {
        valAppId: bigint | number
        depositPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>
        feeSetupPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>
        mbr: TransactionToSign | Transaction | Promise<SendTransactionResult>
        roundStart: bigint | number
        roundEnd: bigint | number
      }
      argsTuple: [valAppId: bigint | number, depositPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>, feeSetupPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>, mbr: TransactionToSign | Transaction | Promise<SendTransactionResult>, roundStart: bigint | number, roundEnd: bigint | number]
      returns: void
    }>
    & Record<'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void' | 'deposit_keys', {
      argsObj: {
        delAcc: string
        selKey: Uint8Array
        voteKey: Uint8Array
        stateProofKey: Uint8Array
        voteKeyDilution: bigint | number
        roundStart: bigint | number
        roundEnd: bigint | number
      }
      argsTuple: [delAcc: string, selKey: Uint8Array, voteKey: Uint8Array, stateProofKey: Uint8Array, voteKeyDilution: bigint | number, roundStart: bigint | number, roundEnd: bigint | number]
      returns: void
    }>
    & Record<'confirm_keys(uint64,pay)void' | 'confirm_keys', {
      argsObj: {
        keyregTxnIndex: bigint | number
        feeOperationPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [keyregTxnIndex: bigint | number, feeOperationPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'keys_not_generated(address)void' | 'keys_not_generated', {
      argsObj: {
        delAcc: string
      }
      argsTuple: [delAcc: string]
      returns: void
    }>
    & Record<'keys_not_confirmed(address)void' | 'keys_not_confirmed', {
      argsObj: {
        delAcc: string
      }
      argsTuple: [delAcc: string]
      returns: void
    }>
    & Record<'end_expired_or_breached_delegator_contract(address)void' | 'end_expired_or_breached_delegator_contract', {
      argsObj: {
        delAcc: string
      }
      argsTuple: [delAcc: string]
      returns: void
    }>
    & Record<'end_active_delegator_contract(uint64)void' | 'end_active_delegator_contract', {
      argsObj: {
        keyregTxnIndex: bigint | number
      }
      argsTuple: [keyregTxnIndex: bigint | number]
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      blockedAmt?: IntegerState
      depositDelMin?: IntegerState
      depositValMin?: IntegerState
      live?: IntegerState
      manager?: BinaryState
      valEarnFactor?: IntegerState
      valFactoryAppId?: IntegerState
    }
    local: {
      balance?: IntegerState
      delAppId?: IntegerState
      depositAmt?: IntegerState
      valAppId?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type NoticeboardSig = keyof Noticeboard['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends NoticeboardSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Represents a ValConfigMan result as a struct
 */
export type ValConfigMan = {
  hwCat: bigint
  minAmt: bigint
  maxAmt: bigint
  feeSetup: bigint
  feeRound: bigint
  deposit: bigint
  setupRounds: bigint
  confirmationRounds: bigint
  maxBreach: bigint
  breachRounds: bigint
  uptimeGar: bigint
}
/**
 * Converts the tuple representation of a ValConfigMan to the struct representation
 */
export function ValConfigMan([hwCat, minAmt, maxAmt, feeSetup, feeRound, deposit, setupRounds, confirmationRounds, maxBreach, breachRounds, uptimeGar]: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint] ) {
  return {
    hwCat,
    minAmt,
    maxAmt,
    feeSetup,
    feeRound,
    deposit,
    setupRounds,
    confirmationRounds,
    maxBreach,
    breachRounds,
    uptimeGar,
  }
}
/**
 * Represents a ValConfigExtra result as a struct
 */
export type ValConfigExtra = {
  name: Uint8Array
  link: Uint8Array
}
/**
 * Converts the tuple representation of a ValConfigExtra to the struct representation
 */
export function ValConfigExtra([name, link]: [Uint8Array, Uint8Array] ) {
  return {
    name,
    link,
  }
}
/**
 * Maps a method signature from the Noticeboard smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends NoticeboardSig> = Noticeboard['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the Noticeboard smart contract to the method's return type
 */
export type MethodReturn<TSignature extends NoticeboardSig> = Noticeboard['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type NoticeboardCreateCalls = (typeof NoticeboardCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type NoticeboardCreateCallParams =
  | (TypedCallParams<undefined> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type NoticeboardDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: NoticeboardCreateCalls) => NoticeboardCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class NoticeboardCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the Noticeboard smart contract using a bare call
       *
       * @param params Any parameters for the call
       * @returns A TypedCallParams object for the call
       */
      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: undefined,
          methodArgs: undefined,
          ...params,
        }
      },
    }
  }

  /**
   * Gets available optIn call factories
   */
  static get optIn() {
    return {
      /**
       * Constructs an opt in call for the Noticeboard smart contract using the user_opt_in()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      userOptIn(args: MethodArgs<'user_opt_in()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return {
          method: 'user_opt_in()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the setup(uint64,uint64,uint64,uint64,address,pay)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setup(args: MethodArgs<'setup(uint64,uint64,uint64,uint64,address,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'setup(uint64,uint64,uint64,uint64,address,pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.depositValMin, args.depositDelMin, args.valEarnFactor, args.valFactoryAppId, args.manager, args.mbr],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the create_validator_ad(pay,pay,pay)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static createValidatorAd(args: MethodArgs<'create_validator_ad(pay,pay,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'create_validator_ad(pay,pay,pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.deposit, args.mbrFactory, args.mbrVal],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void ABI method
   *
   * Creates or updates mandatory part of validator ad and sets liveliness status
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setValidatorAdMandatory(args: MethodArgs<'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valConfigMan, args.live, args.manager, args.maxDelCnt],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the set_validator_ad_extra((byte[30],byte[70]))void ABI method
   *
   * Creates or updates extra part of validator ad
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setValidatorAdExtra(args: MethodArgs<'set_validator_ad_extra((byte[30],byte[70]))void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'set_validator_ad_extra((byte[30],byte[70]))void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valConfigExtra],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the end_validator_ad()void ABI method
   *
   * Sender can delete the validator ad.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static endValidatorAd(args: MethodArgs<'end_validator_ad()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'end_validator_ad()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the val_withdraw_earnings()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static valWithdrawEarnings(args: MethodArgs<'val_withdraw_earnings()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'val_withdraw_earnings()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the withdraw_balance()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static withdrawBalance(args: MethodArgs<'withdraw_balance()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'withdraw_balance()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the withdraw_depoist()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static withdrawDepoist(args: MethodArgs<'withdraw_depoist()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'withdraw_depoist()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static createDelegatorContract(args: MethodArgs<'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valAppId, args.depositPayment, args.feeSetupPayment, args.mbr, args.roundStart, args.roundEnd],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static depositKeys(args: MethodArgs<'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delAcc, args.selKey, args.voteKey, args.stateProofKey, args.voteKeyDilution, args.roundStart, args.roundEnd],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the confirm_keys(uint64,pay)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static confirmKeys(args: MethodArgs<'confirm_keys(uint64,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'confirm_keys(uint64,pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.keyregTxnIndex, args.feeOperationPayment],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_not_generated(address)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysNotGenerated(args: MethodArgs<'keys_not_generated(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_not_generated(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delAcc],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_not_confirmed(address)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_not_confirmed(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delAcc],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the end_expired_or_breached_delegator_contract(address)void ABI method
   *
   * Anyone can delete the delegator contract after its expiry or when it was breached.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static endExpiredOrBreachedDelegatorContract(args: MethodArgs<'end_expired_or_breached_delegator_contract(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'end_expired_or_breached_delegator_contract(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delAcc],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the end_active_delegator_contract(uint64)void ABI method
   *
   * Delegator can withdraw from contract and get refunded remaining operational fee.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static endActiveDelegatorContract(args: MethodArgs<'end_active_delegator_contract(uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'end_active_delegator_contract(uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.keyregTxnIndex],
      ...params,
    }
  }
}

/**
 * A client to make calls to the Noticeboard smart contract
 */
export class NoticeboardClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `NoticeboardClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof Noticeboard['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the Noticeboard smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: NoticeboardDeployArgs & AppClientDeployCoreParams & IncludeSchema = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(NoticeboardCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the Noticeboard smart contract using a bare call.
       *
       * @param args The arguments for the bare call
       * @returns The create result
       */
      async bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & IncludeSchema & CoreAppCallArgs & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<undefined, AppCreateCallTransactionResult>(await $this.appClient.create(args))
      },
    }
  }

  /**
   * Gets available optIn methods
   */
  public get optIn() {
    const $this = this
    return {
      /**
       * Opts the user into an existing instance of the Noticeboard smart contract using the user_opt_in()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The optIn result
       */
      async userOptIn(args: MethodArgs<'user_opt_in()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return $this.mapReturnValue<MethodReturn<'user_opt_in()void'>>(await $this.appClient.optIn(NoticeboardCallFactory.optIn.userOptIn(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the Noticeboard smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the setup(uint64,uint64,uint64,uint64,address,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setup(args: MethodArgs<'setup(uint64,uint64,uint64,uint64,address,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.setup(args, params))
  }

  /**
   * Calls the create_validator_ad(pay,pay,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public createValidatorAd(args: MethodArgs<'create_validator_ad(pay,pay,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.createValidatorAd(args, params))
  }

  /**
   * Calls the set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void ABI method.
   *
   * Creates or updates mandatory part of validator ad and sets liveliness status
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setValidatorAdMandatory(args: MethodArgs<'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.setValidatorAdMandatory(args, params))
  }

  /**
   * Calls the set_validator_ad_extra((byte[30],byte[70]))void ABI method.
   *
   * Creates or updates extra part of validator ad
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setValidatorAdExtra(args: MethodArgs<'set_validator_ad_extra((byte[30],byte[70]))void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.setValidatorAdExtra(args, params))
  }

  /**
   * Calls the end_validator_ad()void ABI method.
   *
   * Sender can delete the validator ad.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public endValidatorAd(args: MethodArgs<'end_validator_ad()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.endValidatorAd(args, params))
  }

  /**
   * Calls the val_withdraw_earnings()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public valWithdrawEarnings(args: MethodArgs<'val_withdraw_earnings()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.valWithdrawEarnings(args, params))
  }

  /**
   * Calls the withdraw_balance()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public withdrawBalance(args: MethodArgs<'withdraw_balance()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.withdrawBalance(args, params))
  }

  /**
   * Calls the withdraw_depoist()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public withdrawDepoist(args: MethodArgs<'withdraw_depoist()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.withdrawDepoist(args, params))
  }

  /**
   * Calls the create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public createDelegatorContract(args: MethodArgs<'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.createDelegatorContract(args, params))
  }

  /**
   * Calls the deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public depositKeys(args: MethodArgs<'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.depositKeys(args, params))
  }

  /**
   * Calls the confirm_keys(uint64,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public confirmKeys(args: MethodArgs<'confirm_keys(uint64,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.confirmKeys(args, params))
  }

  /**
   * Calls the keys_not_generated(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public keysNotGenerated(args: MethodArgs<'keys_not_generated(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.keysNotGenerated(args, params))
  }

  /**
   * Calls the keys_not_confirmed(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.keysNotConfirmed(args, params))
  }

  /**
   * Calls the end_expired_or_breached_delegator_contract(address)void ABI method.
   *
   * Anyone can delete the delegator contract after its expiry or when it was breached.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public endExpiredOrBreachedDelegatorContract(args: MethodArgs<'end_expired_or_breached_delegator_contract(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.endExpiredOrBreachedDelegatorContract(args, params))
  }

  /**
   * Calls the end_active_delegator_contract(uint64)void ABI method.
   *
   * Delegator can withdraw from contract and get refunded remaining operational fee.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public endActiveDelegatorContract(args: MethodArgs<'end_active_delegator_contract(uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NoticeboardCallFactory.endActiveDelegatorContract(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<Noticeboard['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get blockedAmt() {
        return NoticeboardClient.getIntegerState(state, 'blocked_amt')
      },
      get depositDelMin() {
        return NoticeboardClient.getIntegerState(state, 'deposit_del_min')
      },
      get depositValMin() {
        return NoticeboardClient.getIntegerState(state, 'deposit_val_min')
      },
      get live() {
        return NoticeboardClient.getIntegerState(state, 'live')
      },
      get manager() {
        return NoticeboardClient.getBinaryState(state, 'manager')
      },
      get valEarnFactor() {
        return NoticeboardClient.getIntegerState(state, 'val_earn_factor')
      },
      get valFactoryAppId() {
        return NoticeboardClient.getIntegerState(state, 'val_factory_app_id')
      },
    }
  }

  /**
   * Returns the smart contract's local state wrapped in a strongly typed accessor with options to format the stored value
   *
   * @param account The address of the account for which to read local state from
   */
  public async getLocalState(account: string | SendTransactionFrom): Promise<Noticeboard['state']['local']> {
    const state = await this.appClient.getLocalState(account)
    return {
      get balance() {
        return NoticeboardClient.getIntegerState(state, 'balance')
      },
      get delAppId() {
        return NoticeboardClient.getIntegerState(state, 'del_app_id')
      },
      get depositAmt() {
        return NoticeboardClient.getIntegerState(state, 'deposit_amt')
      },
      get valAppId() {
        return NoticeboardClient.getIntegerState(state, 'val_app_id')
      },
    }
  }

  public compose(): NoticeboardComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      setup(args: MethodArgs<'setup(uint64,uint64,uint64,uint64,address,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.setup(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      createValidatorAd(args: MethodArgs<'create_validator_ad(pay,pay,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.createValidatorAd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      setValidatorAdMandatory(args: MethodArgs<'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.setValidatorAdMandatory(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      setValidatorAdExtra(args: MethodArgs<'set_validator_ad_extra((byte[30],byte[70]))void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.setValidatorAdExtra(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      endValidatorAd(args: MethodArgs<'end_validator_ad()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.endValidatorAd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      valWithdrawEarnings(args: MethodArgs<'val_withdraw_earnings()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.valWithdrawEarnings(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      withdrawBalance(args: MethodArgs<'withdraw_balance()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.withdrawBalance(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      withdrawDepoist(args: MethodArgs<'withdraw_depoist()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.withdrawDepoist(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      createDelegatorContract(args: MethodArgs<'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.createDelegatorContract(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      depositKeys(args: MethodArgs<'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.depositKeys(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      confirmKeys(args: MethodArgs<'confirm_keys(uint64,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.confirmKeys(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      keysNotGenerated(args: MethodArgs<'keys_not_generated(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysNotGenerated(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysNotConfirmed(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      endExpiredOrBreachedDelegatorContract(args: MethodArgs<'end_expired_or_breached_delegator_contract(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.endExpiredOrBreachedDelegatorContract(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      endActiveDelegatorContract(args: MethodArgs<'end_active_delegator_contract(uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.endActiveDelegatorContract(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      get optIn() {
        const $this = this
        return {
          userOptIn(args: MethodArgs<'user_opt_in()void'>, params?: AppClientComposeCallCoreParams) {
            promiseChain = promiseChain.then(() => client.optIn.userOptIn(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as NoticeboardComposer
  }
}
export type NoticeboardComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the setup(uint64,uint64,uint64,uint64,address,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setup(args: MethodArgs<'setup(uint64,uint64,uint64,uint64,address,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'setup(uint64,uint64,uint64,uint64,address,pay)void'>]>

  /**
   * Calls the create_validator_ad(pay,pay,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createValidatorAd(args: MethodArgs<'create_validator_ad(pay,pay,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'create_validator_ad(pay,pay,pay)void'>]>

  /**
   * Calls the set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void ABI method.
   *
   * Creates or updates mandatory part of validator ad and sets liveliness status
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setValidatorAdMandatory(args: MethodArgs<'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'set_validator_ad_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),bool,address,uint64)void'>]>

  /**
   * Calls the set_validator_ad_extra((byte[30],byte[70]))void ABI method.
   *
   * Creates or updates extra part of validator ad
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setValidatorAdExtra(args: MethodArgs<'set_validator_ad_extra((byte[30],byte[70]))void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'set_validator_ad_extra((byte[30],byte[70]))void'>]>

  /**
   * Calls the end_validator_ad()void ABI method.
   *
   * Sender can delete the validator ad.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  endValidatorAd(args: MethodArgs<'end_validator_ad()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'end_validator_ad()void'>]>

  /**
   * Calls the val_withdraw_earnings()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  valWithdrawEarnings(args: MethodArgs<'val_withdraw_earnings()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'val_withdraw_earnings()uint64'>]>

  /**
   * Calls the withdraw_balance()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdrawBalance(args: MethodArgs<'withdraw_balance()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'withdraw_balance()uint64'>]>

  /**
   * Calls the withdraw_depoist()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdrawDepoist(args: MethodArgs<'withdraw_depoist()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'withdraw_depoist()uint64'>]>

  /**
   * Calls the create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createDelegatorContract(args: MethodArgs<'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'create_delegator_contract(uint64,pay,pay,pay,uint64,uint64)void'>]>

  /**
   * Calls the deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  depositKeys(args: MethodArgs<'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'deposit_keys(address,byte[32],byte[32],byte[64],uint64,uint64,uint64)void'>]>

  /**
   * Calls the confirm_keys(uint64,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  confirmKeys(args: MethodArgs<'confirm_keys(uint64,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'confirm_keys(uint64,pay)void'>]>

  /**
   * Calls the keys_not_generated(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysNotGenerated(args: MethodArgs<'keys_not_generated(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'keys_not_generated(address)void'>]>

  /**
   * Calls the keys_not_confirmed(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'keys_not_confirmed(address)void'>]>

  /**
   * Calls the end_expired_or_breached_delegator_contract(address)void ABI method.
   *
   * Anyone can delete the delegator contract after its expiry or when it was breached.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  endExpiredOrBreachedDelegatorContract(args: MethodArgs<'end_expired_or_breached_delegator_contract(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'end_expired_or_breached_delegator_contract(address)void'>]>

  /**
   * Calls the end_active_delegator_contract(uint64)void ABI method.
   *
   * Delegator can withdraw from contract and get refunded remaining operational fee.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  endActiveDelegatorContract(args: MethodArgs<'end_active_delegator_contract(uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, MethodReturn<'end_active_delegator_contract(uint64)void'>]>

  /**
   * Gets available optIn methods
   */
  readonly optIn: {
    /**
     * Opts the user into an existing instance of the Noticeboard smart contract using the user_opt_in()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    userOptIn(args: MethodArgs<'user_opt_in()void'>, params?: AppClientComposeCallCoreParams): NoticeboardComposer<[...TReturns, MethodReturn<'user_opt_in()void'>]>
  }

  /**
   * Makes a clear_state call to an existing instance of the Noticeboard smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): NoticeboardComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): NoticeboardComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<NoticeboardComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<NoticeboardComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type NoticeboardComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type NoticeboardComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
